{
  "title": "Step Complex Xml Writer",
  "headers": [
    "Contents:",
    "Step Complex Xml Writer",
    "Properties",
    "Detailed Description",
    "Element Complex Xml Writer Object Stream Cfg",
    "Properties",
    "Element Complex Xml Writer Object Substream Cfg",
    "Properties",
    "Element Data Format Parameters",
    "Properties",
    "Detailed Description"
  ],
  "content": "This step creates output XML file according to the template. Without any advanced configuration,\n\t\t\tthe template is simply written to the output file. For filling it dynamically with some data, we will\n\t\t\tneed objects.\n\nAn object is a stream of records, and the columns of the records are attributes\n\t\t\tof this object. When a new object is added, a new input of the same name is automatically created for reading\n\t\t\tthese records. When we do have an object and we connect a data stream to its input, we can use it in the template.\n\t\t\tThis is simply done by including an element with the same name as the object. That causes this element to be\n\t\t\tentirely replaced by the XML representation of the object - actually, by one representation for every record read from the input\n\nThe XML representation of the object is done in very similar way - by its own XML template. But here, we are inside the object,\n\t\t\tand we can use its attributes - columns of the original records - as text values of nodes or attributes of elements. Attribute is\n\t\t\treferenced by its name in curly brackets.\n\nThe default behavior for handling null values is omitting the entire XML element for all column types except of STRING, which will\n\t\t\tinclude the element with empty content. This behavior can be changed by putting additional flag after the column name inside the\n\t\t\tcurly brackets. This can be either a question mark (?) or an exclamation mark (!). The former removes the entire XML element for\n\t\t\ta null value of the column. The latter forces the XML element with empty content for null value.\n\nXML template of objects is not a standalone XML and is not limited to single root element.\n\nAny object can have subobjects - more complex attributes that are read from their own input streams and are joined with parent\n\t\t\tobject exactly the same way as in inner join of tables. The attributes/columns for join are specified in the inner objects, in\n\t\t\tthe parameterColumn Binding. Inner objects are objects as well and can also have subobjects, etc.\n\nThis step supports encodings supported by Java, including Unicode formats. Available encodings are listed in step configuration.\n\nData format parameters are parameters used for data formatting when an\n\t\t\t\tinternal/external data format conversion is required. This task typically\n\t\t\t\toccurs when [branding:product.name.abbreviation] needs to load data from an external file or needs to store\n\t\t\t\tdata to an external file. Data format parameters then describe how\n\t\t\t\tto convert data to the desired form based on the reading and writing file data formats.\n\nProcessing steps supporting DataFormatParameters (DFP) can define DFP at the top level\n\t\t\t\tof a step as well as on the \"local\" level of each column. If there are no\n\t\t\t\tDFP defined on the local level, the global DFP are used. If global data format parameters\n\t\t\t\tare not defined, the default values are assumed. When a column defines its own DFP,\n\t\t\t\tthis DFP must contain all attributes needed for successful parsing (those attributes\n\t\t\t\tmust be assigned valid values). The only exception to this rule isThousands Separator.\n\t\t\t\tIn contrast with the rest of DFP attributes that must always have some value,Thousands Separatormay remain empty (meaning that no thousands\n\t\t\t\tseparator is used).\n\nDefines the locale for parsing non-numerical data (for example short forms of months in dates -\n\t\t\t\te.g., Sep 18, 1999). The value is the same as the value of the corresponding locale in Java\n\t\t\t\t(for detail seeJava locales).\n\nDefines the format that should be used for processing 'datetime' data. The template is\n\t\t\t\tbased onSimpleDateFormat, which uses the Java convention.\n\nDefines the format that should be used for processing 'date' data. The template is based onSimpleDateFormat, which uses the Java convention.\n\nDefines what character is used as the decimal separator.Escaped string property.\n\nString value that represents a logical 'false' value in the given data. The comparison is\n\t\t\t\tnot case sensitive.\n\nDefines the string that represents the thousands separator (used in numbers). A non-escaped\n\t\t\t\tcharacter is expected. Numbers to be read do not need to contain this separator, but\n\t\t\t\twhen the separator is present it is processed (stripped) accordingly.Escaped string property.\n\nString value representing a logical 'true' value in the given data. The comparison is not case\n\t\t\t\tsensitive.\n\nFor datetime and date types there is an existing output format defined. This format definition is given by a\n\t\t\t\t\ttextual string that follows the convention used in the JavaSimpleDateFormat.\n\nThe meanings of the most used characters in the formatting string are as follows:y ... year, M ... month in year, d ... day in month. By changing the number of those\n\t\t\t\t\tformatting characters it is possible to change the meaning of the characters.NOTE: the formatting string is case sensitive, so the same character has different\n\t\t\t\t\tmeaning when used as upper or lower case.\n\nReading a year:If the formatting string contains more than two characters, then the input number\n\t\t\t\t\tis interpreted as is, without accounting for the century.If the formatting string contains a shortened version (\"y\" or \"yy\"), then the input\n\t\t\t\t\tnumber is parsed against the current data where the resulting date is in the range -80, +20 years\n\t\t\t\t\tfrom the current date. It is important to note that the number of digits in the year must\n\t\t\t\t\tstrictly comply with the number of its formatting characters. Otherwise, the year is\n\t\t\t\t\tread as specified in the input (for format '..yy' and input '...765' the\n\t\t\t\t\tresulting year is 765.\n\nYear output format:If the formatting string includes the \"yy\" form, then the year is transformed into 2 characters,\n\t\t\t\t\totherwise it is formatted as the original number (including completion).\n\nMonth output format:If the number of formatting characters for month is >=3,\n\t\t\t\t\tthen the output is the full month's name (for example, January), otherwise the output\n\t\t\t\t\tis represented by the number (so, for January, it is 1).\n\nNumerical output format:Numerical padding functionality dictates there must be at least as many characters representing the\n\t\t\t\t\tdigits of the number as contained in the biggest number to be displayed. Shorter numbers\n\t\t\t\t\tare filled with zeroes from the left.\n\nWhen formatting numbers, a number is represented by a template containing the sequence\n\t\t\t\t\tof formatting characters. Each formatting character in the template represents one digit\n\t\t\t\t\tof the number. Usually it is not necessary to specify the number of digits in the\n\t\t\t\t\ttemplate exactly (a number can have a different number of digits and will still be\n\t\t\t\t\tparsed correctly). The only exception is when there are two neighboring numbers to\n\t\t\t\t\tbe parsed. In order to determine which character belongs to which number, the parsing\n\t\t\t\t\ttemplates are applied in their exact form (and therefore the number of characters in\n\t\t\t\t\tthe template matters).\n\nProcessing date from text:If at least 4 formatting characters are specified, then the\n\t\t\t\t\tfull text form is used, otherwise the short form is used (or at least shortened -\n\t\t\t\t\tJanuary/Jan, etc). For reading, the number of formatting characters does not matter\n\t\t\t\t\tand all forms are accepted.\n\nExample of input: \"yyyy-MM-dd\" - accepts input \"1970-01-01\"Example of output: \"d.M.yyyy\" - output is 1.1.1970\n\nIt is possible to define an input/output format for types with the form\n\t\t\t\t\t\"true-text | false-text\", where true-text (or false-text respectively) is the\n\t\t\t\t\tstring representingtrue(orfalse) values. By default these\n\t\t\t\t\tvalues are set to \"true\" and \"false.\""
}