{
  "title": "Step MDM Identify",
  "headers": [
    "Contents:",
    "Step MDM Identify",
    "Properties",
    "Endpoints",
    "Detailed Description",
    "Element Input Column",
    "Properties",
    "Element Output Column",
    "Properties"
  ],
  "content": "This step should be used in online service to create compound services with complex logic not achievable using just native MDM services.\n\nFor every input record, step asks MDM to execute identification process. This process takes input data, cleanses them and matches them by matching rules with data in MDM.\n                If input record is matched, its would-be master_id and other matching information is added to output. Moreover values of its would-be master record are added to output.\n\nStep reads data directly via internal Java interface (not via HTTP call) and works only if NmeServerComponent is in the same JVM.\n\nIf there are multiple steps in one plan, they share the same transaction when accessing data, providing consistent data.\n                For example in a plan with MDM Read and MDM Identify steps, record is first processed by MDM Read, data is changed, record is processed by MDM Identify\n                - MDM Identify will see the same data as MDM Read because the change happened in another isolated transaction.\n                This applies for both MDM Read and MDM Identify step - both of them share the same transaction.\n                The level of consistency depends on used persistence and underlying database.\n                For read-only transactions, VldbPersistence does not track read operations, potentially allowing obsolete record versions to be retained by LTC, even if needed by the transaction.\n                For read-write transactions, VldbPersistence keeps old record versions and ensures repeatable read using MVCC.\n                To ensure consistency, you need to change the underlying database isolation level from READ COMMITTED (default for most databases) to REPEATABLE READ."
}