{
  "title": "Step Pattern Parser",
  "headers": [
    "Contents:",
    "Step Pattern Parser",
    "Properties",
    "Endpoints",
    "Scoring",
    "Detailed Description",
    "Element Configurable Tokenizer Config",
    "Properties",
    "Element Token Type",
    "Properties",
    "Element Parser Config",
    "Properties",
    "Element Component",
    "Properties",
    "Scoring",
    "Element Verifier",
    "Properties",
    "Element Pattern Group",
    "Properties",
    "Element Pattern",
    "Properties"
  ],
  "content": "This step performs parsing of the input string data based on defined parsing rules.\n\t\t\tIt tries to find a pattern that matches the input text. If such pattern is found, its \n\t\t\tdefinition is used to recognize individual parts (components) and store their values\n\t\t\tin the output.\n\nThe input text is first split into tokens using the defined tokenizer. Tokens are then matched \n\t\t\tagainst defined patterns and their components. For parsing purposes, pattern\n\t\t\tdefinitions and the input string are both pre-compiled using an identical tokenizer and \n\t\t\ttherefore correct (identical) construction of all components is guaranteed.\n\nPatterns consists of components. Generally there are two types of components:basic components - these are components whose purpose is to recognize input chunks\n\t\t\t\tonly syntactically (for example: a word must contain only letters, a number must contain \n\t\t\t\tonly digits, etc.). They do not care about the meaning of the matched text - they\n\t\t\t\talso do not provide access to the matched value.user specified components - these are components that consists of some other \n\t\t\t\tcomponents (typically basic ones) and the addition of other features:naming- the component can be named and therefore used in \n\t\t\t\t\tthe patterns or other custom componentsstoring of matched text- it is possible to define a column \n\t\t\t\t\tthat the matched value should be stored invalidation- it is possible to define a lookup file where \n\t\t\t\t\tmatched text should be validated againstscoring- it is possible to score if the given component\n\t\t\t\t\tdoes not match\n\nThe predefined basic components are:Component nameDescriptionLETTERA letter (no parameters available)WORDA (single) word. Available parameters:intminLength- minimum number of required characters (default value: 2)intmaxLength- maximum number of required characters (default value: integer max)stringchars- string that defines which characters the words can be composed of;\n\t\t\t\t\t\t\t\tdefault value: [:letter:] (seeConfigurableTokenizerConfig)MULTIWORDA multiple word string - a string consisting of more than one word.Available parameters:intminLength- minimum number of required characters (default value: 2)intmaxLength- maximum number of required characters (default value: integer max)stringchars- see WORDstringwordSeparatorsA string that defines characters that are considered to be acceptable word delimiters (separators).\n\t\t\t\t\t\t\t\t\tIt is not necessary to define a space as a separator; it is automatically considered as a delimiter.\n\t\t\t\t\t\t\t\t\tThe default value is an empty string.MULTIWORDaccepts various numbers of input tokens, depending \n\t\t\t\t\t\t\ton the verifier and the pattern where it is used:If a verifier is specified, thenMULTIWORDaccepts as many words \n\t\t\t\t\t\t\t\t\tas possible until:the whole read string is present in multi-word lookup, oreach read chunk is present in single-word lookupIf a verifier is not specified:then the number of words read from the input depends on the pattern whereMULTIWORDis used.MULTIWORDwill then contain \n\t\t\t\t\t\t\t\t\tas many words as possible according to the rest of the pattern.See thedetailed multiword description hereto find more information about this topic.The main purpose and advantage of theMULTIWORDcomponent over a \n\t\t\t\t\t\t\tset ofWORDcomponents is its flexibility. Contrary to a set ofWORDcomponents that matches only exactly the same number of \n\t\t\t\t\t\t\tinput tokens, theMULTIWORDcomponent allows you to read \n\t\t\t\t\t\t\tvarious numbers of input words depending on the given verifier or \n\t\t\t\t\t\t\tpattern.Known limitations:there must not be more separators in a sequence, otherwiseMULTIWORDcomponent will not accept the string (even it \n\t\t\t\t\t\t\t\t\tis specified in lookup file)only single-character separators are supportedINTERLACED_WORDWord where each character is separated by a space character.stringchars- see WORDANWORDAn alphanumeric word (no parameters available).DIGITA single digit (no parameters available).NUMBERA natural number. Available parameters:booleanacceptSeparators- specifies whether the delimiter specified inseparatorCharis acceptable between digits within a number.\n\t\t\t\t\t\t\t\t\tDefault value:falsecharseparatorChar- value which is acceptable as a delimiter\n\t\t\t\t\t\t\t\t\tof single digits within a number. Default value:' 'intminLength- minimum number of required characters (default value: 2)intmaxLength- maximum number of required characters (default value: integer max)INTEGERWhole number. Available parameters:The same as in the case ofNUMBER, with the following exceptions:acceptSeparators- default value:trueoperators are also acceptable ( '+' and '-')REAL_NUMBERReal number. Available parameters:charfloatingPoint- a character representing a decimal separator.\n\t\t\t\t\t\t\t\t\tDefault value: '.'ROMAN_NUMBERRoman number (no parameters available).REGEXPRegular expression. Available parameters:stringpattern- a string with a Javaregex.Pattern(seeclass Pattern).A component defined using a string.No parameters available.*Component accepting any text.\n\nThe main purpose and advantage of theMULTIWORDcomponent over a \n\t\t\t\t\t\t\tset ofWORDcomponents is its flexibility. Contrary to a set ofWORDcomponents that matches only exactly the same number of \n\t\t\t\t\t\t\tinput tokens, theMULTIWORDcomponent allows you to read \n\t\t\t\t\t\t\tvarious numbers of input words depending on the given verifier or \n\t\t\t\t\t\t\tpattern.\n\nKnown limitations:there must not be more separators in a sequence, otherwiseMULTIWORDcomponent will not accept the string (even it \n\t\t\t\t\t\t\t\t\tis specified in lookup file)only single-character separators are supported\n\nNOTE:The componentsNUMBERandWORDare \n\t\t\tdefined by default using at least 2 digits (for NUMBER) or 2 characters (for WORD) in order\n\t\t\tto be distinguished fromDIGITorLETTER(which are defined using one \n\t\t\tdigit or character, respectively).\n\nMULTIWORD component - detailed informationThis component reads individual tokens from the input (tokenizer's output; the tokenizer \n\t\t\tpreprocesses data for the parser). When reading, single character tokens (and those which \n\t\t\tare equal to the one defined in thewordSeparatorsparameter) are considered \n\t\t\tto be a part of a word.The result of this reading process (acquired words) are merged using the ' ' character. \n\t\t\tThis way the component reads a maximum possible number of words and then processes the \n\t\t\trest of the string against the rest of the pattern (i.e. consecutive parsing when the \n\t\t\trest of the pattern is applied). If the consecutive parsing is not\tsuccessful, the \n\t\t\tcomponent detaches the last read word and performs consecutive parsing again.\n\t\t\tFinally the input string is either not parsed or when the process is successful, the \n\t\t\tcomponent stores the result in the specified output column.For accepting processes, theMULTIWORDcomponent can be used either with the \n\t\t\tstandard single word verifier or with theMultiwordVerifierverifier, which \n\t\t\ttries to lookup the actual input in the multi-word dictionary (if defined - it is optional). \n\t\t\tIf the lookup is not successful, the step attempts to lookup individual words (i.e. \n\t\t\tsequences of characters delimited by spaces) in the single word dictionary. If any\n\t\t\tof this process succeeds, the token sequence is accepted.NOTE:theMULTIWORDcomponent is the only component that uses \n\t\t\t\tthe multiword-lookup identifier\t'Multi file name' in the relatedVerifierIf a dictionary based verification is not required for theMULTIWORDcomponent, the first component defined this way accepts a maximum number of tokens. At \n\t\t\tthe same time, the rest of the components must be considered to meet pattern's \n\t\t\trequirements. For example, two consecutiveMULTIWORDcomponents which have \n\t\t\tno verification will share an input with N tokens in the following way: the first\n\t\t\tcomponent reads N-1 tokens and the second reads one token only.Example:Input string:Anna-Maria o'Donald- the string is split by the tokenizer of the parser in the\n\t\t\tfollowing way:Anna,-,Maria,,o,',DonaldUsingwordSeparators=\"-'\"definition, theMULTIWORDcomponent merges this\n\t\t\t(the tokenizer's) output into this result:Anna-Maria,o'Donald.\n\t\t\tIf using a multi-word dictionary, the following combination is looked up:Anna-Maria o'Donald, in case of failure, the single-word dictionary is used and this\n\t\t\tcombination is looked up:Anna-Maria,o'DonaldIf case of no match, theMULTIWORDcomponent detaches the last word (o'Donald) and\n\t\t\tif a consecutive parsing succeeds, the test is performed again, this time with the same valueAnna-Mariain the multi-word dictionary and subsequently in the single-word dictionary.\n\nThis component reads individual tokens from the input (tokenizer's output; the tokenizer \n\t\t\tpreprocesses data for the parser). When reading, single character tokens (and those which \n\t\t\tare equal to the one defined in thewordSeparatorsparameter) are considered \n\t\t\tto be a part of a word.\n\nThe result of this reading process (acquired words) are merged using the ' ' character. \n\t\t\tThis way the component reads a maximum possible number of words and then processes the \n\t\t\trest of the string against the rest of the pattern (i.e. consecutive parsing when the \n\t\t\trest of the pattern is applied). If the consecutive parsing is not\tsuccessful, the \n\t\t\tcomponent detaches the last read word and performs consecutive parsing again.\n\t\t\tFinally the input string is either not parsed or when the process is successful, the \n\t\t\tcomponent stores the result in the specified output column.\n\nFor accepting processes, theMULTIWORDcomponent can be used either with the \n\t\t\tstandard single word verifier or with theMultiwordVerifierverifier, which \n\t\t\ttries to lookup the actual input in the multi-word dictionary (if defined - it is optional). \n\t\t\tIf the lookup is not successful, the step attempts to lookup individual words (i.e. \n\t\t\tsequences of characters delimited by spaces) in the single word dictionary. If any\n\t\t\tof this process succeeds, the token sequence is accepted.\n\nNOTE:theMULTIWORDcomponent is the only component that uses \n\t\t\t\tthe multiword-lookup identifier\t'Multi file name' in the relatedVerifier\n\nIf a dictionary based verification is not required for theMULTIWORDcomponent, the first component defined this way accepts a maximum number of tokens. At \n\t\t\tthe same time, the rest of the components must be considered to meet pattern's \n\t\t\trequirements. For example, two consecutiveMULTIWORDcomponents which have \n\t\t\tno verification will share an input with N tokens in the following way: the first\n\t\t\tcomponent reads N-1 tokens and the second reads one token only.\n\nThere are two ways to define a component.a named component whose definition is specified in acomponentelement.redefine a component directly within a pattern\n\nUsing a component in a pattern:The component name is enclosed by brackets: '{' and '}' within the parsing pattern \n\t\t\tdefinition. Any other string defined outside brackets is considered literally; in the \n\t\t\tparsing process, such text must be part of the parsed input string to match the parsing \n\t\t\tpattern. The component usage specification is as follows:{component_name[:name_par=value_par,name_par=value_par] [| list_of_components_defining_the_structure]}\n\nIn order to locally modify behavior of the component, you can:change values of component parametersredefine the component definition\n\nChange component parametersSetting of component behavior and properties can be performed using the component's parameters (see the table).\n\t\t\tParameters are specified in the following way: parameter_name=parameter_value. The specification requires\n\t\t\tthat the component name and parameter definition be separated by a  colon (':').The component parameter's value can be quoted using both single and double quotes (' and \"). When a\n\t\t\tquote is intended to be part of the value, it must be escaped using the same quote (i.e. producing\"\"or''). It is also possible to use no quotation (the parameter value is not escaped) up to\n\t\t\ta first \",\" (comma), \"|\" (pipe) or \"}\" (right parenthesis). In this case, escape sequences for definition\n\t\t\tof the special characters (such as \\t, \\n, \\r or \\f) cannot be defined (the only possible definition is when the value is quoted).\n\t\t\tIt is also possible to use a special definition using the @ character. When escaped by @, every character\n\t\t\twithin escaping quotes has the explicit value (a value that has no special meaning) - e.g. definition\n\t\t\tof @\"\\t\" means that \\t is interpreted as the appropriate string (\\t) and not as a tab.Pay special attention to coding patterns of the regular expression component (REGEXP), where special\n\t\t\tcharacters such as '{' or '\\' are often used in the pattern, e.g. when backslash should be used in the quoted parameter,\n\t\t\tyou have to duplicate it.Examples:{MULTIWORD:wordSeparators=\"-'&quot;&quot;\\t\"}= delimiters: dash, single quote and (one) double quote, tab{MULTIWORD:wordSeparators=@\"-'.\\t\"}= delimiters: dash, single quote, dot, backslash, character 't'{WORD:minLength=2}{REGEXP:pattern=\"[a-zA-Z\\\\\\\\]\\\\d*\\\\.\\\\d{1,2}\"}= letter or backslash followed by digits, dot and 1-2 digits{REGEXP:pattern=@\"[a-zA-Z\\\\]\\d*\\.\\d{1,2}\"}= the same pattern as above without necessary double escapingFor some parameters a special acronym can be used. An acronym definition must follow the\n\t\t\tparameter's name (before the separating colon). Currently only one acronym is available : \"!\"\n\t\t\t(the exclamation mark). When used, the presence of the specified component in the dictionary is required,\n\t\t\totherwise the component is not considered to be valid (it does not match the pattern).\n\nFor a named component definition, an attributedefinitionis used. The attribute contains\n\t\t\ta string of components representing actual components' structure definition. Redefining a component\n\t\t\tmeans changing the parsing pattern structure while other functional capabilities of the component\n\t\t\tremain unchanged (verifying against dictionaries, output column, etc.). For redefining components,\n\t\t\ta '|' character\tis used as a delimiter between the component name and its new definition. For example we\n\t\t\thave a named componentCOMPdefined by{WORD} {WORD}with output columnoutputthen we can create the following definition{COMP|{WORD} a}. Then for parsing the{WORD} awill be used\n\t\t\tinstead of{WORD} {WORD}and if trashing is switched on the output will be stored in theoutputcolumn.\n\nIf you put after the component name the question mark then the parser will try first parse the input text\n\t\t\twith component and if it fails it tries to parse the input text without the component. Therefore we call\n\t\t\tit the optional component. An example is:{REGEXP?:pattern=\".\"}. If there are more optional \n\t\t\tcomponents in the pattern then the parser tries to omit the components from the right side.\n\nTo allow for extended prioritization of parsing rules, they are divided\n\t\t\tinto parsing groups and each of them is parsed in isolation from\n\t\t\tothers. For a complete description see thePattern Groupconfiguration element.\n\nScoringfunctionality of thePattern Parserstep is\n\t\t\tperformed via two types ofscorers. The first is a main scorer applied to\n\t\t\tthe overall step. The second is applied separately to each component participating in the parsing process.\n\t\t\tEvery component scores its activity and thus it is possible to obtain detailed information about the process.\n\t\t\tComponent scorers are not required.\n\nThe set of characters can be defined using the following (for detailed description seecharacter set):enumeration, e.g.abcdefinterval, e.g.a-fora-cd-f, etc. If the character-is intended to be part of the set, it must be defined at the very end of the definition.Link to predefined constant set of characters using bracket expression ([:and:]).\n\t\t\t\t\tWhen the characters \"[:\" or \":]\" are intended to be a part of the set, they must be\n\t\t\t\t\tdefined separately from the definition (not to be considered as beginning or definition set).There are alsopredefined character classesavailable.\n\t\n\t\t\t\t\tAn example of definition:[:uppercase:].Listed constants can also be used in an \"exclude\" form such as[:lowercase:-abc:], where\n\t\t\t\t\tcharacters \"abc\" are a list of exceptions in the defined characters set.\n\t\t\t\t\tAn example of such definition:[:uppercase:-A:](all capital letters except for 'A')merging - all possibilities listed above can be combined to create a single set,\n\t\t\t\t\t\te.g. a definition of a token that begins with a letter and continues with letters, numbers\n\t\t\t\t\t\tor a dash:<type tokenCharacters=\"[:letter:][:digit:]-\" tokenStartCharacters=\"[:letter:]\">"
}