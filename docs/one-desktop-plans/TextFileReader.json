{
  "title": "Step Text File Reader",
  "headers": [
    "Contents:",
    "Step Text File Reader",
    "Properties",
    "Endpoints",
    "Detailed Description",
    "Example",
    "Enum Compression Type",
    "Values",
    "Element Error Handling Strategy",
    "Properties",
    "Element Error Instruction",
    "Properties",
    "Detailed Description",
    "Enum Error Fix Type",
    "Values",
    "Enum Error Type",
    "Values",
    "Element Shadow Column Def",
    "Properties",
    "Enum Column Type",
    "Values",
    "Element Text Reader Column",
    "Properties",
    "Element Text Reader Data Format Parameters",
    "Properties",
    "Detailed Description"
  ],
  "content": "The data source is a standard text file (or an archive containing such a file, where records are saved as rows and\n\t\t\tcolumns are separated by delimiter characters.\n\nThe step is capable of processing compressed files using either ZIP or GZIP format.\n\t\t\t\tWhen processing ZIP file, it searches for a file named after the archive itself (without the extension)\n\t\t\t\tor uses the only file present in the archive (regardless of its name).\n\nMoreover, the step is capable of reading multiple files having the same format\n\t\t\t\twith names defined as template where both, ordinary text and column variables\n\t\t\t\tcan appear.\n\t\t\t\tColumn variable has the following format: {<column_name>}.\n\t\t\t\tColumn variables that reference columns that are unknown are\n\t\t\t\ttreated as ordinary text.\n\t\t\t\tWhen reading, the step scans file system for files matching the file name template.\n\t\t\t\tFor each matched file and all its records it assigns corresponding\n\t\t\t\tcolumns the values extracted from the file's name.\n\nThis step supports encodings supported by Java, including Unicode formats (supported\n\t\t     Unicode formats are: UTF-8, UTF-16, UTF-16BE, UTF-16LE). The input is processed byUnicodeAwareReader, which allows correct processing of files with Byte Order Mark (BOM)\n\t\t     signatures used in some Unicode formats (for their identification) and\n\t\t     therefore allows correct processing of non-Unicode formats.The file encoding detection procedure is as follows:The UnicodeAwareReadertries to read the BOM from the file and compares the received\n      \t\tresults with the encoding entered within the step configuration (theEncodingparameter). If both types match and this file type is supported by the version of Java being used,\n      \t\tthe BOM is skipped and the file is read in the original format. If the file type in the\n      \t\tconfiguration is not the same as the type set by the BOM, a format discrepancy warning is\n      \t\tdisplayed and the file processing proceeds in the format set within the configuration (including\n      \t\tBOM bytes, which are considered to be common content).If the BOM cannot be detected from the file, it is assumed that the encoding used within\n      \t\tthe step configuration is valid (i.e., either Unicode format without BOM signature\n      \t\tor non-unicode format) and the file is read in the format set within the configuration.If the configuration has UTF-16 as the general encoding type and it is\n      \t\tpossible to get the exact sub-format from the BOM (i.e., UTF-16BE or UTF-16LE), the type from the\n      \t\tBOM is used. But if there is no BOM signature contained within the file, processing ends\n      \t\twith an error because it is not clear which format should be used.The following table shows possible file encodings and configuration values for Unicode files:Real File FormatConfiguration ValueBOM SignatureResult (Used) EncodingUTF-8UTF-8yesUTF-8UTF-8UTF-8noUTF-8UTF-8non/bad-unicodeyesnon/bad-unicode + warningUTF-8non/bad-unicodenonon/bad-unicodeUTF-16BE/LEUTF-16BE/LEyesUTF-16BE/LEUTF-16BE/LEUTF-16BE/LEnoUTF-16BE/LEUTF-16BE/LEUTF-16yesUTF-16BE/LEUTF-16BE/LEUTF-16noerrorUTF-16BE/LEnon/bad-unicodeyesnon/bad-unicode + warningUTF-16BE/LEnon/bad-unicodenonon/bad-unicodenon-unicodeUTF-8-UTF-8non-unicodeUTF-16-errornon-unicodeUTF-16BE/LE-UTF-16BE/LEnon-unicodeother-format-other-format\n\nThe file encoding detection procedure is as follows:The UnicodeAwareReadertries to read the BOM from the file and compares the received\n      \t\tresults with the encoding entered within the step configuration (theEncodingparameter). If both types match and this file type is supported by the version of Java being used,\n      \t\tthe BOM is skipped and the file is read in the original format. If the file type in the\n      \t\tconfiguration is not the same as the type set by the BOM, a format discrepancy warning is\n      \t\tdisplayed and the file processing proceeds in the format set within the configuration (including\n      \t\tBOM bytes, which are considered to be common content).If the BOM cannot be detected from the file, it is assumed that the encoding used within\n      \t\tthe step configuration is valid (i.e., either Unicode format without BOM signature\n      \t\tor non-unicode format) and the file is read in the format set within the configuration.If the configuration has UTF-16 as the general encoding type and it is\n      \t\tpossible to get the exact sub-format from the BOM (i.e., UTF-16BE or UTF-16LE), the type from the\n      \t\tBOM is used. But if there is no BOM signature contained within the file, processing ends\n      \t\twith an error because it is not clear which format should be used.\n\nThe following table shows possible file encodings and configuration values for Unicode files:\n\nUTF-32(LE/BE) formats are not supported. Non-Unicode formats are untouched by this\n     \t\t\treader and they are read using formats entered within the configuration.\n\nInput data records are processed using parameters specified in the elementData Format Parameters. Additional details are available inDataFormatParameters.\n\t\t\t\tIf a column does not define (override) its own format settings, a global formatting setting\n\t\t\t\tis used by default.\n\nThis step may produce the following errors:SHORT_LINE,INVALID_DATE,UNPARSABLE_FIELD,LONG_LINE,EXTRA_DATA,PROCESSING_ERROR.When aSHORT_LINEerror occurs the input value is considered to benullfor further parsing.\n\nError management is configured by the elementError Handling Strategy.\n\t\t\t\tError handling strategy allows disabling of processing of the incorrect entries,\n\t\t\t\twhich can be send to the \"rejected\" output endpoint. For a more detailed description of\n\t\t\t\terror handling seeError Handling Strategy.\n\nWhen creating a reject file, the following rules are observed:The initial name for the reject file isrejected.txt.The encoding defined for the input data file is used as the encoding of the rejected file.The line separator defined for the input data file is used as the line separator.Every input row is written to the reject file at most once. So,\n\t\t\t\t\teven if there are more error fields in the same row whose instructions\n\t\t\t\t\trequire writing to the reject file the row is written there only once.Empty reject files are not created. A reject file is created when\n\t\t\t\t\tan instruction requires writing to this file.\n\nDefines compression type to be used when reading or writing text files\n\t\t\t\t(such asTextFileReader,TextFileWriterorFixedWidthFileReader).\n\nThe error handling strategy defines the behavior of steps in case of error.\n\t\t\t\tThis strategy consists of a set ofErrorInstructionsthat instruct the step how to behave in case of each type of error.\n\t\t\t\tSeeErrorInstructionsfor more details.\n\nThe following table shows all possible error statuses:StateDescriptionSHORT_LINEInput line is too short or contains fewer fields than expected.EXTRA_DATAInput line is longer or contains more fields than expected.LONG_LINEInput line exceeds the maximum allowed length specified in the configuration.UNPARSABLE_FIELDInput field contains data which cannot be converted to the specified data type.INVALID_DATEInput field contains data which cannot be parsed as date or datetime.PROCESSING_ERROROther error during parsing data.\n\nThe following table shows the meaning of instructions that may be created as combinations\n\t\t\tof error types and error actions to be taken:Error StateActionDescriptionanySKIP_LINEwill cause skipping of the line that causes the\n\t\t\t\t\t\t\t\t\t\t\t   error from processinganySTOPcauses data loading interruptSHORT_LINENULL_VALUEnullentry is written to\n\t\t\t\t\t\t\t\t\t\t\t   \t\tthe outputREAD_POSSIBLEvalues possible to parse will be written to\n\t\t\t\t\t\t\t\t\t\t       the output, the rest will havenullvaluesUNPARSABLE_FIELDNULL_VALUEnullwill be written to the\n\t\t\t\t\t\t\t\t\t\t       output fieldREAD_POSSIBLEnullwill be written to the\n\t\t\t\t\t\t\t\t\t\t       output fieldINVALID_DATENULL_VALUEnullwill be written to the\n\t\t\t\t\t\t\t\t\t\t       output fieldREAD_POSSIBLEthe result of processing\n\t\t\t\t\t\t\t\t\t\t       withlenient=onis written to the resultPROCESSING_ERRORNULL_VALUEnullvalues are written to the\n\t\t\t\t\t\t\t\t\t\t       \t\toutput fieldREAD_POSSIBLEvalues that have been parsed before the error\n\t\t\t\t\t\t\t\t\t\t       occurred are written to the output, for the rest\n\t\t\t\t\t\t\t\t\t\t       of valuesnullsare written to the output\n\nAny entries that cause an error can be written to a log file and/or excluded from further\n\t\t\t\tprocessing. By default theerrorHandlingStrategyis set up\n\t\t\t\tas follows:ErrorLogRejectFix TypePROCESSING_ERRORXSTOPINVALID_DATEXREAD_POSSIBLEUNPARSABLE_FIELDXNULL_VALUESHORT_LINEXXREAD_POSSIBLEEXTRA_DATAXREAD_POSSIBLELONG_LINEXXSTOP\n\nThis class defines actions to be taken as a response to the ErrorType reported.\n\t\t\t\tEach error must have some action associated with it in order to define a validerror handling strategy.\n\nData format parameters are parameters used for data formatting when an\n\t\t\t\tinternal/external data format conversion is required. This task typically\n\t\t\t\toccurs when [branding:product.name.abbreviation] needs to load data from an external file or needs to store\n\t\t\t\tdata to an external file. Data format parameters then describe how\n\t\t\t\tto convert data to the desired form based on the reading and writing file data formats.\n\nProcessing steps supporting DataFormatParameters (DFP) can define DFP at the top level\n\t\t\t\tof a step as well as on the \"local\" level of each column. If there are no\n\t\t\t\tDFP defined on the local level, the global DFP are used. If global data format parameters\n\t\t\t\tare not defined, the default values are assumed. When a column defines its own DFP,\n\t\t\t\tthis DFP must contain all attributes needed for successful parsing (those attributes\n\t\t\t\tmust be assigned valid values). The only exception to this rule isThousands Separator.\n\t\t\t\tIn contrast with the rest of DFP attributes that must always have some value,Thousands Separatormay remain empty (meaning that no thousands\n\t\t\t\tseparator is used).\n\nIf specified, the provided string will be used in place of any whitespace character seen in the input\n\t\t\t\tvalue of the corresponding column(s). This technique can be useful for avoiding automated whitespace\n\t\t\t\ttrimming in file reader steps or for normalizing whitespace characters in the reading phase.\n\nDefines the locale for parsing non-numerical data (for example short forms of months in dates -\n\t\t\t\te.g., Sep 18, 1999). The value is the same as the value of the corresponding locale in Java\n\t\t\t\t(for detail seeJava locales).\n\nDefines the format that should be used for processing 'datetime' data. The template is\n\t\t\t\tbased onSimpleDateFormat, which uses the Java convention.\n\nDefines the format that should be used for processing 'date' data. The template is based onSimpleDateFormat, which uses the Java convention.\n\nDefines what character is used as the decimal separator.Escaped string property.\n\nString value that represents a logical 'false' value in the given data. The comparison is\n\t\t\t\tnot case sensitive.\n\nDefines the string that represents the thousands separator (used in numbers). A non-escaped\n\t\t\t\tcharacter is expected. Numbers to be read do not need to contain this separator, but\n\t\t\t\twhen the separator is present it is processed (stripped) accordingly.Escaped string property.\n\nString value representing a logical 'true' value in the given data. The comparison is not case\n\t\t\t\tsensitive.\n\nFor datetime and date types there is an existing output format defined. This format definition is given by a\n\t\t\t\t\ttextual string that follows the convention used in the JavaSimpleDateFormat.\n\nThe meanings of the most used characters in the formatting string are as follows:y ... year, M ... month in year, d ... day in month. By changing the number of those\n\t\t\t\t\tformatting characters it is possible to change the meaning of the characters.NOTE: the formatting string is case sensitive, so the same character has different\n\t\t\t\t\tmeaning when used as upper or lower case.\n\nReading a year:If the formatting string contains more than two characters, then the input number\n\t\t\t\t\tis interpreted as is, without accounting for the century.If the formatting string contains a shortened version (\"y\" or \"yy\"), then the input\n\t\t\t\t\tnumber is parsed against the current data where the resulting date is in the range -80, +20 years\n\t\t\t\t\tfrom the current date. It is important to note that the number of digits in the year must\n\t\t\t\t\tstrictly comply with the number of its formatting characters. Otherwise, the year is\n\t\t\t\t\tread as specified in the input (for format '..yy' and input '...765' the\n\t\t\t\t\tresulting year is 765.\n\nYear output format:If the formatting string includes the \"yy\" form, then the year is transformed into 2 characters,\n\t\t\t\t\totherwise it is formatted as the original number (including completion).\n\nMonth output format:If the number of formatting characters for month is >=3,\n\t\t\t\t\tthen the output is the full month's name (for example, January), otherwise the output\n\t\t\t\t\tis represented by the number (so, for January, it is 1).\n\nNumerical output format:Numerical padding functionality dictates there must be at least as many characters representing the\n\t\t\t\t\tdigits of the number as contained in the biggest number to be displayed. Shorter numbers\n\t\t\t\t\tare filled with zeroes from the left.\n\nWhen formatting numbers, a number is represented by a template containing the sequence\n\t\t\t\t\tof formatting characters. Each formatting character in the template represents one digit\n\t\t\t\t\tof the number. Usually it is not necessary to specify the number of digits in the\n\t\t\t\t\ttemplate exactly (a number can have a different number of digits and will still be\n\t\t\t\t\tparsed correctly). The only exception is when there are two neighboring numbers to\n\t\t\t\t\tbe parsed. In order to determine which character belongs to which number, the parsing\n\t\t\t\t\ttemplates are applied in their exact form (and therefore the number of characters in\n\t\t\t\t\tthe template matters).\n\nProcessing date from text:If at least 4 formatting characters are specified, then the\n\t\t\t\t\tfull text form is used, otherwise the short form is used (or at least shortened -\n\t\t\t\t\tJanuary/Jan, etc). For reading, the number of formatting characters does not matter\n\t\t\t\t\tand all forms are accepted.\n\nExample of input: \"yyyy-MM-dd\" - accepts input \"1970-01-01\"Example of output: \"d.M.yyyy\" - output is 1.1.1970\n\nIt is possible to define an input/output format for types with the form\n\t\t\t\t\t\"true-text | false-text\", where true-text (or false-text respectively) is the\n\t\t\t\t\tstring representingtrue(orfalse) values. By default these\n\t\t\t\t\tvalues are set to \"true\" and \"false.\""
}