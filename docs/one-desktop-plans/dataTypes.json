{
  "title": "Data types",
  "headers": [
    "Data types",
    "Contents:",
    "Supported data types in records",
    "Formatting of data types for I/O operations",
    "Errors while parsing input to the data type",
    "Data types usable in step properties",
    "Data types",
    "JDBC data type conversions"
  ],
  "content": "Formatting rules for parsing input/output data into [branding:product.name.abbreviation] data types are \n\t\t\tdefined by theDataFormatParametersof the respective input/output processing steps.See that section for more details.\n\nIn all cases, ifnullexists in the input field,nullis written to the related output field without generating an error.\n\nThe following errors may occur for each data type:STRINGDoes not generate any errors.BOOLEANWhen there's an unparsable non-null value in the input, anUNPARSABLE_FIELDerror is generated.INTEGERWhen there's an unparsable non-null value in the input, anUNPARSABLE_FIELDerror is generated.FLOATWhen there's an unparsable non-null value in the input, anUNPARSABLE_FIELDerror is generated.LONGWhen there's an unparsable non-null value in the input, anUNPARSABLE_FIELDerror is generated.DAYIf the data parsing ends up with error, anINVALID_DATEerror\n\t\t\t\t\t\tis generated. If theREAD_POSSIBLEoption is set, the step parses the data again, this \n\t\t\t\t\t\ttime with added leniency towards nonsensical numeric parts of the date. For example, the \n\t\t\t\t\t\tstring '32-13-2000' represents a valid date value that is parsed\n\t\t\t\t\t\tas 1.2.2001. If even lenient parsing fails, anUNPARSABLE_FIELDerror is generated.DATETIMEProcessing is the same as for theDAYdata type.\n\nEach step that handles I/O parsing of [branding:product.name.abbreviation] data types is required to \n\t\t\t\timplement a specificerror handling strategythat manages error handling.\n\nThe following data types can be used in step properties definition:\n\nWhen reading data from a database type to an internal data type or when writing an internal data type\n\t\t\tto a DB data type, a set of predefined conversions is used. The table below shows how data\n\t\t\tare converted between a DB type and an internal data type.Internal data typeSQL data typeJDBC get methodJDBC write methodbooleanBITgetBooleansetBooleanintegerINTEGERgetIntsetIntlongBIGINTgetBigDecimalsetBigDecimaldateTIMESTAMPgetTimestampsetTimestampdayDATEgetDatesetDatefloatDECIMALgetBigDecimalsetBigDecimalstringVARCHARgetStringsetStringThis means that to read data from a database or write data to a database the \n\t\t\tJDBC get/set method is used. For example to read/write adateinternal data type\n\t\t\tfrom/to a database, the JDBC functionsgetTimestamp()/setTimestamp()are used. These conversions are used by all JDBC related steps (such asJdbc Reader,Jdbc Writer,SQL Execute,SQL Select...).JDBC internal conversionsThe JDBC specifications define JDBC's capability for inner\n\t\t\ttype conversions (the difference between which JDBC method you use to read/write data and \n\t\t\tthe real database column's data type). These specifications are availablehere.\n\t\t\tThe conversion abilities of certain drivers depend on the JDBC specification version they\n\t\t\timplement. Base conversions are defined in API 1.0 and extended in 3.0. Currently, most of\n\t\t\tthe drivers support JDBC 3.0.However, some drivers may not implement these conversions fully or a database may use its own \n\t\t\textra data types, so real conversion abilities are JDBC driver dependent. The above mentioned JDBC \n\t\t\tmethods used to read/write data from/to a database were\tchosen taking into consideration maximum \n\t\t\tcompatibility with major databases and their JDBC connectors."
}