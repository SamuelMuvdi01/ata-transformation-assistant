<?xml version='1.0' encoding='UTF-8'?>
<elements>
  <class name="com.ataccama.dqc.tasks.common.group.AbstractGroupingStrategy"/>
  <class name="com.ataccama.dqc.tasks.clean.config.Action">
    <description>
			An action is comprised of the occurrence and the actual action definitions, including flags and scorers.
			The occurrence results are defined by the <code>F Is In</code> and <code>L Is In</code> attributes - these determine in which
			dictionary the input string can be found. Each of these attributes can take the following values: &quot;&quot;, &quot;-&quot;, &quot;fl&quot;, &quot;f&quot; or &quot;l&quot;.

			The presence of the &quot;f&quot; or &quot;l&quot; character indicates that a given name is present in the first names dictionary
			or in the last names dictionary, respectively. A &quot;fl&quot; value indicates that a given input name was found in both
			first and last names dictionaries, an empty string &quot;&quot; indicates that the given input name was not found in any dictionary
			and the string &quot;-&quot; indicates NULL input data.<br/>
			Action is defined by the <code>Swap</code> attribute.
		</description>
    <properties>
			<property name="FIsIn" type="string" required="false">
				Indication of occurrence of data from the &quot;firstName&quot; input.
			</property>
			<property name="LIsIn" type="string" required="false">
				Indication of occurrence of data from the &quot;lastName&quot; input.
			</property>
			<property name="scoringEntry" type="string" required="false">
				Defines a flag string that is set when an action is performed. If no value is defined, no flag is sent to
				output, except for the following situation:
				if action is set to &quot;true&quot;, the flag &quot;SNS_SWAP&quot; is sent to output no matter what the <code>Scoring Entry</code>
				setting is (the flag string &quot;SNS_SWAP&quot; is combined with the value set in this attribute).
			</property>
			<property name="swap" type="boolean" required="true">
				Defines what actions are performed on the data - whether they (in case of a defined situation) should be
				swapped or retained in the original order.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.iway.adapter.execute.AdapterExecute">
    <introduction>
			Executes the adapter&#39;s service with parameters from the data flow.
		</introduction>
    <description>
			
		</description>
    <properties>
			<property name="serviceColumns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="false">
				This element is used to define new columns of specific types based on adapter&#39;s service output format.
				The columns are created automatically if the particular adapter is connected.
			</property>
			<property name="mapping" type="com.ataccama.dqc.tasks.iway.adapter.step.AdapterStep$ColumnMapping[]" required="false">
			</property>
			<property name="adapterName" type="string" required="true">
				Name of the adapter target.
			</property>
			<property name="serviceName" type="string" required="true">
				Name of the adapter&#39;s service.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.iway.adapter.read.AdapterReader">
    <introduction>
			Reads data from an adapter&#39;s service output.
		</introduction>
    <description>
		</description>
    <properties>
			<property name="adapterName" type="string" required="true">
				Name of the adapter target.
			</property>
			<property name="serviceName" type="string" required="true">
				Name of the adapter&#39;s service.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="false">
				This element is used to define new columns of specific types based on adapter&#39;s service output format.
				The columns are created automatically if the particular adapter is connected.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				These columns, together with the columns property, define the record format of the output endpoint. The shadow
				columns are not visible outside of the Plan file where the input step is used.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.iway.adapter.select.AdapterSelect">
    <introduction>
			Reads additional data from the adapter&#39;s service output and writes it to the output data flow.
		</introduction>
    <description>
		This step reads data from an adapter&#39;s service (optionally parameterized by some data from the input data flow).
		For every entry of the result set it creates a copy of the processed input row with data from the result set row
		added according to the given mappings. If no row is returned from the service, the appropriate record is removed from the
		data flow.
		</description>
    <properties>
			<property name="serviceColumns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="false">
				This element is used to define new columns of specific types based on adapter&#39;s service output format.
				The columns are created automatically if the particular adapter is connected.
			</property>
			<property name="mapping" type="com.ataccama.dqc.tasks.iway.adapter.step.AdapterStep$ColumnMapping[]" required="false">
				Maps input data flow columns to adapter&#39;s service input columns (service parameters).   
			</property>
			<property name="adapterName" type="string" required="true">
				Name of the adapter target.
			</property>
			<property name="serviceName" type="string" required="true">
				Name of the adapter&#39;s service.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.iway.adapter.write.AdapterWriter">
    <introduction>
			Writes data to an adapter&#39;s service input.
		</introduction>
    <description>
		</description>
    <properties>
			<property name="columnMappings" type="com.ataccama.dqc.tasks.iway.adapter.write.AdapterWriter$ColumnMapping[]" required="false">
				Maps input data flow columns to adapter&#39;s service input columns.   
			</property>
			<property name="adapterName" type="string" required="true">
				Name of the adapter target.
			</property>
			<property name="serviceName" type="string" required="true">
				Name of the adapter&#39;s service.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				Specifies whether to write out all columns as defined in the input data flow format. This attribute is exclusive
				to column definitions. If this value is set to true, then there must be no columns defined
				in the columns element, otherwise an error is reported.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.AddedColumn">
    <properties>
			<property name="expression" type="string" required="false">
			Expression used to evaluate and/or initialize the value of a given column.
			The data <code>type</code> of the expression output value must match the data <code>Type</code> of the
			column.
			</property>
			<property name="name" type="string" required="true">
			Name of a given column. Must be unique from input columns, unless
			specified in the set <code>Removed Columns</code>.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
			Data type for a given column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addressdoctor.AddressDoctorAlgorithm">
    <introduction>
			This step encapsulates the <a href="http://www.addressdoctor.com/" target="_blank">Address Doctor©</a>
			software library under <code>Correction Only (BATCH)</code> processing mode. Address Doctor© is third-party verification software
			that analyzes, corrects and standardizes addresses.
		</introduction>
    <description>
			<p align="justify">The Correction Only (BATCH) processing mode is designed for batch processing of data 
		without output selection possible. This step, which simulates this mode, 
		will process the input and will try to autocorrect it (if needed), providing a one result per line of input. 
			</p>
			<p align="justify">If you want the step to create a detailed log of actions performed during the plan run, click on
			the dropdown triangle next to the <strong>Run</strong> button and select <strong>Run Configurations</strong>. In the 
			<em>Run Configurations</em> dialogue go to the <strong>Runtimes</strong> tab and in the 
			<strong>VM Arguments</strong> field write <code>-DaddressDoctor.debugLog=debug.xml</code>. This specification will
			save <code>debug.xml</code> into the folder with the plan. Alternatively, you can specify an arbitrary
			full path.
			</p>
		</description>
    <properties>
			<property name="etalonFolder" type="string" required="true">
				The folder containing configuration file(s) SetConfig.xml and optionally Parameters.xml.
			</property>
			<property name="parametersFile" type="string" required="false">
				The path to specific parameters configuration file.
			</property>
			<property name="inputElements" type="com.ataccama.dqc.tasks.addressdoctor.AddressInputElement[]" required="false">
				List of input address elements source.
			</property>
			<property name="outputElements" type="com.ataccama.dqc.tasks.addressdoctor.AddressOutputElement[]" required="false">
				List of output address elements mapping.
			</property>
			<property name="resultParameters" type="com.ataccama.dqc.tasks.addressdoctor.AddressResultParameter[]" required="false">
				List of parsing result output mapping.
			</property>
			<property name="processStatus" type="string" required="false">
				Name of column to store parsing process status.
			</property>
			<property name="elementScorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			    Element which stores scoring settings for address elements.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
    <scoring>
			<scoringKey name="POSTAL_CODE_NULL">Set when postal code is empty (input status = 0)</scoringKey>
			<scoringKey name="POSTAL_CODE_INVALID">Set when postal code is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="POSTAL_CODE_CORRECTED">Set when postal code is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="LOCALITY_NULL">Set when locality is empty (input status = 0)</scoringKey>
			<scoringKey name="LOCALITY_INVALID">Set when locality is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="LOCALITY_CORRECTED">Set when locality is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="PROVINCE_NULL">Set when province is empty (input status = 0)</scoringKey>
			<scoringKey name="PROVINCE_INVALID">Set when province is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="PROVINCE_CORRECTED">Set when province is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="STREET_NULL">Set when street is empty (input status = 0)</scoringKey>
			<scoringKey name="STREET_INVALID">Set when street is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="STREET_CORRECTED">Set when street is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="NUMBER_NULL">Set when number is empty (input status = 0)</scoringKey>
			<scoringKey name="NUMBER_INVALID">Set when number is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="NUMBER_CORRECTED">Set when number is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="DELIVERY_SERVICE_NULL">Set when delivery service is empty (input status = 0)</scoringKey>
			<scoringKey name="DELIVERY_SERVICE_INVALID">Set when delivery service is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="DELIVERY_SERVICE_CORRECTED">Set when delivery service is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="BUILDING_NULL">Set when building is empty (input status = 0)</scoringKey>
			<scoringKey name="BUILDING_INVALID">Set when building is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="BUILDING_CORRECTED">Set when building is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="SUB_BUILDING_NULL">Set when subbuilding is empty (input status = 0)</scoringKey>
			<scoringKey name="SUB_BUILDING_INVALID">Set when subbuilding is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="SUB_BUILDING_CORRECTED">Set when subbuilding is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="COUNTRY_NULL">Set when country is empty (input status = 0)</scoringKey>
			<scoringKey name="COUNTRY_INVALID">Set when country is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="COUNTRY_CORRECTED">Set when country is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>

			<scoringKey name="ADDR_INVALID">Set when AD process status is V1, C1, C2, I1, I2, I3 or I4</scoringKey>
			<scoringKey name="ADDR_CORRECTED">Set when AD process status is V3, C3 or C4</scoringKey>
			<scoringKey name="ADDR_VERIFIED">Set when AD process status is V2 or V4</scoringKey>
			<scoringKey name="ADDR_NO_COUNTRY_FOUND">Set when AD process status is N1 or appropriate country etalon is not present</scoringKey>
			<scoringKey name="ADDR_NO_REFERENCE_DATA">Set when AD process status is N2</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.addressdoctor.AddressElementName">
    <description>
            List of possible address elements that can be queried from result of address processing.
            For more information, see documentation for Address Doctor©.
	    </description>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.AddressIdentifier">
    <introduction>Parses and identifies addresses.</introduction>
    <description>
			This step performs address identification based on reference data and a parsing rule definition.
			Address identification means that the step returns a unique address ID corresponding to input
			values (city, street, street number, etc.) which are parsed and compared with reference data within the
			identification process. The step checks relationships between particular components and supplies missing relationships.
			
			<p align="justify">
			<linkTarget id="AddressIdentifier_patterns"/>
			Address patterns are defined as string describing allowed text in the input.
			The allowed text can be defined by both, ordinary strings and components.
			The component definition syntax is <code>{COMPONENT_NAME [:spec][!]}</code>.
			Available component names are:
			<ul>
				<li>
            <code>DISTRICT</code>
          </li>
				<li>
            <code>CITY</code>
          </li>
				<li>
            <code>CITY_DISTRICT</code> - small part of a city</li>
				<li>
            <code>STREET</code>
          </li>
				<li>
            <code>POST_OFFICE</code>
          </li>
				<li>
            <code>ZIP</code>
          </li>
				<li>
            <code>PSC</code> - see <code>ZIP</code>
          </li>
				<li>
            <code>CITY_PART</code> - bigger part of a city (usually consisting of city districts)</li>
				<li>
            <code>LRN</code>
          </li>
				<li>
            <code>SN</code>
          </li>
				<li>
            <code>*</code> - universal component matching any text including spaces</li>
			</ul>
			Exclamation mark (<code>!</code>) indicates that text matched by the component
			must be found in dictionary (exact or approximative match).
			<code>Spec</code> indicates additional specification for the component.
			Currently only few components use additional specification.
			For LRN and SN components the values available are:  
			<ul>
			<li>
            <code>CZ</code> for parsing numbers according to czech rules. <code>{LRN:CZ}</code>
          </li>
			<li>
            <code>SK</code> for parsing numbers according to slovak rules. <code>{SN:SK}</code>
          </li>
			</ul>
			When LRN and SN are used without additional specification, it is assumed that czech rules are requested.
			Component <code>*</code> defines a trailing characters as its additional specification. <code>{*:;}</code> matches any text till the first <code>;</code> character.
			</p>
			
			<p align="justify">The algorithm uses several scorers as opposed to ordinary steps that use only one. 
			The scorers and their associated scoring entries are summarized in the following table:</p>
			<table border="1">
				<tr>
          <td>
            <strong>Scorer</strong>
          </td>
          <td>
            <strong>Entry</strong>
          </td>
        </tr>

				<tr>
          <td>
            <code>Attribute Scorer</code>
          </td>
          <td>AI_CITY</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CD</td>
        </tr>
				<tr>
          <td/>
          <td>AI_STREET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_SN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LRN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_PC</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CITY_STREET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_STREET_SN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CITY_LRN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_PC_CITY</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CITY_CD</td>
        </tr>
				<tr>
          <td/>
          <td>AI_PC_CITY_STREET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CITY_CD_STREET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CITY_STREET_SN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_PC_CITY_CD</td>
        </tr>
				<tr>
          <td/>
          <td>AI_NOT_VERIFIED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_NO_ADDRESS</td>
        </tr>
				<tr>
          <td/>
          <td>AI_NO_ADDRESS_ID</td>
        </tr>
				<tr>
          <td/>
          <td>AI_NO_PATTERN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_ID_MISMATCH</td>
        </tr>
				<tr>
          <td/>
          <td>AI_SWAP_LRN_SN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_UNDECIDED_LRN_SN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_EVN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LRN_OR_EVN</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CD_SUFFIX</td>
        </tr>

				<tr>
          <td/>
          <td/>
        </tr>

				<tr>
          <td>
            <code>Parser Scorer</code>
          </td>
          <td>AI_STREET_REPL_PART</td>
        </tr>
				<tr>
          <td/>
          <td>AI_STREET_REPL_FULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_REPL_PART</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_REPL_FULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_PART_REPL_PART</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_PART_REPL_FULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_POST_OFFICE_REPL_PART</td>
        </tr>
				<tr>
          <td/>
          <td>AI_POST_OFFICE_REPL_FULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CITY_PART_REPL_PART</td>
        </tr>
				<tr>
          <td/>
          <td>AI_CITY_PART_REPL_FULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_DISTRICT_REPL_PART</td>
        </tr>
				<tr>
          <td/>
          <td>AI_DISTRICT_REPL_FULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_ZIP_REPL_PART</td>
        </tr>
				<tr>
          <td/>
          <td>AI_ZIP_REPL_FULL</td>
        </tr>
			
				<tr>
          <td/>
          <td/>
        </tr>
				
				<tr>
          <td>
            <code>Scorer</code>
          </td>
          <td>AI_DISTRICT_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_PART_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_STREET_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LRN_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_SN_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_ZIP_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_POST_OFFICE_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_MUNICIPALITY_PART_NULL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_STREET_MISSING</td>
        </tr>
				<tr>
          <td/>
          <td>AI_STREET_SURPLUS</td>
        </tr>
				<tr>
          <td/>
          <td>AI_DISTRICT_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_PART_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_STREET_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LRN_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_SN_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_ZIP_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_POST_OFFICE_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_MUNICIPALITY_PART_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LRN_TYPE_CHANGED</td>
        </tr>
				<tr>
          <td/>
          <td>AI_DISTRICT_SET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_SET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LOCALITY_PART_SET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_STREET_SET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_LRN_SET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_SN_SET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_ZIP_SET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_POST_OFFICE_SET</td>
        </tr>
				<tr>
          <td/>
          <td>AI_MUNICIPALITY_PART_SET</td>
        </tr>

			<!-- ambiguity scorer -->
				<tr>
          <td/>
          <td/>
          <td/>
        </tr>
				
				<tr>
          <td>
            <code>Ambiguity Scorer</code>
          </td>
          <td>AI_AMBIG_CL</td>
        </tr>
				<tr>
          <td/>
          <td>AI_AMBIG_CL_CD</td>
        </tr>
				<tr>
          <td/>
          <td>AI_AMBIG_CL_ZCD</td>
        </tr>
				<tr>
          <td/>
          <td>AI_AMBIG_CS_N</td>
        </tr>
				<tr>
          <td/>
          <td>AI_AMBIG_SN_Q</td>
        </tr>
				<tr>
          <td/>
          <td>AI_AMBIG_ZCD_L</td>
        </tr>
				<tr>
          <td/>
          <td>AI_AMBIG_ZCS_L</td>
        </tr>
				<tr>
          <td/>
          <td>AI_AMBIG_ZCS_N</td>
        </tr>
				<tr>
          <td/>
          <td>AI_AMBIG_ZC_L</td>
        </tr>
			</table>
		</description>
    <properties>
			<property name="analyzedAddressLayout" type="string" required="true">
			String that contains the formula for a address string composition from the input fields.
			The address is sequentially processed by the parsing routine which searches for all
			patterns to which the address string may match. The formula contains characters and components
			which represent the value of a column. Components are enclosed in curly brackets (&#39;{&#39; and &#39;}&#39;) and
			each contains a column name.
		</property>
		<property name="configFile" type="string" required="true">
			String that contains the name of the configuration file which contains the specification
			of component parsing by templates (element parser factory) and
			also the specification of component identification and verification
			as against the UIR-ADR (element verifier factory).
			</property>
			<property name="numApproxMatches" type="integer" required="true">
			Number specifying the maximum number of components which may be found by the approximative search.
			Minimum length of input text that can be searched approximatively is 3 for all text components
			(all components but SN and LRN).
				<!--(see <link id="aproximativni_hledani">aproximativní hledání</link>).-->
			</property>
			

			<property name="errors" type="string" required="false">
			Column that stores the bitwise sum of particular error codes (replaced by the functionality of the scorer).
			</property>
			<property name="errorExplanation" type="string" required="false">
			Column that stores a list of error descriptions (replaced by the functionality of the scorer).
			</property>
			<property name="parserRuleName" type="string" required="false">
			Column that stores the name of the applied rule (rules are defined in the parser factory element).
			</property>
			
			<property name="hasStreets" type="string" required="false">
			Column (type BOOLEAN) that stores information about the existence of the street(s) in the recognized address.
			If the address is not detected, then the value is <code>null</code>. If a
			decision about street existence cannot be made, then the value is also <code>null</code>.
			</property>
			<property name="trashed" type="string" required="false">
			Column that stores all parts of the input that have been detected but are not part of the address.
			</property>
			
			<property name="outputComponents" type="com.ataccama.dqc.tasks.addresses.ComponentOutputInfo" required="true">
			 	Specifies columns where to store particular component values of the address.
			 	By default this property is set so that no component is stored in any column.
			</property>
			<property name="ambiguityScorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			    Scores cases when address id cannot be determined due to ambiguity.
			</property>
            <property name="parserScorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
                Scores cases when partial and/or full replacements have been applied during input parsing.
            </property>
            <property name="attributeScorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
                Scores relations of address attributes (components).
            </property>
            <property name="cleanAccidentialCzechLetters" type="boolean" required="false">
                Specifies whether the algorithm should fix accidental errors caused by replacing czech letters with digits (ř -&gt; 5).
                Default value: false.
            </property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
    <scoring>
			<scoringKey name="AI_CITY">
			A scoring flag indicating that the city was not found.
			</scoringKey>
			<scoringKey name="AI_CD">
			A scoring flag indicating that the city district was not found.
			</scoringKey>
			<scoringKey name="AI_STREET">
			A scoring flag indicating that the street was not found.
			</scoringKey>
			<scoringKey name="AI_SN">
			A scoring flag indicating that the street number was not found.
			</scoringKey>
			<scoringKey name="AI_LRN">
			A scoring flag indicating that the land registry number was not found.
			</scoringKey>
			<scoringKey name="AI_PC">
			A scoring flag indicating that the ZIP code was not found.
			</scoringKey>
			<scoringKey name="AI_CITY_STREET">
			A scoring flag indicating that the combination of input city and street does not exist.
			</scoringKey>
			<scoringKey name="AI_STREET_SN">
			A scoring flag indicating that the combination of input street and street number does not exist.
			</scoringKey>
			<scoringKey name="AI_CITY_LRN">
			A scoring flag indicating that the combination of input city and land registry number does not exist.
			</scoringKey>
			<scoringKey name="AI_PC_CITY">
			A scoring flag indicating that the combination of input ZIP and city does not exist.
			</scoringKey>
			<scoringKey name="AI_CITY_CD">
			A scoring flag indicating that the combination of input city and city district does not exist.
			</scoringKey>
			<scoringKey name="AI_PC_CITY_STREET">
			A scoring flag indicating that the combination of input ZIP, city and street does not exist.
			</scoringKey>
			<scoringKey name="AI_CITY_CD_STREET">
			A scoring flag indicating that the combination of input city, city district and street does not exist.
			</scoringKey>
			<scoringKey name="AI_CITY_STREET_SN">
			A scoring flag indicating that the combination of input city, street and street number does not exist.
			</scoringKey>
			<scoringKey name="AI_PC_CITY_CD">
			A scoring flag indicating that the combination of input ZIP, city district and city district does not exist.
			</scoringKey>
			<scoringKey name="AI_NOT_VERIFIED">
			A scoring flag indicating that the city cannot be verified (city code cannot be determined).
			</scoringKey>
			<scoringKey name="AI_NO_ADDRESS">
			A scoring flag indicating that none of the address components can be recognized - the parser cannot find any matching template.
			</scoringKey>
			<scoringKey name="AI_NO_ADDRESS_ID">
				A scoring flag indicating that the address ID cannot be identified (i.e. addressId = null).
			</scoringKey>
			<scoringKey name="AI_NO_PATTERN">
				A scoring flag indicating that none of the parsing rules match the input.
			</scoringKey>
			<scoringKey name="AI_ID_MISMATCH">
				A scoring flag indicating that the address point is identified, but one of the components does not
				correspond to the address, usually caused by inconsistency between the street number and the land registry number.
			</scoringKey>
			<scoringKey name="AI_SWAP_LRN_SN">
		    A scoring flag indicating that the land registry number and street number were switched during the identification
			as opposed to the found rule. The step found out that switching of the
			land registry number and street number would cause better address identification.
			If the identification finished successfully, the components were actually switched in the input.
			In case of unsuccessful identification, the components were switched in the input with a high
			probability. In both cases, the result components are switched in comparison with the input values.
			</scoringKey>
			<scoringKey name="AI_UNDECIDED_LRN_SN">
			A scoring flag indicating that the step cannot decide which combination of land registry number and
			street number is correct.
			</scoringKey>
			<scoringKey name="AI_EVN">
			A scoring key indicating that type of the LRN is evidence number - &quot;cislo evidencni&quot;. 
			</scoringKey>
			<scoringKey name="AI_LRN_OR_EVN">
			A scoring flag indicating that the number at input identified as possible LRN might point
			to different addresses where it is either &quot;cislo popisne&quot; or &quot;cislo evidencni&quot;.
			</scoringKey>
			<scoringKey name="AI_CD_SUFFIX">
			A scoring flag indicating that the parsed suffix of locality part cannot
			be that suffix in the context of the identified address (if the id is available)
			or is not suffix of locality part stored in <code>localityPart</code> output column
			(if the value is retrieved) or is not suffix of parsed locality part. The flag is not
			set if the suffix is not parsed at all.
			</scoringKey>
			<scoringKey name="AI_STREET_REPL_PART">
			A scoring flag indicating that partial replacement of the street component value is applied.
			</scoringKey>
			<scoringKey name="AI_STREET_REPL_FULL">
			A scoring flag indicating that full replacement of the street component value is applied.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_REPL_PART">
			A scoring flag indicating that partial replacement of the locality component value is applied.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_REPL_FULL">
			A scoring flag indicating that full replacement of the locality component value is applied.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_PART_REPL_PART">
			A scoring flag indicating that partial replacement of the locality part component value is applied.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_PART_REPL_FULL">
			A scoring flag indicating that full replacement of the locality part component value is applied.
			</scoringKey>
			<scoringKey name="AI_POST_OFFICE_REPL_PART">
			A scoring flag indicating that partial replacement of the post office component value is applied.
			</scoringKey>
			<scoringKey name="AI_POST_OFFICE_REPL_FULL">
			A scoring flag indicating that full replacement of the post office component value is applied.
			</scoringKey>
			<scoringKey name="AI_CITY_PART_REPL_PART">
			A scoring flag indicating that partial replacement of the city part component value is applied.
			</scoringKey>
			<scoringKey name="AI_CITY_PART_REPL_FULL">
			A scoring flag indicating that full replacement of the city part component value is applied.
			</scoringKey>
			<scoringKey name="AI_DISTRICT_REPL_PART">
			A scoring flag indicating that partial replacement of the district component value is applied.
			</scoringKey>
			<scoringKey name="AI_DISTRICT_REPL_FULL">
			A scoring flag indicating that full replacement of the district component value is applied.
			</scoringKey>
			<scoringKey name="AI_ZIP_REPL_PART">
			A scoring flag indicating that partial replacement of the zip component value is applied.
			</scoringKey>
			<scoringKey name="AI_ZIP_REPL_FULL">
			A scoring flag indicating that full replacement of the zip component value is applied.
			</scoringKey>
			<scoringKey name="AI_DISTRICT_NULL">
			A scoring flag indicating that the input data does not contain a district component.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_NULL">
			A scoring flag indicating that the input data does not contain a locality component.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_PART_NULL">
			A scoring flag indicating that the input data does not contain a locality part component.
			</scoringKey>
			<scoringKey name="AI_STREET_NULL">
			A scoring flag indicating that the input data does not contain a street component.
			</scoringKey>
			<scoringKey name="AI_LRN_NULL">
			A scoring flag indicating that the input data does not contain a local registry number component.
			</scoringKey>
			<scoringKey name="AI_SN_NULL">
			A scoring flag indicating that the input data does not contain a street number component.
			</scoringKey>
			<scoringKey name="AI_ZIP_NULL">
			A scoring flag indicating that the input data does not a contain ZIP component.
			</scoringKey>
			<scoringKey name="AI_POST_OFFICE_NULL">
			A scoring flag indicating that the input data does not contain a post office component.
			</scoringKey>
			<scoringKey name="AI_MUNICIPALITY_PART_NULL">
			A scoring flag indicating that the input data does not contain a municipality part component.
			</scoringKey>
			<scoringKey name="AI_STREET_MISSING">
			A scoring flag indicating that the locality contains a street network (determined from the input data and lookup dictionary)
			but the street is missing in the input.
			NOTE: this case may reflect the situation in which the input data reflects updated information about the street network, but
			the dictionary in [branding:product.name.abbreviation] contain obsolete information.
			</scoringKey>
			<scoringKey name="AI_STREET_SURPLUS">
			A scoring flag indicating that the locality does not contain a street network and therefore the 
			input street information is redundant.
			NOTE: this case may reflect the situation in which the input data reflects updated information about the street network, but 
			the dictionary in [branding:product.name.abbreviation] contain obsolete information.
			</scoringKey>
			<scoringKey name="AI_DISTRICT_CHANGED">
			A scoring flag indicating that the district name was changed.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_CHANGED">
			A scoring flag indicating that the locality was changed.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_PART_CHANGED">
			A scoring flag indicating that the locality part was changed.
			</scoringKey>
			<scoringKey name="AI_STREET_CHANGED">
			A scoring flag indicating that the street name was changed.
			E.g. &#39;Třída 1. máje&#39; (in the input) is actually named &#39;1. máje&#39; (the official name).
			</scoringKey>
			<scoringKey name="AI_LRN_CHANGED">
			A scoring flag indicating that the land registry number was changed.
			</scoringKey>
			<scoringKey name="AI_SN_CHANGED">
			A scoring flag indicating that the street number was changed.
			</scoringKey>
			<scoringKey name="AI_ZIP_CHANGED">
			A scoring flag indicating that the ZIP was changed.
			</scoringKey>
			<scoringKey name="AI_POST_OFFICE_CHANGED">
			A scoring flag indicating that the post office name was changed.
			</scoringKey>
			<scoringKey name="AI_MUNICIPALITY_PART_CHANGED">
			A scoring flag indicating that the municipality part was changed.
			</scoringKey>
			<scoringKey name="AI_LRN_TYPE_CHANGED">
			A scoring flag indicating that type of land registry number has changed.
			It either has been parsed as evidence number (číslo evidenční) 
			and should have been a house number (číslo popisné) or vice versa.
			</scoringKey>
			<scoringKey name="AI_DISTRICT_SET">
			A scoring flag indicating that the district was found and replaced from the dictionary file.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_SET">
			A scoring flag indicating that the locality was found and replaced from the dictionary file.
			</scoringKey>
			<scoringKey name="AI_LOCALITY_PART_SET">
			A scoring flag indicating that the locality part was found and replaced from the dictionary file.
			</scoringKey>
			<scoringKey name="AI_STREET_SET">
			A scoring flag indicating that the street was found and replaced from the dictionary file.
			</scoringKey>
			<scoringKey name="AI_LRN_SET">
			A scoring flag indicating that the land registry number was found and replaced from the dictionary file.
			</scoringKey>
			<scoringKey name="AI_SN_SET">
			A scoring flag indicating that the street number was found and replaced from the dictionary file.
			</scoringKey>
			<scoringKey name="AI_ZIP_SET">
			A scoring flag indicating that the ZIP was found and replaced from the dictionary file.
			</scoringKey>
			<scoringKey name="AI_POST_OFFICE_SET">
			A scoring flag indicating that the post office was found and replaced from the dictionary file.
			</scoringKey>
			<scoringKey name="AI_MUNICIPALITY_PART_SET">
			A scoring flag indicating that the municipality part was found and replaced from the dictionary file.
			</scoringKey>
			
			<!-- ambiguity scorer -->
			<scoringKey name="AI_AMBIG_CL">City and land registry number are not sufficient to uniquely identify address id.</scoringKey>
			<scoringKey name="AI_AMBIG_CL_CD">City and land registry number with city district are not sufficient to uniquely identify address id.</scoringKey>
			<scoringKey name="AI_AMBIG_CL_ZCD">City and land registry number with ZIP are not sufficient to uniquely identify address id.</scoringKey>
			<scoringKey name="AI_AMBIG_CS_N">City and street with street number are not sufficient to uniquely identify address id.</scoringKey>
			<scoringKey name="AI_AMBIG_SN_Q">Street and street number with city part are not sufficient to uniquely identify address id.</scoringKey>
			<scoringKey name="AI_AMBIG_ZCD_L">ZIP, city and city district with land registry number are not sufficient to uniquely identify address id.</scoringKey>
			<scoringKey name="AI_AMBIG_ZCS_L">ZIP, city and street with land registry number are not sufficient to uniquely identify address id.</scoringKey>
			<scoringKey name="AI_AMBIG_ZCS_N">ZIP, city and street with street number are not sufficient to uniquely identify address id.</scoringKey>
			<scoringKey name="AI_AMBIG_ZC_L">ZIP and city with land registry number are not sufficient to uniquely identify address id.</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.components.addresses.can.CAAddressesIdentifier">
    <introduction>
		Cleanses Canadian addresses.

		Component works in SERP Certification mode (validation and addresses correction according to Canada Post requirements) with ability to standardize the input.

Recognizable addresses:

<ul>
    <li>Civic address  (street address)</li>
    <li>Civic address (street served by route address)</li>
    <li>Lock Box address</li>
    <li>Route service address</li>
    <li>General delivery address</li>
</ul>
<pre>
Municipality, Province and Postal Code are necessary for the proper identification of each type of address.
Lock box, Route service and GD adresses should not have street line starting with number (it leads to incorrect recognition of address type and therefore wrong parsing).

Requirements for address delivery line:

CIVIC ADDRESS (street address)
Street Line of the address should contain a street number and street name (preferrably in this order): .
It may also contain any of the following: apartment or suite number, street number suffix, street type or street direction.
Recommended order for possible street line content (this is only an introduction of the expected order of street line elements) -
Example:

    415 HERITAGE CRES UNIT 102
    SASKATOON SK S7H 5M5

    11D JESSOME ST
    GLACE BAY NS B1A 5H9

    104-2701 23RD AVE
    REGINA SK S4S 1E5

    225 RUE FLEURY O
    MONTREAL QC H3L 1T8

CIVIC ADDRESS (street served by route address)
Requirements of this type of address are the same as street address requirements with addition of rural route type and number.
Example:

    1920 BLAIR LAKE RD RR 6
    AMHERST NS B4H 3Y4

LOCK BOX ADDRESS
This type of address has to contain a delivery type identifier which would mark the address as Lock Box type; the most common being PO BOX, BOX or CASE POSTALE.
In order for this type to be identified correctly, a box number is needed as well, possibly along with a station type and/or name (the name might be number or text).
Example of station type is STN, LCD or PO.
Example:

    PO BOX 6001 LCD 1
    VICTORIA BC V8P 5L4

ROUTE SERVICE ADDRESS
This type of address has to contain a route service identifier in order to be recognized, e.g. MOBILE ROUTE (or MR), ROUTE RURALE (RR), SUBURBAN SERVICE (SS).
In order for this type to be identified correctly, a route number is necessary for most of the addresses, possibly along with station type and/or name.
(Although in some cases a station type and name could suffice.)
Example:

    RR 1 ETOBICOKE STN B
    TORONTO ON M9W 5K7

    RR 2
    SALMON ARM BC V1E 4M2

GENERAL DELIVERY ADDRESS
This type of address requires a GD identifier, e.g. GD, IM, POSTE RESTANTE (or PR).
To identify the address properly a station type or/and name might be needed.
Example:

    GD
    COLD LAKE AB T0A 0V0
    (General delivery address)
</pre>
		</introduction>
    <properties>
			<property name="inEndPoint" type="com.ataccama.dqc.components.addresses.can.CANAddressesGenerated$InEndPoint" required="true">
			Input column mappings.
			</property>
			<property name="outEndPoint" type="com.ataccama.dqc.components.addresses.can.CANAddressesGenerated$OutEndPoint" required="true">
			Output column mappings.
			</property>
			<property name="cleansedEndPoint" type="com.ataccama.dqc.components.addresses.can.CANAddressesGenerated$CleansedEndPoint" required="true">
			Cleansed output column mappings. Available for identified addresses only.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="dataDir" type="string" required="true">
			    Directory with lookup files for Canadian addresses. Must point to directory named &#39;data&#39;
                in the standard folder hierarchy (&lt;project&gt;/data/ext/lkp/ca_address_identifier).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.components.addresses.gb.GBAddressIdentifier">
    <introduction>The goal of this solution is cleansing, standardization and
 enrichment of GB addresses and to find UDPRN (Unique
 Delivery Point Reference Number), if possible.
			<bullet_list>
				<item>Input: 5 address lines and postcode attribute</item>
				<item>Output: Best output address data (validated, precleansed or input) in 7 components (out_building, out_thfare, out_locality, out_post_town, out_postcode, out_dps,</item>
			</bullet_list>
        	Each component contains general description of behavior in yellow comments at the beginning of each plan as well as detailed technical description of the whole solution.
			<ul>
				<li>•Address validation process : </li>
				<li>•Simple decoding - Transformation into upper case for all input barring src_postcode.</li>
				<li>•Preparation for working columns : merging for address lines.</li>
				<li>•Postcode extraction.</li>
				<li>•Check if the input is null and if so provides scoring and explanation code.</li>
				<li>•If the input is not null : multiple commas are merged into one and commas and dots and other abbreviations from the start of each input are removed.</li>
				<li>•Extraction of countries, posttowns and places via parsing.</li>
				<li>•Record descriptors are merged into one.</li>
				<li>•Null or Unknown addresses are assigned proper label.</li>
				<li>•Address branches are united, working columns are removed.</li>
			</ul>
        	Input values of address component are used in case the
        	address in not sufficiently identified.
        	
			<ul>
				<li>•out_county,out_district,out_post_town require the address to be identified </li>
				<li>•out_locality,out_thfare_name,out_thfare_desc require the address to be identified </li>
				<li>•out_postcode,out_building_number,out_building_name require the address to be identified </li>
				<li>•out_sub_building,out_organization,out_udprn,out_dps require the address to be identified </li>
			</ul>Test data contains set of addresses with various types. Data is targeted on only one locality because of limited set of reference addresses (post town SALISBURY).Component uses sample reference data. Reference data contains only addresses in post town SALISBURY.
		</introduction>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="inEndPoint" type="com.ataccama.dqc.components.addresses.gb.GBAddressesGenerated$InEndPoint" required="true">
                Input endpoint column mappings.
            		</property>
			<property name="outEndPoint" type="com.ataccama.dqc.components.addresses.gb.GBAddressesGenerated$OutEndPoint" required="true">
                Output endpoint column mappings.
            		</property>
			<property name="dataDir" type="string" required="true">
                Directory with lookup files for English addresses. Must point to directory named &#39;data&#39;
                in the standard folder hierarchy (&lt;project&gt;/data/ext/lkp/gb_address_identifier).
            		</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.components.addresses.us.USAddressesIdentifier">
    <introduction>
		Cleanses US addresses. Recognizable addresses Recommended input street line formats are following:
		<ul>
    <li>Standard address</li>
    <li>PO BOX address</li>
    <li>Rural route address</li>
    <li>General delivery address</li>
</ul>
		<pre>
STANDARD ADDRESS STREET LINE 1 CAN CONTAIN THESE INFORMATION:

    {street number} {cardinal direction} {street type before name} {street name} {street type} {cardinal direction} {unit descriptor} {unit number}


Possible cardinal direction, unit descriptor and street type formats can be found in etalons, also poud sign # can be used as unit descriptor.
Example:

    799 E DRAGRAM SUITE 5A
    300 BOYLSTON AVE E
    799 E DRAGRAM



POBOX ADDRESSES SHOULD HAVE 1ST LINE IN FORMAT:

    {PO BOX identifier} {Box number}


PO Box identifier formats can also be found in relevant etalon
Example:

    PO BOX 1022



RURAL ROUTE ADDRESsES SHOULD HAVE 1ST LINE IN FORMAT:

    {route type} {1-3 digit route number} BOX {alphanumeric box number - might contain also hyphens}


Route type (possible formats in etalon - more in chapter Lookup files and external sources) and route number are mandatory to properly identify rural route address. If route number is missing, address is still considered rural route type but might not be properly identified. Some addresses might contain box and box number and some not.
Example:

    RR 6 BOX 152



GENERAL DELIVERY ADDRESSES SHOULD HAVE 1ST LINE IN FORMAT:

    {general delivery identifier}


General delivery identifiers can be found in etalon.
Example:

    General Delivery (address of postal office should come then in address line 2)



ADDRESS LINE 2 SHOULD CONTAIN INFORMATION IDENTIFYING A CITY:

    {name of a city}



ADDRESS LINE 3 SHOULD CONTAIN INFORMATION IDENTIFYING A STATE:

    {name or shortcut of US state}



CITY AND STATE CAN BOTH COME IN ONE COLUMN (STREET LINE 2 OR STREET LINE 3):

    {name of a city}, {name or shortcut of US state}


Example:

    street line 2 can contain &quot;Fishkill, NY&quot;
    (street line 3 might be empty)



ZIP CODE SHOULD CONTAIN INFORMATION IDENTIFYING A POSTAL CODE:
It is expected in following formats:

    {5 digits}
    {5 digits}-{4 digits}
    {9 digits}


However, the component can process these formats too:

    {text}{5 digits}{text}
    {text}{5 digits}-{4 digits}{text}
    {4 digits} and so on (any format where 4, 5 or 9 digital zip code can be parsed out)



ZIP CODE CAN BE RECOGNIZED IN ADDRESS LINE 2 OR 3 AS WELL:
Example:

    ^Fishkill, NY 12524^ (works only if zip is at the end of the string)
		</pre>

		</introduction>
    <properties>
			<property name="input" type="com.ataccama.dqc.components.addresses.us.USAddressesGenerated$InEndPoint" required="true">
			Input endpoint column mappings.
			</property>
			<property name="output" type="com.ataccama.dqc.components.addresses.us.USAddressesGenerated$OutEndPoint" required="true">
			Output endpoint column mappings.
			</property>
			<property name="output" type="com.ataccama.dqc.components.addresses.us.USAddressesGenerated$CleansedEndPoint" required="true">
			Cleansed output column mappings.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property> 
			<property name="dataDir" type="string" required="true"> 
			    Directory with lookup files for US addresses. Must point to directory named &#39;data&#39;
                in the standard folder hierarchy (&lt;project&gt;/data/ext/lkp/us_address_identifier).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.loqate.AddressInputElement">
    <properties>
			<property name="elementName" type="string" required="true">
				Name of the input address element.
			</property>
			<property name="column" type="string" required="true">
				String column or expression with address element value.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addressdoctor.AddressInputElement">
    <properties>
			<property name="elementName" type="com.ataccama.dqc.tasks.addressdoctor.AddressElementName" required="true">
				Name (or type) of the address element. The list of elements may contain more than
				one item of the same element type, but the number is limited depending of the type.
				E.g. you can parse up to six street elements.  
			</property>
			<property name="column" type="string" required="true">
				String column or expression with address element value.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.uiradr.UirAdrGenerator">
    <introduction>Compiles the source of address reference data for the Address Identifier.</introduction>
    <description>
			This step compiles source data of the UIR-ADR into a format readable
			by the <strong>Address Identifier</strong> step.
			<br/>
			The address identification suite relies on synonyms defined for each
			address component separately (e.g., streets named like &#39;Boženy Němcové&#39;,
			&#39;Němcové&#39;, &#39;B. Němcové&#39; etc. are unified under a common name &#39;Němcové&#39;).
			This unification is a two step process consisting of partial
			and full replacement.
		</description>
    <bindings/>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="destFolder" type="string" required="true">
				Folder where compiled files are stored. If the folder doesn&#39;t exist, it is created. 
				If it does exist, it is cleared so that any .lkp, .cif or .cifIndex file is removed.
			</property>
			<property name="replacements" type="com.ataccama.dqc.tasks.addresses.uiradr.Replacement[]" required="false">
				List of replacements for particular address components. The list doesn&#39;t necessarily
				define replacements for all components.<br/>
				Default value: <code>empty list</code>.
			</property>
			<property name="sourceFolder" type="string" required="true">
				Folder containing source files of the UIR-ADR
			</property>
			<property name="workFolder" type="string" required="false">
				The working folder.<br/>
				Default value: folder referenced by the java.io.tmpdir variable or
				system temporary folder if the variable is not set.
			</property>
			<property name="uirAdrEncoding" type="string" required="false">
				Specifies the encoding of input files. <br/>
				Default value: windows-1250 for UIR-ADR mode, UTF-8 for RUIAN mode.
			</property>
			<property name="activeAddressesOnly" type="boolean" required="true">
				Indicates whether accept only valid (i.e. current) addresses or removed addresses as well.<br/>
				Default value: <code>false</code>.				
			</property>
			<property name="generateExactIndices" type="boolean" required="true">
				Indicates to generate indices to be used by 
				<strong>ExactAddressIdentifier</strong>algorithm.<br/>
				Default value: false.
			</property>
			<property name="mode" type="com.ataccama.dqc.addresses.commons.AddressModeType" required="false">
				Defines type of source data. <br/>Possible values: <code>UIR-ADR</code> and <code>RUIAN</code>.
				Default value: UIR-ADR.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.addresses.commons.AddressModeType">
    <introduction>
			Mode of operation for various address related steps. It defines values:
			<ul>
				<li>
          <code>UIR-ADR</code> - represents legacy mode</li>
				<li>
          <code>RUIAN</code> - represents changes that were introduced when RUIAN has
					been launched. These changes include new way of creating postal address and also
					new source files of address reference data.</li>
			</ul>
		</introduction>
  </class>
  <class name="com.ataccama.dqc.loqate.AddressOutputElement">
    <properties>
			<property name="elementName" type="string" required="true">
				Name of the output address element.
			</property>
			<property name="column" type="string" required="true">
				String column for storing address element of parsed address.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addressdoctor.AddressOutputElement">
    <properties>
			<property name="elementName" type="com.ataccama.dqc.tasks.addressdoctor.AddressElementName" required="true">
				Name (or type) of the address element. The list of elements may contain more than
				one item of the same element type, but the number is limited depending of the type.  
			</property>
			<property name="column" type="string" required="true">
				String column for storing address element of parsed address.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.parser2.AddressPattern">
    <introduction>
			Address pattern definition.
		</introduction>
    <properties>
			<property name="ruleName" type="string" required="false">
				Name of the pattern.<br/>
				Default value: none.
			</property>
			<property name="definition" type="string" required="true">
				Pattern definition - a string containing component references (with appropriate properties
				if desired) and strings to be present in the input in that order.
				For a detailed description of components usable in
				patterns, see <strong>patterns</strong> in AddressIdentifier algorithm.
			</property>
			<property name="priority" type="integer" required="true">
				Priority of the pattern. If there are two or more patterns
				with the same quality (cannot decide which pattern to match to the
				input as the best), the pattern with the highest priority is selected.
				Higher value means higher priority.<br/>
				Default value: 0.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.parser2.AddressPatternGroup">
    <introduction>
			Address pattern group definition.
		</introduction>
    <properties>
			<property name="name" type="string" required="false">
				Name of the pattern.<br/>
				Default value: none.
			</property>
			<property name="patterns" type="com.ataccama.dqc.tasks.addresses.parser2.AddressPattern[]" required="false">
				Definition of this group&#39;s patterns.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addressdoctor.AddressResultParameter">
    <properties>
			<property name="parameterName" type="com.ataccama.dqc.tasks.addressdoctor.ResultStatusName" required="true">
				Type of result code.
			</property>
			<property name="column" type="string" required="true">
				String column for storing code.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.aggregator.AggregatingColumnAssigner">
    <introduction>Computes aggregated values for one or more sets of record groups.</introduction>
    <description>
			Calculates aggregation expression based on one or more grouping.
			The result of expression is assigned to record column similar to ColumnAssigner step.
			Each grouping is defined in the <code>Aggregations</code> element which defines
			grouping key components and a set of aggregating expressions.
		</description>
    <properties>
			<property name="aggregations" type="com.ataccama.dqc.tasks.analysis.aggregator.AggregatingColumnAssigner$Aggregation[]" required="true">
				Set of definitions of aggregation.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.bob.AggregatingOrderBy">
    <properties>
			<property name="expression" type="string" required="true">
			Specifies the expression evaluated to a value used in sorting. May contain aggregating functions.
			</property>
			<property name="locale" type="string" required="false">
			Locale definition for compared string values.
			</property>
			<property name="nullsFirst" type="boolean" required="true">
			Specifies whether null records should be sorted at the beginning of the data set.
			</property>
			<property name="orderDescending" type="boolean" required="true">
			Specifies the sort direction.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.aggregator.AggregatingColumnAssigner$Aggregation">
    <properties>
			<property name="groupBy" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
				Set of definitions of grouping keys.
			</property>
			<property name="assignments" type="com.ataccama.dqc.tasks.common.column.ColumnAssign[]" required="true">
				Set of definitions of aggregated values and target columns.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.aggregator.Aggregation">
    <properties>
			<property name="expression" type="string" required="true">
				Aggregating expression. Must not contain any column reference outside
				of aggregating functions, e.g. <code>avg(score_instance) + 100</code> is
				correct but <code>avg(score_instance) + score_name</code> is not.
			</property>
			<property name="name" type="string" required="true">
				Name of output column storing the aggregated value.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.aggregator.AggregationSet">
    <properties>
			<property name="aggregations" type="com.ataccama.dqc.tasks.analysis.aggregator.Aggregation[]" required="false">
				Set of definitions of aggregated values and target columns.
			</property>
			<property name="groupBy" type="com.ataccama.dqc.tasks.analysis.aggregator.Component[]" required="true">
				Set of definitions of grouping keys and target columns.
			</property>
			<property name="when" type="string" required="false">
				Condition for performing this aggregation set.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ISearchMethodDefinition" name="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.AhoCorasickMethod">
    <introduction>
    		Original input text examination method that uses the Aho-Corasick algorithm.
    	</introduction>
    <description>
    		This method finds known values even as substrings which can generate
    		many matches, thus many variants, and possibly many proposals.
    	</description>
    <properties>
		  <property name="inputComponents" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference[]" required="true">
		      List of input components to be searched for.
		  </property>
		  
		</properties>
  </class>
  <class super="com.ataccama.adt.task.iterators.order.IOrder" name="com.ataccama.adt.task.iterators.order.AlphabeticalOrder">
    <introduction> </introduction>
    <description> </description>
    <properties>
			<property name="locale" type="string" required="false"> </property>
			<property name="reverse" type="boolean" required="true"> </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.AlterFormat">
    <introduction>Transforms data flow.</introduction>
    <description>
		Performs transformation of the input data format.

		The output data is given new data formats, either by removing or adding new column definitions.
		New columns are added behind existing columns of the input format, and can be initialized
		as part of the column definition. Columns can be replaced (the data type can be changed and values converted)
		by both removing and adding. The position of replaced column will be the same as in input format.
		<br/>
      <br/>

		<p align="justify">
			In the following example, the column <code>data</code> will be removed, then a new column <code>newday</code> will be added.
			Next, the column <code>id</code> will be converted to a string by first being removed, then added as a column with the
			same name, and evaluated with the expression toString(). Other format columns will remain unchanged.
		</p>
		</description>
    <bindings>
		</bindings>
    <properties>	
			<property name="addedColumns" type="com.ataccama.dqc.tasks.flow.AddedColumn[]" required="false">
			List of columns to be added.
			</property>
			<property name="removedColumns" type="com.ataccama.dqc.tasks.common.column.ColumnRef[]" required="false">
			List of columns to be removed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property> 
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.frequency.Analysis">
    <description>Column-specific analytical node.</description>
    <properties>
			<property name="classification" type="string" required="false">
			Column name for classification values.
			</property>
			<property name="expression" type="string" required="true">
			The specified multi-column expression, or a single <em>column</em> expression, to evaluate
			for all records.
			</property>
			<property name="locale" type="string" required="false">
			Locale definition for a specified column.
			</property>
			<property name="name" type="string" required="true">
			Name of the analysis.
			</property>
			<property name="range" type="com.ataccama.dqc.tasks.analysis.frequency.RangeCfg" required="false">
			Output range for given interval values. If not specified, discrete value analysis will be used.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.text.AnalyzedColumn">
    <description>
		Definition of a single pair of source and destination columns.
		</description>
    <properties>
			<property name="dest" type="string" required="true">
			Destination column name.
			</property>
			<property name="maskWithUnknownLeft" type="string" required="false">
			Destination column where not found words are left as they were.
			</property>
			<property name="maskWithUnknownReplaced" type="string" required="false">
			Destination column where not found words are replaced by the symbolForUnidentifiedWords property.
			</property>
			<property name="src" type="string" required="true">
			Source column name.
			</property>
			<property name="patterns" type="com.ataccama.dqc.tasks.text.WordAnalyzer$Pattern[]" required="false">
			Output masks can be replaced (and unified) furthermore by these patterns.
			</property>
			<property name="usePatterns" type="boolean" required="true">
			If the patterns should be applied to the output mask.
			</property>
			<property name="trash" type="string" required="false">
			The unidentified words are stored into this column.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="WM_PATTERN_NOT_FOUND">A scoring flag indicating that no pattern has been applied.</scoringKey>
      		<scoringKey name="WM_NULL_INPUT">A scoring flag indicating that the analyzed column was empty.</scoringKey>
      		<scoringKey name="WM_UNKNOWN_WORD">A scoring flag indicating that the analyzed column contained a word which wasn&#39;t found in any dictionary file.</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.text.CharacterGroupsAnalyzer$AnalyzedColumn">
    <introduction>
			Definition of pair of the source and destination columns.
		</introduction>
    <properties>
			<property name="dest" type="string" required="true">
				Destination column name. The column must be of string type.
			</property>
			<property name="src" type="string" required="true">
				Source column name. The column must be of string type.
			</property>
			<property name="copyUnknownCharacters" type="boolean" required="false">
				Specifies if characters that do not belong to any character group specified are copied (<code>true</code>) or skipped in the output column.
				<br/>Default: value of global <code>Copy Unknown Characters</code>
			</property>
			<property name="characterGroups" type="com.ataccama.dqc.tasks.common.text.CharacterGroup[]" required="false">
				List of character group definitions.
				<br/>Each character from the input is tested to see if it belongs to a specified group.
				In case it meets the criteria for more than one group, the first of them is used.
				For example, when numeric group as first and alphanumeric group as
				second are defined, the input word &quot;ABC123&quot; is not assumed as one alphanumeric sequence,
				but one alphanumeric (ABC) followed by one numeric (123).
				<br/>Default: groups definition specified in global <code>Default Character Groups</code>
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="CG_NULL_INPUT">A scoring flag indicating that the analyzed column was empty.</scoringKey>
      		<scoringKey name="CG_UNKNOWN_CHAR">A scoring flag indicating that the analyzed column contained undefined character.</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.anonymizer.AnonymizerAlgorithm">
    <introduction>Anonymizes Czech birth numbers, birth dates and names.</introduction>
    <description>
			This step anonymizes the input data. The content of the output data is different than the input, but
			all the essential characteristics of the data are retained. The step supports the following data types:
				<table border="1">
					<th>
						<th>Data Type</th>
						<th>Description</th>
					</th>
					<tr>
						<td>Date (of birth)</td>
						<td>
							Date is mostly used in conjunction with birth number (RC) and therefore it preserves the RC eras
							(see below). If the date is outside of the allowed range the transformation doesn&#39;t take place,
						  the input value is sent to output unchanged and the AA_BD_NOT_CHANGED flag is set.<br/>
							This step shifts the date within the original RC era. The older the date (meaning how far
							it is from <code>Birth Day Max</code>), the wider the range from which the transformed date is
							chosen from. The minimum range is 1 year (ie. +/- 6 months from the input date) This range gets
							wider for dates	further in the past(relative to <code>Birth Day Max</code>. At least one year
							difference is required between <code>Birth Day Max</code>	and <code>Birth Day Min</code> to ensure the minimum range.<br/>
							For the step to be able to generate dates that are random enough and within the right RC era, the
							following restrictions apply to <code>Birth Day Max</code> and <code>Birth Day Min</code>:
							<ul>
								<li>minimum 1 year difference between <code>Birth Day Min</code> and <code>Birth Day Max</code>
              </li>
							  <li>
                <code>Birth Day Min</code> must not be within 1 year before 1.1.1954
									or within 1 year before 1.4.2004</li>
							  <li>
                <code>Birth Day Max</code> must not be within 1 year after 1.1.1954
									or within 1 year after 1.4.2004</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Birth Number (RC)</td>
						<td>The transformation of RC follows these rules:
								<ul>
									<li>
										The transformation occurs only if the date part of the RC is valid, not artificial and consists of
										either 6,9 or 10 characters. Otherwise the input is copied to the output and the
										<code>AA_RC_NOT_CHANGED</code> is set.
									</li>
									<li>if a date is on the input and
										<ul>
											<li>the input date is outside the allowed range: the input date is copied to the output and the input RC is
												copied to the output. The <code>AA_BD_NOT_CHANGED</code> and  <code>AA_RC_NOT_CHANGED</code> flags
												are set.</li>
											<li>the input date matches the date from the RC:  both dates are transformed to the same date</li>
											<li>the input date doesn&#39;t match the date from the RC:  both dates are transformed independently and
												the <code>AA_RC_MISMATCH</code> flag is set.</li>
										</ul>
									</li>
									<li> if there is no date on the input and
										<ul>
											<li>the date from RC is outside the allowed range: the input value is copied to the output and the
												<code>AA_RC_NOT_CHANGED</code> is set.</li>
											<li>the date from RC is within the allowed range: the date is transformed and the
												<code>AA_RC_CENTURY_GUESSED</code> flag is set. The missing year from the RC is guessed as
												the last possible year before <code>Birth Day Max</code>
                  </li>
										</ul>
              </li>
									<li>preserves the era of the input RC, i.e., the output RC is from the same era as the input RC. 3 eras
										are recognized (as intervals): <br/>
										  &lt;<code>Birth Day Min</code>,31.12.1953&gt;, &lt;1.1.1954,31.3.2004&gt;,
										  &lt;1.4.2004,<code>Birth Day Max</code>&gt;</li>
									<li>preserves the sex from RC</li>
									<li>preserves the extended form of the month</li>
									<li>preserves the length of the RC - the trailer in 10-digit RC is modified (see below), the trailer in
										9-digit RC are sent to the output unmodified</li>
									<li>preserves the CRC characteristics for 10-digit RC
											<ul>
												<li>if the input RC has a valid CRC - the output RC also has a valid CRC (the last digit of the
													trailer is modified accordingly)</li>
												<li>if the input RC has an invalid CRC - the output RC also has an invalid CRC, which differs from
													the correct one by the same value as on the input (the last one or two digits of the trailer are
													modified accordingly)</li>
											</ul>
									</li>
								</ul>
						</td>
					</tr>
					<tr>
						<td>
							First Name
						</td>
						<td>
							The transformation occurs for known names. It preserves:
							<ul>
								<li>roughly the number and the positions of capital letters</li>
								<li>sex (based on the name)</li>
							</ul>

							The quality of the transformation (preserving sex etc..) depends on the dictionary used. When creating
							the dictionary, the names must be divided into 9 groups (masculine, feminine and neutral for first name, last name and 
							both) and within these groups suitable replacements with similar frequency occurrences must be found.<br/>
            <br/>
							The transformation of a name (first and last) consists of its replacement with another name using a
							<code>Name Lookup File Name</code> dictionary. Single and multiple word names are processed. Each token is
							considered a name if it consists only of letters and/or the apostrophe character (&#39;). Other tokens
							(i.e., non-letter) are considered to be delimiters and are not transformed by the step. The transformed
							names are sent to the output separated by the original delimiters.<br/>
							In case the name (or one of the names, if the input contains more than one token) is not found in the
							dictionary, the input as a whole is considered invalid, the appropriate flag is set
							(<code>AA_FN_NOT_CHANGED</code> or <code>AA_LN_NOT_CHANGED</code>) and the input is copied to the output
							unmodified.<br/>
            <br/>
							The dictionary is a <strong>Lookup table</strong>. 
							The input name is used as the key and the value is the replacement for the original name. Both values must be 
							transformed to uppercase before being inserted into the dictionary (the dictionary must be created with the
							<code>doUppercase</code> parameter set to on).
						</td>
					</tr>
					<tr>
						<td>
							Last name
						</td>
						<td>
							The same rules and restrictions apply as with first names.
						</td>
					</tr>
				</table>
			This step ensures that for all pairs of identical input values, identical output values will be generated.
			If any input value is empty, then the output is also empty (no flag is set).
			</description>
    <properties>
			<property name="rc" type="string" required="true">
				Input/output for RC.
			</property>
			<property name="birthDate" type="string" required="true">
				Input/output for birth date.
			</property>
			<property name="firstName" type="string" required="false">
				Input/output for first name.
			</property>
			<property name="lastName" type="string" required="false">
				Input/output for last name.
			</property>
			<property name="birthDayMax" type="date" required="false">
				The maximum possible date which:
				<ul>
					<li>is considered valid in the input.</li>
					<li>can appear in the output.	</li>
				</ul>
				Default value: The day of execution of the configuration.
			</property>
			<property name="birthDayMin" type="date" required="false">
				The minimum possible date which:
				<ul>
					<li>is considered valid in the input.</li>
					<li>can appear in the output.	</li>
				</ul>
				The minimum difference between <code>Birth Day Min</code> and <code>Birth Day Max</code> is 1 year.<br/>
				Default value: <code>1.1.1901</code>

			</property>
			<property name="changeNames" type="boolean" required="true">
				Determines whether first and last names will be processed. If set to true, the properties <code>First Name</code>
				and <code>Last Name</code> and the property <code>Name Lookup File Name</code> are required.
				<br/>Default value: <code>false</code>
			</property>
			<property name="nameLookupFileName" type="string" required="false">
				Filename of the dictionary containing the replacement names. Required if <code>Change Names</code> is set to
				<code>true</code>
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="AA_FN_NOT_CHANGED">
				A scoring entry indicating that an unknown first name is in the input. The input value is copied to the output.
			</scoringKey>
			<scoringKey name="AA_LN_NOT_CHANGED">
				A scoring entry indicating that an unknown last name is in the input. The input value is copied to the output.
			</scoringKey>
			<scoringKey name="AA_RC_NOT_CHANGED">
				A scoring entry indicating that an invalid RC is in the input (illegal characters, wrong length, invalid date part).
				The input value is copied to the output.
			</scoringKey>
			<scoringKey name="AA_RC_DATE_MISMATCH">
				A scoring entry indicating that the input date doesn&#39;t match the date from RC. The date in RC has been transformed
				based on the date from the input RC.
			</scoringKey>
			<scoringKey name="AA_BD_NOT_CHANGED">
				A scoring entry indicating that the input date hasn&#39;t been transformed because the value is outside the allowed range.
			</scoringKey>
			<scoringKey name="AA_RC_CENTURY_GUESS">
				A scoring entry indicating that the date in RC has been transformed based on the date guessed from the input RC,
				because no input date value has been found (i.e., the year from RC has been guessed as the last possible year before
				<code>Birth Day Max</code>).
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ApplyReplacementsAlgorithm">
    <introduction>Replaces occurrences of words with their replacements based on dictionary files.</introduction>
    <description>
		    This step has two modes in dependence on <code>onlyFullReplacement</code>. First it only looks for the input in the dictionary and if it finds then it puts
		    the dictionary value to the <code>out</code> column. Second 
			it performs replacements of all known (defined) strings within the given text string, where 
			the final value is stored in the data output. Transformations are stored in the specified dictionary 
            as a pair of the source value (text to be replaced) and final value (replacement).
			This step replaces the longest substring of the input that equals the source definition value
			in the dictionary containing the replacement values.
		</description>
    <properties>
			<property name="in" type="string" required="true">
				Column that contains the input text.
			</property>
			<property name="out" type="string" required="true">
				Column that stores the transformed output text.
			</property>
			<property name="replacementsFileName" type="string" required="true">
				Dictionary file that contains the source value of the replacement
				(text to be replaced) and final value (replacement).
				For more information about the dictionary see a (<strong>detailed description</strong>).
			</property>
			<property name="tokenizer" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Setting of parsing mechanism used to tokenize input strings.
				The default tokenizer setting distinguishes words, numbers and other single characters, except
				for whitespace characters (space, tab). In the following dictionary, the default setting is used.
				Note that when onlyFullReplacement set on, this mechanism is not used.
			</property>
  			<property name="onlyFullReplacement" type="boolean" required="true"> 
  			    If true then only the whole input string is looked up in the dictionary otherwise it looks for substrings
  			    split by tokenizer.
  			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property> 
  			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="ignoredSeparators" type="string" required="false">
				Definition of characters that might be ignored when input token
				cannot be matched to expected token in translation rule. 
				Expected token can be ignored only if it is defined as ignorable,
				with input token either being skipped when it is ignorable as well, or preserved.
				<br/>
				The set is defined by means of <strong>character set</strong>.
				For a detailed description see <strong>Strip titles</strong>
				and its <strong>example</strong>.<br/>
				Note that when <code>Only Full Replacement</code> set on, this mechanism is not used.<br/>
				Default value: none.
			</property>
			<property name="preserveUnsupportedChars" type="boolean" required="false">
			    If true then unsupported characters immediately following replaced text will be copied to
			    output, otherwise these characters will be removed. For detailed description of these characters,
                see <strong>Matching Value Generator Config</strong>.<br/>
			    Default value: <code>true</code> 
			</property>
  		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="AR_CHANGED">
				A scoring flag indicating that some strings within the input text were replaced.
			</scoringKey>
			<scoringKey name="AR_NULL">
			    The input string is null.
			</scoringKey>
			<scoringKey name="AR_MULTI">
			    One value was found and replaced in the input string more than one time.
			</scoringKey>
			<scoringKey name="AR_MORE">
			    There were at least two different values found and replaced in the input string.
			</scoringKey>
		</scoring>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.ApproximateQuantiles">
    <introduction>The approximate quantiles analysis displays the data values that occur at designated intervals in the ordered data set. The first value in the list is at  0% and the last value is at 100%. The median value is at the 50% marker.</introduction>
    <properties>
			<property name="error" type="double" required="true">Margin of Error.</property>
			<property name="numberOfQuantiles" type="integer" required="true">Specifies the number of quantiles categories.<br/>Default value: <code>10</code>.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.unify.config.IOperationConfig" name="com.ataccama.dqc.unify.config.AssignOperation">
    <introduction>
			Performs common expression evaluation and assigns the result to a column. See <strong>Column Assigner</strong> for more details.
		</introduction>
    <description>
		</description>
    <properties>
			<property name="id" type="string" required="true">
				Unique operation id.
			</property>
			<property name="assignments" type="com.ataccama.dqc.tasks.common.column.ColumnAssign[]" required="false">
				List of assignments. Has the same meaning as in the <strong>Column Assigner</strong> step.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.expressions.Assignment">
    <properties>
			<property name="column" type="string" required="true">
				Column that stores the final result of the defined expression.
			</property>
			<property name="expression" type="string" required="true">
				An expression whose result is assigned to the output.
				For a list of all available expressions and their definitions, refer to <strong>Expressions</strong>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="CA_CHANGED">
				An individual (for each assignment) scoring flag indicating that the value in the assigned
				column has changed (i.e. the final column value is different from the initial value).
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.expressions.DynamicExpressionAssigner$Assignment">
    <properties>
			<property name="column" type="string" required="true">
				Column that stores the final result of the evaluated expression.
			</property>
			<property name="expression" type="string" required="true">
				A string expression whose result is expression that have to be evaluated.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="EE_EMPTY">
				Scoring flag indicating that the result of expression is empty, i.e. no expression
				may be evaluated.
			</scoringKey>
			<scoringKey name="EE_INVALID">
				Scoring flag indicating that the result of expression is not valid expression or its type
				is incompatible with target column type.
			</scoringKey>
			<scoringKey name="EE_CHANGED">
				Scoring flag indicating that the value in the assigned
				column has changed (i.e. the final column value is different from the initial value).
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.AbstractGroupAssigner$Assignment">
    <introduction>Column and expression assigned to each group record.</introduction>
    <description>
			Defines column and value that wil be stored into records of group.
			The value is usually calculated by some aggregating function. 
		</description>
    <properties>
			<property name="column" type="string" required="true">
				Name of destination column.
			</property>
			<property name="expression" type="string" required="true">
				Expression to calculate column value.
				Can contain aggregated functions
				evaluated on particular group and reference to record itself.
				<br/>Example: <code>iif(count(score_addr &gt;= 1000) &gt; 0, &quot;N/A&quot;, street)</code>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.Selector$Assignment">
    <introduction>Column and expression assigned to output record.</introduction>
    <description>
			Defines column and value that wil be stored into selected record.
			There are two expressions, one for cases when the group has only one
			record and so no selection is needed, second for groups of more records
			when the best is selected and some aggregating might be needed.
		</description>
    <properties>
			<property name="column" type="string" required="true">
				Name of destination column.
			</property>
			<property name="expression" type="string" required="true">
				Expression to calculate column value when the group has more than one record.
				Can contain aggregated functions
				evaluated on particular group. The context of expression accesses to following
				dot sources:
				<ul>
					<li>
            <strong>best</strong> - selected best record</li>
					<li>
            <strong>second</strong> - second best record</li>
					<li>unnamed source - only inside aggregating functions</li>
				</ul>
				For example: <code>avg(value - best.value) + second.value</code>
			</property>
			<property name="singleRecordExpression" type="string" required="false">
				Expression to calculate column value in case of single record group.
				<br/>Default: Expression for groups of more than one.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.asyncwriter.AsyncWriter">
    <introduction>
			Step providing connection to asynchronous write service. 
		</introduction>
    <description>
			This step is used as writer. Unlike common writers (file, jdbc, ..), the step
			sends incoming records into queue which is read by backend process.
			<br/>
			The backend process (asynchronous writer) is defined as <strong>online service component</strong>
			in service configuration file. 
		</description>
    <properties>
			<property name="serviceName" type="string" required="true">
				Name of asynchronous writer online service.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.asyncwriter.service.AsyncWriterComponent">
    <introduction>Defines parameters for connecting and sending records from AsyncWriter step.</introduction>
    <description>Defines parameters for connecting and sending records from AsyncWriter step.
			<p align="justify">The component takes out the records from a queue created by the AsyncWriter step and sends them to the target (e.g., for processing by a DQC plan) in batches of 25 records.</p>
			<p align="justify">If the queue is empty, the component waits for a record appearance for a time specified in the <strong>Latency Time</strong> parameter. After the timeout expires (AsyncWriter did not provide the records fast enough), the target stops its activity (e.g., a DQC plan finishes). If the AsyncWriter writes new records after the timeout expiration, the target is started again to process the records.</p>
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="latencyTime" type="integer" required="true">Maximum amount of time (s) the component waits before moving records read from the queue into the target. 
				<br/>Default value: 60</property>
			<property name="name" type="string" required="true">Name of the service. Used in the <strong>Service Name</strong> property of the AsyncWriter step.</property>
			<property name="queueSize" type="integer" required="true">Maximal size of a record queue. 
				<br/>Default: 100</property>
			<property name="target" type="com.ataccama.dqc.tasks.experimental.asyncwriter.service.IAsyncWriterTarget" required="true">Specification of target into which records are submitted. Possible implementations: Logger Target, Plan Target.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.asyncwriter.service.IAsyncWriterTarget">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.parquet.reader.Attribute">
    <description>Mapping of a field of Parquet format to DQC column.</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of the attribute and the resulting output column.
			</property>
			<property name="path" type="string" required="true">
				The path (in dot notation) to the field to be associated with this attribute. Relative to the path of the stream this
				attribute belongs to.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
				Type of the output column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.stream.Attribute">
    <description>Mapping of a JSON field to DQC column.</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of the attribute and the resulting DQC column.
			</property>
			<property name="path" type="string" required="true">
				The JSON path to the JSON field to be associated with this attribute. Relative to the JSON path of the stream this
				attribute belongs to. Path containing dot character (&quot;.&quot;) must be surrounded with
				quotation marks (e.g.: &quot;sub.stream&quot;)
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
				Type of the resulting DQC column.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Data formats for parsing string JSON fields into DQC data types. Overrides the data format parameters defined on any
				parent object. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.reader.Attribute">
    <properties>
		 	<property name="name" type="string" required="true">
		 	Name of column in the format of the output end point which is defined in the
		 	parent <code>RecordsOutput</code> configuration element.
		 	</property>
		 	<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
		 	Type of the column.
		 	</property>
		 	<property name="xmlValue" type="boolean" required="true">
		 	Specifies that attribute value will be entire xml code of the (first) matched element.
		 	The type of attribute must be of type string. When xml attribute is evaluated by xpath instead of element, its value is used.
		 	</property>
		 	<property name="xpath" type="string" required="true">
		 	The xpath to a xml element which&#39;s text value will be used as value for column in a
		 	row. It is also possible to use &quot;..&quot; in the xpath to get up but it doesn&#39;t work for
		 	getting xml parts which are in the first level eg. the first rowsRootXPath is /a/b/c
		 	then it is not possible to get from attribute to b or a elements.
		 	</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
					  See <code>Data Format Parameters</code> at the root level of the configuration.
    		  </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.bob.AttributeCfgInst">
    <properties>
			<property name="expression" type="string" required="true">
				Expression used for attribute value calculation. It may contain aggregation functions.
				Accumulation of aggregated values is performed through relevant record groups.
				Column references used outside of the aggregating scope are related to the best selected record,
				identified by &quot;dot&quot; source named <code>best</code>, or the instance itself, identified by source name <code>this</code>.
			</property>
			<property name="name" type="string" required="true">
				Output column name. The column must exist in the input record format.
			</property>
			<property name="resultIfNotFound" type="string" required="false">
				Expression used when no record from the group meets the condition in <code>Acceptance Condition</code>
				and than no best record can be selected.
				The column references in the expression are related to instance itself.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.bob.AttributeCfgRepr">
    <properties>
			<property name="expression" type="string" required="true">
				Expression used for representative&#39;s attribute value calculation. It may contain aggregation functions.
				Accumulation of aggregated values is performed through relevant record groups.
				Column references used outside of the aggregating scope are related to the best selected record.
			</property>
			<property name="name" type="string" required="true">
				Output column name. This name comprises a new column in the format of representative records.
			</property>
			<property name="resultIfNotFound" type="string" required="false">
				Constant expression used when no record from the group meets the condition in <code>Acceptance Condition</code>
				and than no best record can be selected.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.bob.AttributeSetCfg">
    <properties>
			<property name="acceptanceCondition" type="string" required="false">
				Condition for selecting records used for generating representative attributes.
				<br/>Default value: <code>true</code>.
			</property>
			<property name="instanceAttributes" type="com.ataccama.dqc.tasks.identify.bob.AttributeCfgInst[]" required="false">
				Set of definitions of attributes stored in the original record.
				<br/>Note: at least one member of <code>Instance Attributes</code> or <code>Representative Attributes</code> must be present.
			</property>
			<property name="representativeAttributes" type="com.ataccama.dqc.tasks.identify.bob.AttributeCfgRepr[]" required="false">
				Set of definitions of attributes stored in the representative record.
				<br/>Note: at least one member of <code>Instance Attributes</code> or <code>Representative Attributes</code> must be present.
			</property>
			<property name="selectionRules" type="com.ataccama.dqc.tasks.identify.bob.AggregatingOrderBy[]" required="false">
				Set of components that define sorting and record comparing.
				If empty, no sorting or selecting is performed.
				<br/>It is possible to use aggregating functions in property <code>Expression</code>.
				The aggregation is related to the particular record group from which the representant is created.
				<br/>Also the function <code>frequency(value)</code> can be used. It returns the number of occurences 
				of a given value in the group, so it is possible, for example, to give priority to records 
				with the most frequent value. <br/>Function returns 0 for argument <code>null</code>.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.server.services.AuthenticationService">
    <introduction>Protects invoking of services by using a username and password and enriches the request with the identity of the request originator.</introduction>
    <description>
			<p align="justify">
				Protects invoking of services by using a username and password and enriches the request with the identity of the request originator.
			</p>
			<p align="justify">
				The component may be used for internal communication requests as well as for requests going to the web service port. In	the second case you have to use RequiredRoleFiler in the <strong>Http Dispatcher</strong>. You can define several different authentication methods. When resolving identity, all defined methods are asked one by one until one of them returns some identity. Therefore, it is important to put the methods in correct order.
			</p>
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="methods" type="com.ataccama.dqc.communication.auth.server.IServerAuthenticationMethod[]" required="false">Definition of the authentication method.</property>
			<property name="roleMappingProvider" type="com.ataccama.dqc.communication.auth.server.IRoleMappingProvider" required="false">Assigns roles based on the roles resolved by the authentication method and requester&#39;s IP address.</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.streaming.io.reader.IKafkaInputFormat" name="com.ataccama.dqc.streaming.io.reader.AvroFileInputFormat">
    <description>
			Input format which expects that a message in Kafka topic is an Avro file. Each message has to contain schema metadata. Output is a string with a JSON structure of the message.
		</description>
    <properties>
			<property name="column" type="string" required="true">
				Output column name.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.streaming.io.writer.IKafkaOutputFormat" name="com.ataccama.dqc.streaming.io.writer.AvroFileOutputFormat">
    <description>
			Each message is constructed as one Avro file, i.e. a binary data file that contains the schema of record followed by the record&#39;s data.
		</description>
    <properties>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
				A list of columns written into the message.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				All input columns have to be written.
			</property>
			<property name="recordName" type="string" required="false">
				Optional record name. Default = &quot;record&quot;.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.avro.reader.AvroReader">
    <introduction>
            Reads data from an Avro file and puts it into one or more output endpoints.
        </introduction>
    <description>
        The step can create several output streams from one Avro file where rows of one stream can be
		logically children to rows in another stream. Eg. if a file contains client records
		with each client having several addresses, it can be read as a stream of clients
		and a separate stream of addresses of all clients.
		The streams can also be independent.
        </description>
    <properties>
            <property name="fileName" type="string" required="true">
            The source Avro file.
            </property>
            <property name="dataStreams" type="com.ataccama.dqc.tasks.hadoop.io.avro.reader.AvroReaderStream[]" required="true">
               Output endpoints defined on the root level.
            </property>
            <property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
			General parameters for data formatting. This configuration is applied to
			all specified columns unless the column defines its own
			<code>dataFormaParameters</code> section.
			For more information, see <strong>
					  DataFormatParameters</strong>
			</property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.avro.reader.AvroReaderStream">
    <description>
			Defines a single output endpoint where the source of rows are elements returned by
			the <code>Path</code> property.
		</description>
    <properties>
		 	<property name="name" type="string" required="true">
		 	Name of the output endpoint.
		 	</property>
		 	<property name="path" type="string" required="true">
		 	This is the Avro path that selects elements into this stream and creates one row from each element. The Avro path
		 	is a sequence of tokens separated by slash (eg. root/rows/row). Note that the path is never absolute
		 	(even with leading slash), it is always relative to the parent configuration element (the corresponding
		 	stream for attributes, parent stream for streams).
		 	Each token can be one of following:
		 	<ul>
		 		<li>
		 		Full name of the element. Used for named element types: record, enum, fixed. Always has to
		 		be entered with the namespace of the element, if any. Example: <code>org.avro.Address</code>
		 		</li>
		 		<li>
		 		Name of the element inherited from parent element. This is the case where record <code>name.space.A</code> has a field named <code>B</code>,
		 		which stores named element <code>name.space.C</code>. Then both <code>name.space.A/B</code> and
		 		<code>name.space.A/name.space.C</code> (the previous option for token) are valid determinants for the mentioned element.
		 		</li>
		 		<li>
		 		Name of the type of the element. This is most useful for unions - its sub-elements may not have any name at all, but in that case
		 		they will differ in type. The type can be any of the Avro data type:
		 		<code>null</code>,<code>boolean</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>double</code>,<code>bytes</code>,
		 		<code>string</code>,<code>record</code>,<code>enum</code>,<code>array</code>,<code>map</code> and <code>fixed</code>.
		 		Example: <code>name.space.Parent/string</code>
		 		</li>
		 	</ul>
		 	</property>
			<property name="dataStreams" type="com.ataccama.dqc.tasks.hadoop.io.avro.reader.AvroReaderStream[]" required="false">
			Child output endpoints.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of additional columns that are not extracted from the Avro data and
				are added to the record format to the columns defined by <code>Attributes</code> property.
				All parent streams&#39; columns are accessible in the expressions defining their value, under dot-sources of the
				streams&#39; respective names.
			</property>
			<property name="attributes" type="com.ataccama.dqc.tasks.hadoop.io.avro.reader.FieldColumn[]" required="true">
			Columns for this end point.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.streaming.io.reader.IKafkaInputFormat" name="com.ataccama.dqc.streaming.io.reader.AvroRecordInputFormat">
    <description>
			Input format which expects that a message in Kafka topic has an Avro format but does not contain schema metadata. Schema must be provided by the user with the help of a schema file. Output is a string with a JSON structure of the message.
		</description>
    <properties>
			<property name="column" type="string" required="true">
				Output column name.
			</property>
			<property name="schemaFile" type="string" required="true">
				Path to a file with Avro schema. Schema must be valid according to the <a href="https://avro.apache.org/docs/1.7.7/spec.html#schemas" target="_blank">schema definition</a>.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.streaming.io.writer.IKafkaOutputFormat" name="com.ataccama.dqc.streaming.io.writer.AvroRecordOutputFormat">
    <description>
			Each Message is constructed as one Avro message, i.e. an Avro record (in binary format) without a schema specification. The schema of each record is written as a JSON into an external file. 
		</description>
    <properties>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
				A list of columns written into the message.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				All input columns have to be written.
			</property>
			<property name="recordName" type="string" required="false">
				Optional record name. Default = &quot;record&quot;.
			</property>
			<property name="schemaFileName" type="string" required="false">
				Name of the resource (file), which is used to store the actual schema of records.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.streaming.io.reader.IKafkaInputFormat" name="com.ataccama.dqc.streaming.io.reader.AvroSchemaRegistryInputFormat">
    <description>
			Input format which expects that a message in Kafka topic is an Avro record with Avro schema stored in a Schema registry. Output is a string value in the JSON format with the same structure as the consumed Avro record.
			<p align="justify">
        <strong>Note:</strong> The Kafka Reader step sets <monospace>value.deserializer</monospace> and <monospace>value.serializer</monospace> properties to <monospace>ByteArraySerializer</monospace> when schema registry is used. Overriding these properties will break the step.</p>
		</description>
    <properties>
			<property name="column" type="string" required="true">
				Output column name.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.streaming.io.writer.IKafkaOutputFormat" name="com.ataccama.dqc.streaming.io.writer.AvroSchemaRegistryOutputFormat">
    <description>
			<p align="justify">Each Message is constructed as one Avro message, i.e. an Avro record (in binary format). The schema of each record is written directly into the specified schema registry.</p>
			<p align="justify">
        <strong>Note:</strong> The Kafka Writer step sets <monospace>value.deserializer</monospace> and <monospace>value.serializer</monospace> properties to <monospace>ByteArraySerializer</monospace> when schema registry is used. Overriding these properties will break the step.</p>
		</description>
    <properties>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
				A list of columns written into the message.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				All input columns have to be written.
			</property>
			<property name="schemaName" type="string" required="true">
					Name of the schema into which the schema of each Avro record will be written.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.avro.writer.AvroWriter">
    <introduction>Writes data to an Avro file.</introduction>
    <description>Writes data to a standard .avro file, including the schema and the actual data in the binary format.</description>
    <properties>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">Definition of columns to be written to the Avro file.</property>
			<property name="fileName" type="string" required="true">Path to the .avro file where the data should be written.</property>
			<property name="recordName" type="string" required="true">Name of the Avro document.</property>
			<property name="writeAllColumns" type="boolean" required="true">Specifies whether to write all columns as defined in the input format. If this value is set to true, there must be no columns defined in the Columns element.</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.BasicAnalysis">
    <introduction>The Basic analysis provides simple statistics about the data that has been profiled and shows a chart of duplicate and distinct data as a percentage of the whole.</introduction>
    <properties/>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.ILdapAttribute" name="com.ataccama.dqc.communication.auth.server.BasicAttribibuteResolver">
    <introduction>Reads the authenticated user&#39;s <strong>Ldap Attribute</strong> and stores the value as user parameter named as specified in the <strong>Name</strong> property. The value is later accessible using the getParameterValue(key) function. The key is composed of the prefix <code>security.user.</code> and the attribute name defined in the <strong>Name</strong> property.</introduction>
    <description>Reads the authenticated user&#39;s <strong>Ldap Attribute</strong> and stores the value as user parameter named as specified in the <strong>Name</strong> property. The value is later accessible using the getParameterValue(key) function. The key is composed of the prefix <code>security.user.</code> and the attribute name defined in the <strong>Name</strong> property.</description>
    <properties>
			<property name="ldapAttribute" type="string" required="false"> </property>
			<property name="name" type="string" required="false"> </property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.multi.IRandomRecordCountGeneratorConfig" name="com.ataccama.dqc.tasks.generator.multi.BindingRecordCountGenerator">
    <description>
			Number of child records is read from Record Count column in parent record.
		</description>
    <properties>
			<property name="column" type="string" required="true">
				Name of column (of type INTEGER) where is number of child records to generate for this parent record.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ISearchMethodDefinition" name="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.BoundaryAwareMethod">
    <introduction>
    		Modified Aho-Corasick search method so that it is aware of word boundaries.
    	</introduction>
    <description>
    		This method in fact is a configurable version of <strong>AhoCorasickMethod</strong>.
    	</description>
    <properties>
      		<property name="requireBeginBoundary" type="boolean" required="true">
      			Requires that the value start at the word boundary.
      			Default value: True.
      		</property>
    		<property name="requireEndBoundary" type="boolean" required="true">
    			Requires that the value end at the word boundary.
    			Default value: True.
    		</property>
    	<property name="inputComponents" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference[]" required="true">
		      List of input components to be searched for.
		  </property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.Buffer">
    <introduction>Sends data through buffer, breaks producer-consumer performance dependency in data flow.</introduction>
    <description>
			The step continuously writes input data into buffer and reads and sends them
			to output. Both writing and reading are independent, so performance of steps
			after this one doesn&#39;t affect performance and processor utilization in prior steps.
			<br/>
			It brings advantage in multiprocessor environment with enabled parallelism - place
			Buffer after high speed, cpu consuming and parallelized steps (filters) and before heavy loading step that cannot
			be parallelized (writers, builders, ...)
		</description>
    <properties>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.BusinessRule">
    <introduction>
		Defines a predicate (boolean expression) whose accuracy is analyzed.
		Result of this analysis is the number of records that satisfy the rule, don&#39;t satisfy the rule and are
		indeterminable (expression gives <code>null</code> as a result).
		</introduction>
    <properties>
			<property name="name" type="string" required="false">
			Descriptive name of this analysis.
			</property>
			<property name="expression" type="string" required="true">
			Boolean expression tested.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.dqi.CIIStep">
    <introduction>Computes several scores for each input row and then  
		creates a final report.</introduction>
    <description>
		This step has metrics which are each computed for each input row
		integer score using four boolean expressions placed on the metric. This score
		is then written to a given column unique for each metric. In the end it creates a report containing:
			<ul>
			<li>
			    number of all rows
			</li>
			<li>
                for each of the four boolean expressions there is a column with the count of positively
                evaluated rows.
			</li>
			</ul>
		</description>
    <properties>
			<property name="metrics" type="com.ataccama.dqc.tasks.experimental.dqi.Metric[]" required="true">
				An array of metrics.
			</property>
			<property name="defaultCIIScore" type="string" required="true">
			It computes for each row and for each metric an integer score value based on
			the four expressions in the <strong>metric</strong>.
			The score is then stored to the column named in the <code>scoreColumn</code> property
			in the <strong>metric</strong>.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="reportColumns" type="com.ataccama.dqc.tasks.experimental.dqi.ReportedColumn[]" required="false">
			Input columns which are copied to the rows inserted to the report end point.
			</property>
		<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfCopyFileOperation">
    <introduction>Copies source file/folder to the destination folder.</introduction>
    <description>Copies source file/folder to the destination folder. The copy operation automatically preserves target files timestamps.</description>
    <properties>
			<property name="overwriteFlag" type="boolean" required="true">Permission to overwrite files in the destination folder. The task fails when <strong>Overwrite Flag</strong> is false and some of the target files/folders already exist.</property>
			<property name="recursiveFlag" type="boolean" required="true">Permission to copy sub-directories.</property>
			<property name="keepDirTreeFlag" type="boolean" required="true">Permission to copy the source file system hierarchy. Applicable only in case the <strong>Source File</strong> contains wildcards on multiple path levels (e.g., <code>/dir*/*.csv</code>), otherwise the <strong>Keep Dir Tree Flag</strong> is ignored.
			<p align="justify">If true (false), the source file hierarchy is preserved starting from the highest (lowest) level of the <strong>Source File</strong> path containing a wildcard.</p>
			<p align="justify">For example, if you move files from the <code>in</code> to the <code>out</code> folder with the <strong>Source File</strong> value <code>in/dir*/*.csv</code>, the target file hierarchy will have the following structure based on the <strong>Keep Dir Tree Flag</strong> value:</p>
				<ul>
					<li>
            <code>out/dir&lt;value&gt;/&lt;file_name&gt;.csv</code> if the flag is true</li>
					<li>
            <code>out/&lt;file_name&gt;.csv</code> if the flag is false</li>
				</ul>
			<p align="justify">Note: Make sure to appropriately set the <strong>Keep Dir Tree Flag</strong> and <strong>Overwrite Flag</strong>. If both flags are false and multiple files with the same name match the <strong>Source File</strong> mask, the task attempts to copy all matched files to the same destination folder and fails.</p>
			</property>
			<property name="sourceFile" type="string" required="true">Path to the source mask on files/folders. The task fails when no file/directory is found to mask.
			<p align="justify">Supports wildcards.</p>
		</property>
			<property name="targetFile" type="string" required="true">Path to the destination folder or file:
				<ul>
					<li>Folder – file after copy observes the name; the folder must exist, otherwise the task fails.</li>
					<li>File – parent folder of target file must exist, otherwise the task fails.</li>
				</ul>
				<p align="justify">Note: Make sure to appropriately set the <strong>Keep Dir Tree Flag</strong> and <strong>Overwrite Flag</strong>. If both flags are false and multiple files with the same name match the <strong>Source File</strong> mask, the task attempts to copy all matched files to the same destination folder and fails.</p>
			</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.match.CanopyClustering">
    <introduction>Groups records into clusters based on Jaccard distance over tokens.</introduction>
    <description>
			The algorithm takes input values defined in <code>Components</code> 
			and calculates distances to selected centroid record. These distances are averaged and 
			based on the loose and tight thresholds the record is possibly assigned to the cluster 
			defined by the centroid record.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="components" type="com.ataccama.dqc.tasks.match.Component[]" required="false">
				Definition of tokens.
			</property>
			<property name="sortOrder" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Definition of sorting input records. It determines order in which centroid records
				are selected.
			</property>
			<property name="locale" type="string" required="false">
				Default locale for sorting.
			</property>
			<property name="type" type="com.ataccama.dqc.tasks.match.Type" required="true">
				Type of the output.
			</property>
			<property name="minimalIndex" type="double" required="false">
				Minimum value of averaged distance. Values below this limit prevent records be assigned
				to a cluster.
			</property>
			<property name="looseThreshold" type="double" required="false">
				Minimum distance value for the record to become part of the cluster.
			</property>
			<property name="tightThreshold" type="double" required="false">
				Minimum distance value for the record to become part of the cluster and stop its 
				further processing.
			</property>
			<property name="clusterIdColumn" type="string" required="false">
				Column name where to store cluster if of the record. Record can be member of more that
				one cluster.
			</property>
			<property name="clusterRoleColumn" type="string" required="false">
				Column name where to store role of the record in its respective cluster.
				The possible roles are: &quot;C&quot; for centroid record, &quot;I&quot; for record whose distance to centroid
				is equal to 1.0, &quot;T&quot; for record whose distance is greater or equal to tight threshold
				and &quot;L&quot; for record whose distance is between loose and tight threshold.
			</property>
			<property name="averageIndex" type="string" required="false">
				Column name where to store weighted average distance.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Column name where to store record descriptor.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.cassandra.read.CassandraReaderAlgorithm">
    <introduction>Reading data from <a href="http://cassandra.apache.org/" target="_blank">Cassandra</a> database.</introduction>
    <description>
			<p align="justify">This step is implemented only as MapReduce step running on Hadoop. Local run is not supported.</p>
			<p align="justify">It is impossible to run this step from GUI. You must run plan from command line with &quot;guava-18.0.jar&quot; added to Hadoop distributed cache.</p>
			<p align="justify">Tested on Cassandra v2.2.4.</p>
			<p align="justify">It enable user to read data from Cassandra&#39;s keyspace and column family.</p>
		</description>
    <properties>
			<property name="keyspace" type="string" required="true">
				Cassandra&#39;s keyspace
			</property>
			<property name="columnFamily" type="string" required="true">
				Cassandra&#39;s keyspace
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.hadoop.io.cassandra.read.CassandraColumnMapping" required="true">
                Definition of columns (corresponding by order, names and types).
            </property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.cassandra.write.CassandraWriterAlgorithm">
    <introduction>Writing data to <a href="http://cassandra.apache.org/" target="_blank">Cassandra</a> database.</introduction>
    <description>
			<p align="justify">This step is implemented only as MapReduce step running on Hadoop. Local run is not supported.</p>
			<p align="justify">It is impossible to run this step from GUI. You must run plan from command line with &quot;guava-18.0.jar&quot; added to Hadoop distributed cache.</p>
			<p align="justify">Tested on Cassandra v2.2.4.</p>
			<p align="justify">It enable user to write data into Cassandra&#39;s keyspace and column family.</p>
		</description>
    <properties>
			<property name="keyspace" type="string" required="true">
				Cassandra&#39;s keyspace
			</property>
			<property name="columnFamily" type="string" required="true">
				Cassandra&#39;s keyspace
			</property>
			<property name="columnMappings" type="com.ataccama.dqc.tasks.hadoop.io.cassandra.read.CassandraExpressionMapping" required="true">
                Definition of columns (corresponding by order, names and types).
            </property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.catalogItems.CatalogItemColumn">
    <description>Columns from catalog item data structure that Catalog Item Reader step is reading.</description>
    <properties>
			<property name="name" type="string" required="true">Specifies the name of the column to be written to the output.</property>
			<property name="src" type="string" required="false">Column name from catalog item data structure.</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Date type of the specific column.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.catalogItems.CatalogItemReader">
    <introduction>This step allows the user to read data from catalog items (e.g. tables, files) defined in <strong>ONE Web Application</strong> when Remote Execution is used.</introduction>
    <description>
      <strong>Note:</strong> Please note that this step only works when executed using Remote Execution. Step will not read any data when only Local Execution is used.</description>
    <properties>
			<property name="catalogItem" type="string" required="true">You will be provided with a <strong>Select Catalog Item</strong> dialog where you choose catalog item (Catalog item names are listed here.) Once you choose the one catalog item identification of that catalog item will be stored in this property.</property>
			<property name="columns" type="com.ataccama.dqc.tasks.catalogItems.CatalogItemColumn[]" required="true">Definition of columns which will be read from the catalog item.</property>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="serverName" type="string" required="true">Connection details for connecting the ONE 2.0 Metadata Server. (<strong>File Explorer</strong> &gt; <strong>Servers</strong>)</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result of <strong>Default Expression</strong>.</property>
			<property name="workflowState" type="string" required="false">State of the catalog item that <strong>Catalog Item Reader</strong> step will read.<br/>
			<ul>
			<li>
            <code>draft</code>: the latest version available.</li>
			<li>
            <code>published</code>: the latest approved version available.</li>
			</ul>
			</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.text.CharacterGroup">
    <properties>
			<property name="characters" type="string" required="true">
				Definition of characters that belong to a particular character group.
				See <strong>character set definition syntax</strong>.
			</property>
			<property name="repeatedSymbol" type="string" required="false">
				A single character or a sequence of characters of a character group,
				within the input with a count defined by the <code>Repeated Threshold</code> property.
			</property>
			<property name="repeatedThreshold" type="integer" required="false">
				Defines the minimum length of a sequence of characters of an input character group
				that is classified with a character (or a string) defined by the <code>Repeated Symbol</code>
				property instead of the <code>Symbol</code> property.
			</property>
			<property name="symbol" type="string" required="true">
				String or character that classifies characters belonging to the character group in the
				output.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.text.CharacterGroupsAnalyzer">
    <introduction>Profiles groups of characters from an input string.</introduction>
    <description>
      <p align="justify">This step serves as a profiler of input characters. It classifies each character against another character (or a string) according to a character group that the original character belongs to.</p>
			<p align="justify">It is possible to define whether a single character or a sequence of characters belonging to a single group are classified with a single character or string.</p>
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="analyzedColumns" type="com.ataccama.dqc.tasks.text.CharacterGroupsAnalyzer$AnalyzedColumn[]" required="false">
				List of columns to analyze.
			</property>
			<property name="defaultCharacterGroups" type="com.ataccama.dqc.tasks.common.text.CharacterGroup[]" required="false">
				List of default defined character groups. These groups are used for
				analyzed columns which do not have their own character group definition.
			</property>
			<property name="copyUnknownCharacters" type="boolean" required="true">
				Specifies if characters, that do not belong to any character group specified, should be copied (<code>true</code>) or skipped in the output column.
				Value is used for analyzed columns which do not have their own character group definition.
				<br/>Default: <code>true</code>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.CheckPoint">
    <introduction>Waits for all records from the input before sending them further in the data flow.</introduction>
    <description>
			This step reads ALL records from the input and then starts writing
			them to the output. This means that steps following this point will start their work
			only when all preceding steps have finished.
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="folder" type="string" required="false">
				Folder used for the temporary file.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.stream.ChildJsonStreamConfig">
    <description>
			A single stream of data with one output.
			Note: The child stream has <code>Min One Record</code> enabled by default.
		</description>
    <properties>
      <property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="name" type="string" required="true">
				The name of this stream and its associated output.
			</property>
      <property name="path" type="string" required="true">
				The JSON path to the elements that are to be read by this stream. If this is a substream of another stream, then
				the path is relative to the path of the parent stream. Path containing dot character (&quot;.&quot;) must be surrounded with
				quotation marks (e.g.: &quot;sub.stream&quot;). You can also use <code>@</code> in the <strong>Path</strong> attribute to handle JSON arrays. Including <code>$.@</code> for a top level array. 
			</property>
      <property name="parentIdColumn" type="string" required="false">
				Expression evaluating unique id of the superior record. The id is used as a part of <code>Record Descriptor</code>
				assigned to group of records generated by this output and belonging to that parent record. Name of the parent output is used
				as a dot-source name referring to parent record columns. Records from top level data stream are referenced as in.column_name.
				Useless at the top level output of Json Reader step.
			</property>
      <property name="recordDescriptor" type="string" required="false">
				Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
				only when <code>Parent Id Column</code> is defined.
			</property>
      <property name="minOneRecord" type="boolean" required="false">
				Guarantees at least one record in the output data stream. If no record is found in the response, it returns an empty record scored WLA_NOT_FOUND.
			</property>
      <property name="maxOneRecord" type="boolean" required="false">
				Allows at most one record in the output data stream. If multiple records are found in the response, it returns an empty record scored WLA_MULTIPLE.
			</property>
      <property name="dataStreams" type="com.ataccama.dqc.tasks.io.json.stream.ChildJsonStreamConfig[]" required="false">
				The substreams of this stream. They will produce records that are logically children of the records of this parent stream.
			</property>
      <property name="attributes" type="com.ataccama.dqc.tasks.io.json.stream.Attribute[]" required="true">
				The attributes of this stream - columns of the associated output mapped to JSON fields.
			</property>
      <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
      <property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Data formats for parsing string JSON fields into DQC data types. Overrides the data format parameters defined on any
				parent object. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
    </properties>
    <scoring>
			<scoringKey name="WLA_NOT_FOUND">
				Indicates no record in the response when <code>Min One Record</code> is enabled.
			</scoringKey>
			<scoringKey name="WLA_MULTIPLE">
				Indicates multiple records in the response when <code>Max One Record</code> is enabled.
			</scoringKey>
			<scoringKey name="WLA_PARENT">
				Indicates that the parent data stream failed and this record was generated based on <code>Min One Record</code> policy.
			</scoringKey>
		</scoring>
  </class>
  <class super="com.ataccama.dqc.tasks.io.gdr.reader.member.StructuredMemberBase" name="com.ataccama.dqc.tasks.io.gdr.reader.member.Choice">
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.io.gdr.reader.member.StructuredMemberBase" name="com.ataccama.dqc.tasks.io.gdr.reader.member.ChoiceEntry">
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod" name="com.ataccama.dqc.tasks.identify.grouping.ClassicHierarchical">
    <introduction>
        	Unification method where candidate groups are based on one primary group and appended records not belonging to primary group but to common secondary group.
        	Primary group contains records with that same primaryGroupId, whereas secondary group contains records with the same secondaryGroupId.
        	The processing is the same as for <strong>Hierarchical</strong> but the
        	configuration follows the most common use as joining groups from the previous primary and secondary unification.
			Records not belonging to primary group are records having primary unification role <code>N</code> or possibly <code>R</code>,
			depending on switch <code>Consider Role R As Well</code>. 
        </introduction>
    <properties>
	        <property name="considerRoleRAsWell" type="boolean" required="true">
	        	When specified, records with the unification role <code>R</code> will
	        	be assumed as regular primary group. When false, these records may be appended
				to some primary group like records with role <code>N</code>.
	        	<br/>Default value: true.
	        </property>
	        <property name="primaryGroupIdColumn" type="string" required="true">
	        	Column containing id of the primary group.
	        </property>
	        <property name="primaryGroupRoleColumn" type="string" required="true">
	        	Column containing record unification role in the primary group.
	        </property>
	        <property name="secondaryGroupIdColumn" type="string" required="true">
	        	Column containing id of the secondary group.
	        </property>
	        <property name="secondaryGroupRoleColumn" type="string" required="true">
	        	Column containing record unification role in the secondary group.
	        </property>
    	<property name="when" type="string" required="false">
				Boolean condition for using the current grouping method.<br/>
				Default value: true.
			</property>
      <property name="pivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting the &quot;Pivot record&quot; from a set of candidates.
				A matching group is constituted of one pivot record and candidates which
				are near to the pivot record, i.e. which satisfy one of the matching rules.
			</property>
      <property name="maxIterations" type="integer" required="false">
				Maximum number of iterations of the matching group assigning process. Consequently,
				it is maximum number of matching groups in one candidate group.
			</property>
      <property name="mergeSurvivorSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting one &quot;Merge survivor record&quot;, which must be
				assigned for each newly created group (candidate or matching). This
				criterion is used when more than one prior MSR records occurs in group.
				<br/>Ignored when <code>Use Pivot As Survivor</code> is specified.
			</property>
      <property name="matchingRules" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Set of rules used for determining when a candidate record is near the pivot record
				and belongs to its matching group.
				<br/>Note: two records named &quot;pivot&quot; and &quot;candidate&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
      <property name="matchNearest" type="boolean" required="true">
				If specified, candidate will be assigned to matched group with minimal value of <code>Match Quality Expression</code>.
				If not specified, candidate will be assigned to matched group with the best pivot (default behavior). 
			</property>
      <property name="matchQualityExpression" type="string" required="false">
				Numeric (integer, long or float) expression that can be used to evaluate match quality of candidate record with it&#39;s pivot record.
				<br/>Similarly as in <code>Expression</code>
				compared records are referred by two dot-sources <code>pivot</code> and <code>candidate</code>.
				Results of <strong>Matching Measure</strong>
				referred via dot-source <code>measures</code> are accessible, too.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.supervised.classification.LogisticRegressionClassifierConfig">
    <introduction>Predicts a target from previously trained classification model.</introduction>
    <description>
            <p align="justify">
                Based on specified features, this step predicts class based on previously trained model. All features must be the same
                as when training the model. Transformations used in model training are applied automatically before making prediction.
            </p>
            <p align="justify">
                <strong>Note:</strong>
                Transformations are done in memory.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.supervised.columns.ClassifyingFeatureConfig[]" required="true">
                Configuration of features used to predict the target.
            </property>
            <property name="outClassificationColumn" type="string" required="true">
                Column, that is used to output the prediction.
            </property>
            <property name="outProbabilityColumn" type="string" required="false">
                Column, that is used to output probability of the prediction.
            </property>
            <property name="outVectorColumn" type="string" required="false">
                Column, that is used to output the final feature vector created from features after all transformations. This vector is used for prediction.
            </property>
            <property name="modelFile" type="string" required="true">
                File, that contains previously trained model.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.supervised.classification.LogisticRegressionTrainerStepConfig">
    <introduction>Trains classification model.</introduction>
    <description>
            <p align="justify">
                Based on specified features (measurable properties), this step trains classification model (predicting
                categorical variable) and saves trained model to the specified file.
                Each feature can have transformations defined. Order of the features is not important, after all transformations,
                the features are ordered alphabetically.
                We can for example train model to predict flower name based on leaf length and width and size of it&#39;s blossom.
            </p>
            <p align="justify">
                <strong>Note:</strong>
                Everything (transformations and training) is done in memory.
            </p>
        </description>
    <properties>
            <property name="classificationType" type="com.ataccama.dqc.tasks.ai.supervised.classification.LogisticRegressionTrainerConfig" required="true">
                Type of classification model.
            </property>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.supervised.columns.TrainingFeatureConfig[]" required="true">
                Configuration of features used to fit the classification model.
            </property>
            <property name="targetColumn" type="string" required="true">
                Column, that contains target used to fit the classification model.
            </property>
            <property name="outVectorColumn" type="string" required="false">
                Column, that is used to output the final feature vector created from features after all transformations. This vector is used to train the model.
            </property>
            <property name="outputModelFile" type="string" required="true">
                File, that is used to output fitted classification model.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.supervised.columns.ClassifyingFeatureConfig">
    <introduction>Configuration of features used to predict the target.</introduction>
    <description>
            All features must be the same as when training the model. Same transformations used in model training are applied automatically before making
            prediction.
        </description>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must have been used in training step.
            </property>
            <property name="featureColumn" type="com.ataccama.ai.commons.steps.column.FeatureColumn" required="true">
                A way how to parse feature from the column.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.components.addresses.can.CANAddressesGenerated$CleansedEndPoint">
    <properties>
          <property name="stdRecordType" type="string" required="false">
          Defines the <strong>type of record</strong> in the Address Lookup and the Text Lookup files e.g. General Delivery Address.
          </property>
          <property name="stdCivicNumber" type="string" required="false">
          Street number in a range of municipal street addresses
          </property>
          <property name="stdCivicNumberSuffix" type="string" required="false">
          The address suffix associated with the street number. E.g. 14½ and 22B.
          </property>
          <property name="stdStreetName" type="string" required="false">
          The official civic name of a roadway or artery.
          </property>
          <property name="stdStreetDirection" type="string" required="false">
          The <strong>street direction</strong> component of an official street name.
          </property>
          <property name="stdStreetType" type="string" required="false">
          The official description used to identify the type of artery or roadway
          </property>
          <property name="stdSuiteIdentifier" type="string" required="false">
          Suites/units or apartments number/identifier.
          </property>
          <property name="stdDeliveryInstallationName" type="string" required="false">
          The qualifier name uniquely identifies the delivery installation.
          </property>
          <property name="stdDeliveryInstallationType" type="string" required="false">
          The category of <strong>delivery installation</strong>.
          </property>
          <property name="stdMunicipality" type="string" required="false">
          A municipality is any city, town or village in Canada that is recognized as a valid mailing address by Canada Post.
          </property>
          <property name="stdPostalBoxNumber" type="string" required="false">
          Value in a range of lock boxes or lock bags. Note that the number may contain alphanumeric characters.
          </property>
          <property name="stdPostalCode" type="string" required="false">
          A six character, alphanumeric combination (ANA NAN) assigned to one or more postal address. The Postal Code is an integral part of every postal address in Canada and is required for the mechanized processing of mail. Postal codes are also used to identify the various CPC processing facilities, and delivery installations.
          </property>
          <property name="stdProvinceCode" type="string" required="false">
          An alphabetic code listing the province or territory’s position geographically.
          </property>
          <property name="stdRouteServiceNumber" type="string" required="false">
          A number that identifies a Rural Route, Suburban Service or Mobile Route delivery mode.
          </property>
          <property name="stdRouteServiceType" type="string" required="false">
          A code that identifies the <strong>type of route service</strong>.
          </property>
          <property name="stdAdditionalAddressInformation" type="string" required="false">
          Often required for delivery to a rural address that does not have a civic address. In such cases, a SITE and COMP (compartment) is assigned.
          </property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.components.addresses.us.USAddressesGenerated$CleansedEndPoint">
    <properties>
			<property name="cleansedOut_address_type" type="string" required="false">
				Output value of street type
			</property>
			<property name="cleansedStd_city" type="string" required="false">
				Standardized and validated value of city
			</property>
			<property name="cleansedStd_state" type="string" required="false">
				Standardized and validated value of state
			</property>
			<property name="cleansedStd_county" type="string" required="false">
				Standardized and validated value of county
			</property>
			<property name="cleansedStd_zip5" type="string" required="false">
				Standardized and validated value of 5-digit ZIP part
			</property>
			<property name="cleansedStd_zip4" type="string" required="false">
				Standardized and validated value of 4-digit ZIP part
			</property>
			<property name="cleansedStd_sn" type="string" required="false">
				Standardized and validated value of street number
			</property>
			<property name="cleansedStd_street_predirection" type="string" required="false">
				Standardized and validated value of street predirection
			</property>
			<property name="cleansedStd_street_name" type="string" required="false">
				Standardized and validated value of street name
			</property>
			<property name="cleansedStd_street_type" type="string" required="false">
				Standardized and validated value of street type
			</property>
			<property name="cleansedStd_street_postdirection" type="string" required="false">
				Standardized and validated value of street postdirection
			</property>
			<property name="cleansedStd_secondary_unit_designator" type="string" required="false">
				Standardized and validated value of secondary unit designator
			</property>
			<property name="cleansedStd_unit_designator" type="string" required="false">
				Standardized and validated value of unit designator
			</property>
			<property name="cleansedStd_unit" type="string" required="false">
				Standardized and validated value of unit designator number
			</property>
			<property name="cleansedStd_apt" type="string" required="false">
				Standardized and validated value of apartment unit designator
			</property>
			<property name="cleansedStd_apt_num" type="string" required="false">
				Standardized and validated value of apartment number
			</property>
			<property name="cleansedStd_route_type" type="string" required="false">
				Standardized and validated value of route type
			</property>
			<property name="cleansedStd_route_number" type="string" required="false">
				Standardized and validated value of route number
			</property>
			<property name="cleansedStd_route_box" type="string" required="false">
				Standardized and validated value of route box
			</property>
			<property name="cleansedStd_pobox" type="string" required="false">
				Standardized and validated value of PO BOX
			</property>
			<property name="cleansedTmp_additional_info" type="string" required="false">
				Non-validated piece of address not considering during address validation (e.g. building name, department name)
			</property>
		</properties>
  </class>
  <class name="com.ataccama.simplecluster.step.SimpleClusterStep">
    <introduction>Distributes work of part of plan to more computers.
	</introduction>
    <description>See <strong>detailed description</strong>
    </description>
    <properties>
			<property name="configFileName" type="string" required="true">
			File path to the configuration plan file which will be run on the
			execution nodes.
			</property>
			<property name="chunkSize" type="integer" required="true">
			The input will be split by chunk size counted in records. The number
			of records can be slightly bigger if the chunk size is chosen very small (&lt;100).
			</property>
			<property name="group" type="string" required="true">
			Execution nodes can be configured to allow run only listed groups. Only
			nodes with this group can be used to run the plan.
			</property>
			<property name="registry" type="string" required="true">
			Name of the url resource pointing to the registry node.
			</property>
			<property name="compressedChunks" type="boolean" required="true">
			The chunks of records sent to the execution and received back can be 
			compressed.
			</property>
	<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.read.CollibraAssetReaderColumn">
    <description>Properties of Columns section</description>
    <properties>
	<property name="name" type="string" required="true">
	The <strong>name of the column</strong> where the value of a certain Asset Attribute (Characteristic) should be stored.
	</property>
	<property name="collibraAttributeType" type="string" required="true">
	The <strong>name of the Asset Attribute (Characteristic)</strong> which value should be returned.
	</property>
	<property name="type" type="com.ataccama.dqc.tasks.io.collibra.read.CollibraDataType" required="true">
				The data type of a certain column. Each Asset Attribute in Collibra
				is defined by Collibra Resource Type (Characteristic Kind). Only certain Characteristic Kind can be mapped to a specific
				Ataccama Column	Types.<br/>
				The mapping is described below. <br/>
				If the user is not aware of the Characteristic Kind of their data in Collibra, <strong>STRING</strong> may be used for all columns.
			</property>
	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.write.CollibraAssetWriterColumn">
    <description>The configuration properties of Asset Writer Column.</description>
    <properties>
			<property name="attributeType" type="string" required="true">
				Name of the Collibra Attribute Type where the column value should be written to.
			</property>
			<property name="columnName" type="string" required="true">
				Name of the column on the assets input where the value which should be written is stored.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.write.CollibraAssetWriterConfig">
    <description>Properties of section Asset Writer Config</description>
    <properties>
			<property name="assetIdColumn" type="string" required="false">
				Name of the column on the assets input which should contain the Asset ID value which will be used to identify the updated Asset
				in the Collibra.
			</property>
			<property name="assetNameColumn" type="string" required="true">
				Name of the column on the assets input which should contain the Asset Name value. The combination of this and the Domain Name value
				will be used to identify the imported Asset in the case the Asset Id Column is not defined or null.
			</property>
			<property name="assetDisplayNameColumn" type="string" required="false">
				Name of the column on the assets input which should contain the Asset Display Name value.<br/>
				When not specified, the Asset Display Name will be the same as Asset Name.
			</property>
			<property name="assetTypeName" type="string" required="true">
				The Asset Type which is imported. For now each step may always import only Asset of the certain type.
			</property>
			<property name="domainName" type="string" required="false">
				The name of the Domain the Assets should be imported to. The combination of the Community, Domain and Asset names will be used to identify
				the imported Asset in the case the Asset Id Column is not defined or is null.<br/>
				The value will be also used to set the domain where the Assets should be imported.<br/>
				You can leave this empty only if you are updating the Assets with Asset Id identifier.
			</property>
			<property name="communityName" type="string" required="false">
				The name of the Community the Assets should be imported to. The combination of the Community, Domain and Asset names will be used to identify
				the imported Asset in the case the Asset Id Column is not defined or is null.<br/>
				The value will be also used to set the community where the Assets should be imported.<br/>
				In the multi-leveled Community scenario. Always the name of the deepest level Community should be specified.
				You can leave this empty only if you are updating the Assets with Asset Id identifier.
			</property>
			<property name="statusColumn" type="string" required="false">
				Name of the column on the assets input which should contain the name of the Collibra status the Asset should have after import.<br/>
				For now the possible values of the Collibra Workflow are not checked on Ataccama side. Any incorrect status name will make the
				created import job fail.
			</property>
			<property name="assetWriterColumns" type="com.ataccama.dqc.tasks.io.collibra.write.CollibraAssetWriterColumn[]" required="false">
				Definition of input columns containing values of the Asset Attributes.
			</property>
			<property name="multiSelectionDelimiter" type="string" required="false">
				Configuration property relevant only for Assets with Multi Selection Attribute type. If such Attribute is written to the data
				in the input column should be in the form of set of possible values divided by the delimiter defined in this configuration
				property.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.read.CollibraDataType">
    <description>The column type</description>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.read.CollibraReader">
    <introduction>
	The Collibra Reader step allows user to read Assets and theirs Relations from Collibra application.
	</introduction>
    <description>
	<p align="justify">The step was created to read the Asset objects data from Collibra application. It allows the user to specify the Asset Type
	of the Assets which should be returned and further filtering it with <strong>Domain</strong> or <strong>Community name</strong>.
	For each Asset returned by Collibra a record is created in a plan processing.</p>
	<p align="justify">Both meta-information (ID or name) of the Asset as well as its Attributes are returned. The data provided can be mapped to record columns.
	The idea is that in the output the record representing the Asset will have the both the meta-information and Attributes in a specified column.
	The step allows user to map following information:</p>
	<ul>
	<li>
          <strong>Asset ID</strong>
        </li>
	<li>
          <strong>Asset Name</strong>
        </li>
	<li>
          <strong>Asset Type</strong>
        </li>
	<li>
          <strong>Domain Id</strong>
        </li>
	<li>
          <strong>Any Attribute the Asset may have</strong> (defined on its Type)</li>
	</ul>

	<p align="justify">The step also allows you to read the Collibra Relationships information. In that case, the step will automatically
	filter the Relationships and returns just those which are relevant to the returned Assets (The relationship where at least
	one of the returned Asset is either in <strong>Target</strong> or <strong>Source</strong> role).</p>
	<p align="justify">The Relationship data are returned in a separate <strong>relations</strong> Endpoint. The reason is to always provide all the data without any duplicates.</p>
	<p align="justify">For each Relationship the record is created and its data can be mapped to an appropriate columns. The step allows user to map the following Relationship related information.</p>
	<ul>
	<li>Relationship ID</li>
	<li>Id of the Asset which is in <strong>Source</strong> role for returned relationship</li>
	<li>Id of the Asset which is in <strong>Target</strong> role for returned relationship</li>
	</ul>
	</description>
    <properties>
	<property name="urlResource" type="string" required="true">
	The reference of the runtime server resource which contains URL and Collibra credentials. The Generic server resource type
	should be used.
	</property>
	<property name="assetType" type="string" required="true">
	The name of the Type of the Assets which should be returned by the step.
	</property>
	<property name="communityName" type="string" required="false">
	The name of the <strong>Collibra Community</strong>. When specified, only Assets in this <strong>Community</strong> are returned. In the
	multi-leveled Community scenario. Always the name of the deepest level Community should be specified.
	</property>
	<property name="domainName" type="string" required="false">
	The name of the <strong>Collibra Domain</strong>. When specified, only Assets in this Domain are returned.
	</property>
	<property name="assetIdColumn" type="string" required="true">
	This property is in <strong>columns tab</strong>.<br/>
	The <strong>name of the column</strong> where Id of the returned Asset will be stored.
	</property>
	<property name="assetNameColumn" type="string" required="true">
	This property is in <strong>columns tab</strong>.<br/>
	The <strong>name of the column</strong> where the Name of the Asset will be stored.
	</property>
	<property name="assetDisplayNameColumn" type="string" required="true">
	This property is in <strong>columns tab</strong>.<br/>
	The <strong>name of the column</strong> where the Display Name of the Asset will be stored.
	</property>
	<property name="assetTypeColumn" type="string" required="true">
	This property is in <strong>columns tab</strong>.<br/>
	The <strong>name of the column</strong> where the Type name of the Asset will be stored.
	</property>
	<property name="domainIdColumn" type="string" required="true">
	This property is in <strong>columns tab</strong>.<br/>
	The <strong>name of the column</strong> where the <strong>Domain Id</strong> of the Asset will be stored.
	</property>
	<property name="assetStatusColumn" type="string" required="false">
	This property is in <strong>columns tab</strong>.<br/>
	The <strong>name of the column</strong> where the <strong>Status</strong> of the Asset will be stored.
	</property>
	<property name="lastUpdateColumn" type="datetime" required="false">
	This property is in <strong>columns tab</strong>.<br/>
	The <strong>name of the column</strong> where the date and time of a last Asset update will be stored.
	</property>
	<property name="columns" type="com.ataccama.dqc.tasks.io.collibra.read.CollibraAssetReaderColumn[]" required="false">The optional property allowing user to map values from Collibra Asset Attributes (Characteristics) to a certain output columns. </property>
	<property name="relationBinding" type="com.ataccama.dqc.tasks.io.collibra.read.CollibraRelationBinding" required="false">
				The optional property allowing user to return the relationship data for the returned assets.
				If enabled, the user can choose columns to store IDs of related Assets. The data is written to a separate endpoint.
			</property>

	<!--FIX-->
	<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of additional columns that are not extracted from the<br/>
				XML data and are added to the record format to the columns defined by <strong>attributes</strong> property.<br/>
				Default expressions can access parent output end points using their names. They also can access input end point.
			</property>
	<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.read.CollibraRelationBinding">
    <properties>
	<property name="relationId" type="string" required="true">
	The <strong> name of the column</strong> where the value of the Relationship Id should be stored.
	</property>
	<property name="targetId" type="string" required="true">
	The <strong> name of the column</strong> where the value of the Asset Id which is in <source>target role</source> in given relationship
	should be stored.
	</property>
	<property name="sourceId" type="string" required="true">
	The <strong> name of the column</strong> where the value of the Asset Id which is in <strong>source role</strong> in given relationship
	should be stored.
	</property>
	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.write.CollibraRelationWriterConfig">
    <description>Properties of section Relation Writer Config.<br/>

		<strong>As written above this section is for advanced users only.</strong>
		</description>
    <properties>
			<property name="relationTypeId" type="string" required="true">
				Name of the column on the relations input where the ID of the relation type is stored.
			</property>
			<property name="sourceAssetId" type="string" required="false">
				Name of the column on the relations input where the ID of the source Asset should be stored. The value is used to
				identify the source Asset.
			</property>
			<property name="sourceAssetName" type="string" required="false">
				Name of the column on the relations input where the name of the source Asset should be stored. The value in the combination
				with the source Domain Name is used to identify the source Asset if the source Asset Id is null or not defined.
			</property>
			<property name="sourceDomainName" type="string" required="false">
				Name of the column on the relations input where the name of the source Asset Domain should be stored. The value in the combination
				with the Source Asset Name is used to identify the source Asset if the source Asset Id is null or not defined.
			</property>

			<property name="sourceCommunityName" type="string" required="false">
				Name of the column on the relations input where the name of the source Community Name should be stored.
			</property>

			<property name="targetAssetId" type="string" required="false">
				Name of the column on the relations input where the ID of the target Asset should be stored. The value is used to
				identify the target Asset.
			</property>
			<property name="targetAssetName" type="string" required="false">
				Name of the column on the relations input where the name of the target Asset should be stored. The value in the combination
				with the target Domain Name is used to identify the target Asset if the target Asset Id is null or not defined.
			</property>
			<property name="targetDomainName" type="string" required="false">
				Name of the column on the relations input where the name of the target Asset Domain should be stored. The value in the combination
				with the Source Asset Name is used to identify the target Asset if the target Asset Id is null or not defined.
			</property>
			<property name="targetCommunityName" type="string" required="false">
				The name of the Collibra Community. When specified, only Assets in this Community are returned. In the
				multi-leveled Community scenario. Always the name of the deepest level Community should be specified.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.write.CollibraWriter">
    <introduction>
The Collibra Writer step allows user to import or update Assets or Relations to Collibra application.
</introduction>
    <description>
	<p align="justify">The step specifically designed to allow user to import or update Assets, Attributes and Relations in Collibra. Step is utilizing Collibra Import API
	creating Collibra import job based on the data on its input. For more information about Collibra Import API visit this
			<a href="https://community.collibra.com/docs/admin/5.5/Content/API/ImportAPIv2/co_import-api-v2.htm" target="_blank">documentation article</a>.
	</p>

	 <p align="justify">The step can work in three modes.</p>

		<strong>Assets only:</strong>
		<p align="justify">In this mode the step is importing just Assets and its Attributes. Each row in DQC processing is considered an Asset which
	should be imported to Collibra. Each row has to contain all the important information for Asset to be imported in its columns.</p>
	<p align="justify">In order for record to be imported to Collibra it has to contain information necessary to identify the imported Asset.
	The information necessary to identify the Asset might be:
		<ul>
		<li>The Id of the Asset</li>
		<li>The combination of the Asset Name and Domain Name</li>
		</ul>
	</p>
	<p align="justify">If both of these conditions are not satisfied, the record will be rejected and sent to the rejectedAsset endpoint.</p>

	<p align="justify">For every batch of 1000 not-rejected records one import job is created and sent to Collibra. Each Collibra import job created this way is tracked
	by the step and once finished the notification is logged containing the original message from Collibra describing the status of the job.</p>
	<p align="justify">
        <strong>The step can create multiple import jobs at the same time (per 1000 records processed). The issue is that Collibra has hard limit
	for number of running import jobs in parallel which is 4. It is important to have this in mind and reducing the parallelism and not starting multiple
	Collibra Writer Steps in the same plan.
	</strong>
	</p>

	<strong>Relations only: </strong>
      <p align="justify">
	In this mode the step is importing just Relations attempting to add or update Relations in Collibra based on the input data. Each row in DQC processing
	is considered a Relation which should be imported. In this mode the both source and target Asset is identified in the same way as while importing Assets.
	However, the step is not checking any data consistency in the input. Also importing Relations requires a knowledge of Relation type Id from Collibra in
	order to work. Therefore using the step to import relations is considered advanced.</p>

	<p align="justify">The processing works the same as for the Assets mode and possible parallelism should be reduced.</p>

	<strong>Mixed mode:</strong>
      <p align="justify"> In this mode one step can write both Assets and Relations. If this is the case, it will always first update
	the Assets and only after that the Relations.</p>
	</description>
    <properties>
<property name="urlResource" type="string" required="true">
	The reference of the runtime server resource which contains URL and Collibra credentials. The Generic server resource type
	should be used.
	</property>
	<property name="assetWriterConfig" type="com.ataccama.dqc.tasks.io.collibra.write.CollibraAssetWriterConfig" required="false">
				Configuration property which allows user to configure step to accept Asset related data and import it to Collibra.
			</property>
			<property name="relationWriterConfig" type="com.ataccama.dqc.tasks.io.collibra.write.CollibraRelationWriterConfig" required="false">
				Configuration property which allows user to configure step to accept Relations related data and import it to Collibra.
				<strong>Note:</strong>
        <br/>
				Due to the complexity of Relations in Collibra this part is for advanced usage only. It is recommended
				to use Collibra to create relations between Assets if it is possible.
			</property>
			<property name="importBatchSize" type="integer" required="true">Maximal size of imported batch</property>
			<property name="parallelism" type="integer" required="true">Parallelism</property>
			<property name="errorHandler" type="com.ataccama.dqc.tasks.io.collibra.write.CollibraWriterErrorHandler" required="false">
				Specify how to treat errors reported by collibra import jobs.
			</property>
			<property name="importBatchSize" type="integer" required="true">
				Maximum size in records of one import job. Default = 1000.
			</property>
			<property name="importJobParameters" type="com.ataccama.dqc.tasks.io.collibra.write.CollibraWriter.ImportParameter[]" required="false">
				Allows to set some parameters for import job API call.
				See <a href="https://developer.collibra.com/api/rest/import#/operations/importJsonInJob#request-body" target="_blank">documentation</a>.
				The parameters are: sendNotification, deleteFile, simulation, continueOnError, relationsAction
			</property>
	<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.write.CollibraWriterErrorHandler">
    <properties>
			<property name="errorAction" type="com.ataccama.dqc.tasks.io.collibra.write.CollibraWriterErrorHandler$ErrorAction" required="true">
			</property>
			<property name="jobIdFieldName" type="string" required="false">
				Output column added to rejected records indicating id of failed job.
			</property>
			<property name="errorFieldName" type="string" required="false">
				Output column added to rejected records containing failed job error message.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.html.Column">
    <properties>
			<property name="xpathExpression" type="string" required="true">
				The downloaded
				page is transformed into clean XHTML. And this structure
				can be
				searched using XPATH. Example: &quot;/html/body/table/tr[1]&quot;.
			</property>
			<property name="columnName" type="string" required="true">
				Column name
				into which the extracted text is stored.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="WLA_XPATH_ERROR">
				Some error happened when applying XPATH.
			</scoringKey>
			<scoringKey name="WLA_EMPTY_VALUE_FOUND">
				No value found in the document when XPATH was used.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.common.column.ColumnAssign">
    <properties>
			<property name="name" type="string" required="true">
				Output column name.
			</property>
			<property name="expression" type="string" required="true">
				The expression assigned to the output column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.expressions.ColumnAssigner">
    <introduction>Assigns the result of an expression to a column.</introduction>
    <description>
			This step assigns the result of a defined expression to a specified column.
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="assignments" type="com.ataccama.dqc.tasks.expressions.Assignment[]" required="false">
				Tag associating individual assignments with defined expressions.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.column.ColumnDef">
    <description>
			This element is used by steps to define a new column of a specific type in the
			output format. The created column contains no data (as no data were associated with it) and
			is not recognizable from real input data columns in terms of further processing.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Assigned column name.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
				Data type of created column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.merge.ColumnDefinition">
    <properties>
			<property name="expression" type="string" required="true">
				String that contains the expression which is evaluated for input data.
				Column specification in the expressions is made by dot notation.
			</property>
			<property name="name" type="string" required="true">
				String that specifies the name of the output column.
				Names must be unique within the output or the step reports an error and ends.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="false">
				Column type which, if filled, determines the type of data created in the <code>Expression</code>.
			    If there is a conflict between the requested and evaluated return type during compilation,
				then the step reports an error and ends.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.column.ColumnExprDef">
    <description>
			This element defines a new column that this step writes to.
			The value is provided by the expression or, when an expression is not specified, by the column value from the 
			source format. The data type of the new column is determined from the expression/source column type.
			If the data type is indeterminable (a null literal expression), the string type is used.
		</description>
    <properties>
			<property name="expression" type="string" required="false">
				If set, it specifies the expression to execute in order to get the value that will be written
				to the column. If no expression is defined,
				the value corresponding to the value of the input column with the same name as the
				<code>Name</code> attribute will be written to the table.
			</property>
			<property name="name" type="string" required="true">
				Specifies the name of the destination column to be written. When the <code>Expression</code> property
				is not set, it also specifies the name of the source column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.generator.IColumnGenerator">
    <properties>
			<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.ColumnMapping">
    <description>
			Column mapping that describes the mapping of one single input value to  
			one output column.
			Both <code>In_a</code> and <code>In_b</code> attributes can be used at once, 
			while the <code>In_a</code> definition will be included in the <code>In_a</code> data
			conversions and <code>In_b</code> will be added to the <code>In_b</code> input data 
			conversions.
		</description>
    <properties>
			<property name="dest" type="string" required="true">
				Destination column name.
			</property>
			<property name="in_a" type="string" required="false">
				Expression to be processed over the <code>In_a</code> input to get the output value.
			</property>
			<property name="in_b" type="string" required="false">
				Expression to be processed over the <code>In_b</code> input to get the output value.
			</property>				
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.iway.adapter.step.AdapterStep$ColumnMapping">
    <description>
			Maps input data flow to adapter&#39;s service input.   
		</description>
    <properties>
			<property name="requestColumn" type="string" required="true">
				Adapter&#39;s service input column name.
			</property>
			<property name="expression" type="string" required="false">
				Expression which is evaluated for adapter&#39;s service input data, instead of directly mapping a data flow column.
				The expression might include definitions and operations on input columns.
			</property>
			<property name="name" type="string" required="true">
				Name of data flow input column to map to requestColumn.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.iway.adapter.write.AdapterWriter$ColumnMapping">
    <description>
			Maps input data flow to adapter&#39;s service input.   
		</description>
    <properties>
			<property name="requestColumn" type="string" required="true">
				Adapter&#39;s service input column name.
			</property>
			<property name="expression" type="string" required="false">
				Expression which is evaluated for adapter&#39;s service input data, instead of directly mapping a data flow column.
				The expression might include definitions and operations on input columns.
			</property>
			<property name="name" type="string" required="true">
				Name of data flow input column to map to requestColumn.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.jdbc.execute.ColumnMapping">
    <description>Defines mapping from SQL result set column to the data row column.</description>
    <properties>
			<property name="sqlColumn" type="string" required="true">
				Defines the name of the column in the SQL result set to take.
			</property>
			<property name="dataColumn" type="string" required="true">
				Defines the name of the column in the data row where to write values to.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.column.ColumnRef">
    <properties>
			<property name="name" type="string" required="true">
			Column name.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.groupClassification.ColumnSet">
    <description>
			Set of rules used for evaluating group quality.
		</description>
    <properties>
			<property name="pivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting a &quot;Pivot record&quot; from a group. Other records are compared to this record in the scope of
				<code>Matching Rules For A Role</code> and/or <code>Matching Rules For M Role</code>, when these rules are used.
			</property>
			<property name="importantColumns" type="com.ataccama.dqc.tasks.common.column.ColumnRef[]" required="false">
				If for any record in the group any of these columns contain empty values or any two records differ in their respective column values, the group is assigned role &#39;C&#39;.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnRef[]" required="false">
				If one of the column values has missing/empty values, it has role &#39;C&#39;. Moreover, if any two records differ in one of their column values,
				the group cannot be assigned role &#39;A&#39;.
			</property>
			<property name="fuzzyColumns" type="com.ataccama.dqc.tasks.common.column.ColumnRef[]" required="false">
				If any of these columns contain empty values, the group is assigned role &#39;C&#39;. The difference from the <code>Columns</code> property is that records can
				differ in these columns and still get an &#39;A&#39; or &#39;M&#39; role.
			</property>
			<property name="extraConditionForMRole" type="string" required="false">
				This property defines the condition that all records in a given group that must satisfy for the group to belong to role &#39;M&#39;.
				If any records don&#39;t match this condition, the group gets a &#39;C&#39; role.
			</property>
			<property name="extraConditionForARole" type="string" required="false">
				This property defines the condition that all records in a given group must satisfy in order for the group to belong to role &#39;A&#39;.
				If any records don&#39;t match this condition, the group gets at most an &#39;M&#39; role.
			</property>
			<property name="matchingRulesForMRole" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Defines the similarity of all records in the group to the pivot record for the group to get at least an &#39;M&#39; role.
				If any records don&#39;t match this condition, the group gets a &#39;C&#39; role.
				<br/>Note: two records named &quot;pivot&quot; and &quot;other&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
			<property name="matchingRulesForARole" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Defines the similarity of all records in the group to the pivot record for the group to get an &#39;A&#39; role.
				If any records don&#39;t match this condition, the group gets at most an &#39;M&#39; role.
				<br/>Note: two records named &quot;pivot&quot; and &quot;other&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
			<property name="when" type="string" required="false">
				Condition for rule use. All records in the group must satisfy this condition for at least one rule (all for the same rule) or else the
				group gets a &#39;C&#39; role. The default result is true.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.column.ColumnSrcDef">
    <description>
			Column specific mapping.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Output column name.
			</property>
			<property name="src" type="string" required="false">
				Input column name. If not specified, the output column name is assumed.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.statistics.ColumnStatistic">
    <description>
		Statistical operation for a specified column.
		</description>
    <properties>
			<property name="count" type="integer" required="true">
			Record count for output record set. The default value is 5.
			</property>
			<property name="name" type="string" required="true">
			Name of statistical operation. You can use a custom name for each operation.
			</property>
			<property name="type" type="com.ataccama.dqc.tasks.analysis.statistics.colstats.ColumnStatisticType" required="true">
			Type of statistical operation, for possible values refer to type column for this step.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic">
    <description>List of Statistic Implementations.</description>
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.statistics.colstats.ColumnStatisticType">
    <description>
			Type of statistical operation. For FIRST_X, LAST_X and QUANTILES operations you can 
			specify	record count for output record set.
		</description>
  </class>
  <class name="com.ataccama.dqc.model.elements.data.ColumnType">
    <description>Available types of values to be stored in records.</description>
  </class>
  <class super="com.ataccama.dqc.tasks.addresses.dictionary.evaluation.IProposalEvaluatorDefinition" name="com.ataccama.dqc.tasks.addresses.dictionary.evaluation.CombiningProposalEvaluatorDefinition">
    <introduction>
    		Method examining all combinations of components found in the input text. 
    	</introduction>
    <description>
    		The methods scans the input text for all matches of the proposal&#39;s components
    		and for each combination of distinct matches evaluates its correspondence
    		to the proposal. The best combination&#39;s correspondence is selected
    		as conformance of the proposal to the input text. Note: each combination
    		can contain at most one occurence of each component only. 
    	</description>
    <properties>
          <property name="unknownTextCleaner" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="false">
    			Definition of constructing matching value for particular columns
    			of unexpl source (for each input element there is one column).
    			However the overall column existing in the pseudo-input as an addition to the input elements
    			contains concatenated orginal value with a pipe character (<code>|</code>) as a separator.<br/>
    			Default value: none - no cleaning is performed and the value is left as is.    			
    		</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.writer.ComplexXmlAssigner">
    <introduction>Adds a new column (beside the top level object stream columns) filled with XML representation of every single top level object. For more info about how
		the XML is created, see <strong>Complex Xml Writer</strong>. Exactly one top level object has to be here.</introduction>
    <description>
			<p align="justify">This step creates output XML object representation according to the template. Works the same way and uses the same configuration as
			<strong>Complex Xml Writer</strong>, with two differences:
				<ul>
					<li>Instead of creating one XML file from all objects, it creates one XML representation for each object. These
					XML strings are added as a new column to the output, which also contains all columns of the top level object stream.</li>
					<li>For this reason, multiple top level objects are not allowed, exactly one is required.</li>
				</ul>
			</p>
		</description>
    <properties>
			<property name="outputColumnName" type="string" required="true">
				Name of the new column with XML representation of the objects.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="objects" type="com.ataccama.dqc.tasks.io.xml.writer.ComplexXmlWriterObjectStreamCfg" required="false">
				Top level streams of objects. Every new object adds a new input of the same name,
				from which these objects will be read - and possibly used for creating output XML file (depending on template).
			</property>
      <property name="template" type="string" required="true">
				XML template for the output file. The content of the output file will be this template (xml header will be added automatically),
				except all elements in the template that correspond to a stream/object (by their names)
				will be entirely replaced by said stream. For that the stream/object has its own XML template.
			</property>
      <property name="encoding" type="string" required="true">
				File data encoding. The possible encodings are all encodings supported by the
				target Java platform. Some commonly used encodings are: ISO-8859-1,
				ISO-8859-2, and UTF-8.
			</property>
      <property name="indenting" type="boolean" required="true">
				When this is set, the output XML will be in human readable form, indented multi-line. Uncheck this for smaller size of the file.
			</property>
      <property name="maximumRecordsInMemory" type="integer" required="true">
				For each inner object, all its records are stored in the memory until this limit is reached; after that, they are stored
				in an external file, which is slower.
			</property>
      <property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				Contains data formatting information for the whole step, unless there is another such attribute specified at certain
				object stream, in which case the latter will be used for that object stream and all its substreams. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.writer.ComplexXmlWriter">
    <introduction>Creates a XML file from data stream(s), based on given template and hierarchical structure of the streams.</introduction>
    <description>
			<p align="justify">This step creates output XML file according to the template. Without any advanced configuration,
			the template is simply written to the output file. For filling it dynamically with some data, we will
			need objects.</p>
			<p align="justify">An object is a stream of records, and the columns of the records are attributes
			of this object. When a new object is added, a new input of the same name is automatically created for reading
			these records. When we do have an object and we connect a data stream to its input, we can use it in the template.
			This is simply done by including an element with the same name as the object. That causes this element to be
			entirely replaced by the XML representation of the object - actually, by one representation for every record read from the input</p>
			<p align="justify">The XML representation of the object is done in very similar way - by its own XML template. But here, we are inside the object,
			and we can use its attributes - columns of the original records - as text values of nodes or attributes of elements. Attribute is
			referenced by its name in curly brackets.</p>
			<p align="justify">
			The default behavior for handling null values is omitting the entire XML element for all column types except of STRING, which will
			include the element with empty content. This behavior can be changed by putting additional flag after the column name inside the
			curly brackets. This can be either a question mark (?) or an exclamation mark (!). The former removes the entire XML element for
			a null value of the column. The latter forces the XML element with empty content for null value.
			</p>
			<p align="justify">XML template of objects is not a standalone XML and is not limited to single root element.</p>
			<p align="justify">Any object can have subobjects - more complex attributes that are read from their own input streams and are joined with parent
			object exactly the same way as in inner join of tables. The attributes/columns for join are specified in the inner objects, in
			the parameter <code>Column Binding</code>. Inner objects are objects as well and can also have subobjects, etc.</p>
			<p align="justify">This step supports encodings supported by Java, including Unicode formats. Available encodings are listed in step configuration.</p>
		</description>
    <properties>
			<property name="fileName" type="string" required="true">
				Name of the output XML file.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="objects" type="com.ataccama.dqc.tasks.io.xml.writer.ComplexXmlWriterObjectStreamCfg" required="false">
				Top level streams of objects. Every new object adds a new input of the same name,
				from which these objects will be read - and possibly used for creating output XML file (depending on template).
			</property>
      <property name="template" type="string" required="true">
				XML template for the output file. The content of the output file will be this template (xml header will be added automatically),
				except all elements in the template that correspond to a stream/object (by their names)
				will be entirely replaced by said stream. For that the stream/object has its own XML template.
			</property>
      <property name="encoding" type="string" required="true">
				File data encoding. The possible encodings are all encodings supported by the
				target Java platform. Some commonly used encodings are: ISO-8859-1,
				ISO-8859-2, and UTF-8.
			</property>
      <property name="indenting" type="boolean" required="true">
				When this is set, the output XML will be in human readable form, indented multi-line. Uncheck this for smaller size of the file.
			</property>
      <property name="maximumRecordsInMemory" type="integer" required="true">
				For each inner object, all its records are stored in the memory until this limit is reached; after that, they are stored
				in an external file, which is slower.
			</property>
      <property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				Contains data formatting information for the whole step, unless there is another such attribute specified at certain
				object stream, in which case the latter will be used for that object stream and all its substreams. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.writer.ComplexXmlWriterObjectStreamCfg">
    <description>
			Definition of a single object - one kind of records read from its own input.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Object name (also name of the associated input and name of the element that&#39;s being replaced by this object).
			</property>
			<property name="template" type="string" required="true">
			    XML template for this object.
			</property>
			<property name="subObjects" type="com.ataccama.dqc.tasks.io.xml.writer.ComplexXmlWriterObjectSubstreamCfg[]" required="true">
				Subobjects of this object.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Contains data formatting information for this object stream and all its substreams. If specified, overrides any data format parameters
				inherited from parents. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.writer.ComplexXmlWriterObjectSubstreamCfg">
    <description>
			Definition of a single object - one kind of records read from its own input.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Object name (also name of the associated input and name of the element that&#39;s being replaced by this object).
			</property>
			<property name="template" type="string" required="true">
			    XML template for this object.
			</property>
			<property name="subObjects" type="com.ataccama.dqc.tasks.io.xml.writer.ComplexXmlWriterObjectSubstreamCfg[]" required="true">
				Subobjects of this object.
			</property>
			<property name="columnBinding" type="string" required="true">
				Binding of this subobject to the parent object (basically &quot;join on&quot; clause). Syntax is &quot;parentColumn=childColumn&quot;.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Contains data formatting information for this object stream and all its substreams. If specified, overrides any data format parameters
				inherited from parents. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.aggregator.Component">
    <properties>
			<property name="expression" type="string" required="true">
				Expression for grouping key components.
			</property>
			<property name="name" type="string" required="true">
				Name of output column storing the grouping key component value.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.abp.parser.configuration.Component">
    <description>
			Definition of a user defined component. Component is defined by its name, definition, output column,
			verifier and scorer sections.
<example>
        <pre>
	
	&lt;component name=&quot;MATCHED_WORD&quot; definition=&quot;{REGEXP:pattern=&#39;[a-zA-Z]+&#39;}&quot; storeParsedInto=&quot;eWord&quot;&gt;
		&lt;scorer explanationColumn=&#39;expl&#39;&gt;
			&lt;scoringEntries&gt;
				&lt;scoringEntry key=&#39;PPV_MISMATCH&#39; score=&#39;300&#39; explain=&#39;true&#39; /&gt;
			&lt;/scoringEntries&gt;
		&lt;/scorer&gt;
		&lt;verifier&gt;
			&lt;fileName&gt;data/ext/street.sl.cif&lt;/fileName&gt;
		&lt;/verifier&gt;
	&lt;/component&gt;
		
</pre>
      </example>
		</description>
    <properties>
			<property name="definition" type="string" required="true">
				Definition of the component. For example: 
				{LETTER}
				{WORD}
				{WORD:minLength=1, maxLength=1,chars=[:letter:]} 
				{WORD:chars=&quot;[:digit:]-[:letter:]&quot;,minLength=1}
				{MULTIWORD:chars=&quot;[:letter:].-&quot;}
				{REGEXP:pattern=@&quot;\d{4}[a-zA-Z]{2}&quot;}
				{MULTIWORD:chars=&quot;[:letter:]-&#39;&quot;}
				{CITY} {LETTER}     
			</property>
			<property name="name" type="string" required="true">
				Name of the component.
			</property>
			<property name="storeParsedInto" type="string" required="false">
				The value matched by the component is stored into this column.
			</property>
			<property name="storeValidatedInto" type="string" required="false">
                 If the value matched by the component is verified by a verifier then the value used to validate
                 the value is stored into this column.
			</property>
			<property name="verifier" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.Verifier" required="false">
				Definition of the word lookup engine (step). Specifies the method with which the lookup is processed,
				dictionary(ies) of acceptable words and the word normalization method.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="PPV_MISMATCH">
				A scoring flag indicating that the component was not verified.<br/>
				NOTE: This property must be defined for each component separately.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.match.Component">
    <description>Definition of input string and its tokenization.</description>
    <properties>
			<property name="expression" type="string" required="true">
				Defines input expression.
			</property>
			<property name="ngramSize" type="integer" required="false">
				Length of ngrams to produce. The value 0 means do not create ngrams.
			</property>
			<property name="wordSeparator" type="string" required="false">
				Word separator.
			</property>
			<property name="exact" type="boolean" required="false">
				Indicates to treat value of the input expression as whole.
				This flag cannot be combined with <code>Ngram Size</code> or <code>Word Separator</code>.
			</property>
			<property name="indexValue" type="string" required="false">
				Column name where to store distance.
			</property>
			<property name="minimalThreshold" type="double" required="false">
				Minimum distance value. Values below this limit are treated as 0.
			</property>
			<property name="weight" type="double" required="true">
				Weight of this component when computing weighted average.
			</property>
			<property name="resultForNullArgument" type="double" required="true">
				Value to be used as distance for null input.
			</property>
			<property name="nullWeight" type="double" required="true">
				Weight of this component when computing weighted average, if this component is null.
			</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.addresses.commons.model.components.ComponentMapping">
    <description>
			Defines mapping components of the reference data to columns.
		</description>
    <properties>
			<property name="componentId" type="string" required="true">
				References the component whose value is mapped.
			</property>
			<property name="column" type="string" required="true">
				Name of the column holding the value for the component.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.ComponentOutputInfo">
    <properties>
			<property name="district" type="string" required="false">
			 Column that stores the identified district (conjuncted UIR-ADR value).
			</property>
			<property name="locality" type="string" required="false">
			Column that stores the identified locality (conjuncted UIR-ADR value).
			</property>
			<property name="localityPart" type="string" required="false">
			Column that stores the identified municipality part (conjuncted UIR-ADR value).
			</property>
			<property name="street" type="string" required="false">
			Column that stores the identified street (conjuncted UIR-ADR value).
			</property>
			<property name="region" type="string" required="false">
			Column that stores the identified region (conjuncted UIR-ADR value).
			</property>
			<property name="streetNumber" type="string" required="false">
			Column that stores the identified street number.
			</property>
			<property name="landRegistryNumber" type="string" required="false">
			Column that stores the identified land registry number.
			</property>
			<property name="postalCode" type="string" required="false">
			Column that stores the identified ZIP code.
			</property>
			<property name="postOffice" type="string" required="false">
			Column that stores the identified post office (conjuncted UIR-ADR value).
			</property>
			<property name="addressId" type="string" required="false">
			Column that stores the code of the identified address point obtained from the UIR-ADR.
			</property>
			<property name="streetId" type="string" required="false">
			Column that stores the code of the identified street obtained from the UIR-ADR.
			</property>
			<property name="localityPartId" type="string" required="false">
			Column that stores the code of the identified municipality part obtained from the UIR-ADR.
			</property>
			<property name="localityId" type="string" required="false">
			Column that stores the code of the identified municipality obtained from the UIR-ADR.
			</property>
			<property name="districtOrig" type="string" required="false">
			Column that stores the input district.
			</property>
			<property name="localityOrig" type="string" required="false">
			Column that stores the input municipality.
			</property>
			<property name="localityPartOrig" type="string" required="false">
			Column that stores the input municipality part.
			</property>
			<property name="streetOrig" type="string" required="false">
			Column that stores the input street.
			</property>
			<property name="regionOrig" type="string" required="false">
			Column that stores the input region.
			</property>
			<property name="streetNumberOrig" type="string" required="false">
			Column that stores the input street number.
			</property>
			<property name="landRegistryNumberOrig" type="string" required="false">
			Column that stores the input land registry number.
			</property>
			<property name="postalCodeOrig" type="string" required="false">
			Column that stores the input postal code.
			</property>
			<property name="postOfficeOrig" type="string" required="false">
			Column that stores the input post office.
			</property>
			<property name="districtClean" type="string" required="false">
			Column that stores the official name of the district according to the found address id.
			</property>
			<property name="localityClean" type="string" required="false">
			Column that stores the official name of the municipality according to the found address id.
			</property>
			<property name="localityPartClean" type="string" required="false">
			Column that stores the official name of the municipality part according to the found address id.
			</property>
			<property name="streetClean" type="string" required="false">
			Column that stores the official name of the street according to the found address id.
			</property>
			<property name="regionClean" type="string" required="false">
			Column that stores the official name of the region according to the found address id.
			</property>
			<property name="postOfficeClean" type="string" required="false">
			Column that stores the official name of the post office according to the found address id.
			</property>
			<property name="streetNumberClean" type="string" required="false">
			Column that stores the official post number according to the found address id.
			</property>
			<property name="landRegistryNumberClean" type="string" required="false">
			Column that stores the official land registry number according to the found address id.
			</property>
			<property name="postalCodeClean" type="string" required="false">
			Column that stores the official ZIP code according to the found address id.
			</property>
			<property name="cityPart" type="string" required="false">
			Column that stores the identified city part (conjuncted UIR-ADR value).
			</property>
			<property name="cityPartOrig" type="string" required="false">
			Column that stores the official name of the city according to the found address id.
			</property>
			<property name="cityPartClean" type="string" required="false">
			Column that stores the official name of the city part according to the found address id.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.ExactAddressIdentifier$ComponentOutputSet">
    <introduction>
			Output columns where to store result components and identifiers.
		</introduction>
    <properties>
			<property name="addressId" type="string" required="false">
				Column that stores the code of the identified address point obtained from the UIR-ADR. 
			</property>
			<property name="district" type="string" required="false">
				Column that stores the official name of the district according to the found address id.
			</property>
			<property name="locality" type="string" required="false">
				Column that stores the official name of the municipality according to the found address id.
			</property>
			<property name="localityPart" type="string" required="false">
				Column that stores the official name of the municipality part according to the found address id.
			</property>
			<property name="street" type="string" required="false">
				Column that stores the official name of the street according to the found address id.
			</property>
			<property name="streetNumber" type="string" required="false">
				Column that stores the street number according to the found address id.
			</property>
			<property name="landRegistryNumber" type="string" required="false">
				Column that stores the the land registry number according to the found address id.
			</property>
			<property name="postalCode" type="string" required="false">
				Column that stores the official name of the postal code according to the found address id.
			</property>
			<property name="postOffice" type="string" required="false">
				Column that stores the official name of the post office according to the found address id.
			</property>
			<property name="cityPart" type="string" required="false">
				Column that stores the official name of the city part according to the found address id.
			</property>
			<property name="parsedDistrict" type="string" required="false">
				Column that stores the input district. 
			</property>
			<property name="parsedLocality" type="string" required="false">
				Column that stores the input municipality. 
			</property>
			<property name="parsedLocalityPart" type="string" required="false">
				Column that stores the input municipality part. 
			</property>
			<property name="parsedStreet" type="string" required="false">
				Column that stores the input street. 
			</property>
			<property name="parsedStreetNumber" type="string" required="false">
				Column that stores the input street number. 
			</property>
			<property name="parsedLandRegistryNumber" type="string" required="false">
				Column that stores the input land registry number. 
			</property>
			<property name="parsedPostalCode" type="string" required="false">
				Column that stores the input postal code. 
			</property>
			<property name="parsedPostOffice" type="string" required="false">
				Column that stores the input post office. 
			</property>
			<property name="parsedCityPart" type="string" required="false">
				Column that stores the input city part. 
			</property>
			<property name="streetId" type="string" required="false">
				Column that stores the code of the identified street obtained from the UIR-ADR. 
			</property>
			<property name="localityPartId" type="string" required="false">
				Column that stores the code of the identified municipality part obtained from the UIR-ADR. 
			</property>
			<property name="localityId" type="string" required="false">
				Column that stores the code of the identified municipality obtained from the UIR-ADR. 
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ISearchMethodDefinition" name="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ComposedSearchMethod">
    <introduction>
    		Definition of multiple search methods that are to be run in turn.
    	</introduction>
    <description>
    		Simple method that runs each configured search method in turn to find
    		all possible matches. Duplicate matches from different methods
    		are made distinct.
    	</description>
    <properties>
    		<property name="methods" type="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ISearchMethodDefinition[]" required="true">
    			All configured search methods.
    		</property>
    	<property name="inputComponents" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference[]" required="true">
		      List of input components to be searched for.
		  </property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorComposite">
    <description>
			Column value is concatenation of random values generated by sub-generators.
		</description>
    <properties>
			<property name="generators" type="com.ataccama.dqc.tasks.generator.IColumnGenerator[]" required="true">
				List of sub-generators.
			</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.compression.CompressionType">
    <description>
			<p align="justify">
				Defines compression type to be used when reading or writing text files
				(such as <strong>TextFileReader</strong>,
				<strong>TextFileWriter</strong> or
				<strong>FixedWidthFileReader</strong>).
			</p>
		</description>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.reconcile.ComputeGeneralLedger">
    <introduction>
    		Calculates aggregated values of debit and credit for defined 
    		accounts and their descendants in a defined hierarchy.
    	</introduction>
    <description>
    		Algorithm processes input records where it binds columns defined as properties
    		<code>Account Number</code>, <code>Name</code>, <code>Credit Value</code> and <code>Debit Value</code>.
    		It then sums values from <code>Credit Value</code> and <code>Debit Value</code> columns for each account 
    		identified in the input by <code>Account Number</code> defined in the account hierarchy (see property <code>Accounts</code>). 
 			Accounts not defined in the <code>Accounts</code> property are ignored. The <code>Accounts</code> property represents 
 			tree structure of accounts identified by account number. After all records are processed, 
 			the summary information is written to the output <code>out_computed</code> endpoint. 
 			It consist of records in the following format:
 			<ul>
 				<li>
          <code>accountNumber</code> : Long</li>
 				<li>
          <code>accountName</code> : String</li>
 				<li>
          <code>cumulatedCredit</code> : Float. It is account&#39;s credit + sum of all children-accounts credits</li>
 				<li>
          <code>cumulatedDebit</code> : Float. It is account&#39;s debit + sum of all children-accounts debits</li>
 			</ul> 
 			See also steps <strong>Reconcile</strong> 
 			and <strong>Mapped Reconcile</strong>.
    	</description>
    <properties>
    		<property name="accounts" type="com.ataccama.dqc.tasks.experimental.reconcile.GlAccount[]" required="true">
    			Definition of account hierarchy.
    		</property>
      		<property name="debitValue" type="string" required="true">
      			Defines column, which contains value to be added to <code>cumulatedDebit</code> column. 
      		</property>
      		<property name="creditValue" type="string" required="true">
      			Defines column, which contains value to be added to <code>cumulatedCredit</code> column.
      		</property>
      		<property name="glAccount" type="string" required="true">
      			Defines column, which contains account number.
      		</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.components.CondKey">
    <properties>
	        <property name="components" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
	        	Set of components of the key.
	        </property>
	        <property name="noKeyCond" type="string" required="false">
	        	Condition specifying when this key is assumed to be unusable and is therefore not used as a matching key in candidate group collection.
	        </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.conditions.Condition">
    <introduction>Splits the data flow into two branches based on an expression.</introduction>
    <description>
		Filters data flow across multiple branches as determined by the defined
		conditional expression. There are two main branches: satisfied condition and not-satisfied
		condition, which are labeled &quot;out_true&quot; and &quot;out_false&quot;, respectively.
		<br/>
      <br/>

		<p align="justify">
			For a detailed description of the construction of expressions, please refer to the section
			<strong>expressions</strong>.
		</p>
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="condition" type="string" required="true">
			Logical expression that controls branching.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.global.flow.NestedFlowParams" name="com.ataccama.one.profiling.linear.simple.params.global.flow.ConditionParams">
    <introduction>Condition Parameters</introduction>
    <properties>
			<property name="computeForRoot" type="boolean" required="true">Expression is evaluated for all cases. If the condition is true and also if the condition is false.</property>
			<property name="expression" type="string" required="false">Expression condition (<code>Boolean</code>).</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.io.gdr.reader.member.StructuredMemberBase" name="com.ataccama.dqc.tasks.io.gdr.reader.member.ConditionalIteration">
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.common.abp.parser.ITokenizerConfig" name="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig">
    <description>
			This element is used for demarcating/splitting input text string into particular
			components (tokens) depending on defined rules. Every token type is specified using two sets
			of characters: <code>tokenStartCharacters</code> and <code>tokenCharacters</code>.<br/>
			Within the tokenization process, the input string is analyzed one character at a time, and when any character
			corresponding to <code>tokenStartCharacters</code> is found, this character is considered the beginning
			of a new token of the defined type. Any other characters found and corresponding to <code>tokenCharacters</code>
			are then included into this new token.<br/>
			The name of a tag associated with the following configuration depends on which step the <code>ConfigurableTokenizer</code>
			uses (for names of these tags refer to their descriptions).<br/>

			<p align="justify">
				The set of characters can be defined using the following (for detailed description see <strong>character set</strong>):<br/>
				<ul>
					<li>enumeration, e.g. <code>abcdef</code>
          </li>
					<li>interval, e.g. <code>a-f</code> or <code>a-cd-f</code>, etc. If the character <code>-</code>
					is intended to be part of the set, it must be defined at the very end of the definition.</li>
					<li>Link to predefined constant set of characters using bracket expression (<code>[:</code> and <code>:]</code>).
					When the characters &quot;<code>[:</code>&quot; or &quot;<code>:]</code>&quot; are intended to be a part of the set, they must be
					defined separately from the definition (not to be considered as beginning or definition set).<br/>
					There are also <strong>predefined character classes</strong> available.
	
					An example of definition: <code>[:uppercase:]</code>.<br/>
					Listed constants can also be used in an &quot;exclude&quot; form such as <code>[:lowercase:-abc:]</code>, where
					characters &quot;abc&quot; are a list of exceptions in the defined characters set.
					An example of such definition: <code>[:uppercase:-A:]</code> (all capital letters except for &#39;A&#39;)<br/>
					</li>
					<li>merging - all possibilities listed above can be combined to create a single set,
						e.g. a definition of a token that begins with a letter and continues with letters, numbers
						or a dash:
						<code> &lt;type tokenCharacters=&quot;[:letter:][:digit:]-&quot; tokenStartCharacters=&quot;[:letter:]&quot;&gt; </code>
					</li>
				</ul>
			</p>
			<example>
<pre>
&lt;tokenizerConfig whiteSpaceDefinition=&quot;[:white:]&quot;&gt;
	&lt;types&gt;
		&lt;type tokenStartCharacters=&quot;0-9&quot; tokenCharacters=&quot;0-9&quot;  /&gt;
		&lt;type tokenStartCharacters=&quot;[:letter:]&quot; tokenCharacters=&quot;[:letter:]&quot;  /&gt;
	&lt;/types&gt;
&lt;/tokenizerConfig&gt;
</pre>
				The configuration used in the example considers the following as individual tokens:
						<ul>
                            <li>numbers</li>
                            <li>sequences of letters (including national/accented characters)</li>
                        </ul>
				<br/>An example of input and output:
					<table border="1">
						<th>
							<th>input</th>
            <th>output</th>
						</th>
						<tr>
							<td>aaa1234bbb</td>
							<td>aaa<br/>1234<br/>bbb</td>
						</tr>
						<tr>
							<td>aaaBbbCccü Ddd,123eee</td>
                            <td>aaaBbbCccü<br/>Ddd<br/>123<br/>eee</td>
						</tr>
					</table>
			</example>
		</description>
    <properties>
			<property name="types" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig$TokenType[]" required="false">
				Defines types of possible tokens.<br/> 
                <strong>If this definition is missing or the configuration
                of a tokenizer is missing entirely</strong>, the default configuration
                is used. In this situation, only words and numbers are taken into account. That is, the following types are defined:
					<ul>
						<li>
            <code>tokenStartCharacters=[:letter:] tokenCharacters=[:letter:]</code>
          </li>
						<li>
            <code>tokenStartCharacters=[:digit:] tokenCharacters=[:digit:]</code>
          </li>
					</ul>
			</property>
			<property name="whiteSpaceDefinition" type="string" required="false">
				Defines which characters are considered as delimiter characters.
				Only tokenizers derived from <code>ConfigurableTokenizer</code>	use this property
				(e.g. <code>WhiteSpaceTokenizer</code>). Using this property within the <code>ConfigurableTokenizer</code>
				by itself is incorrect.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.multi.IRandomRecordCountGeneratorConfig" name="com.ataccama.dqc.tasks.generator.multi.ConstantRecordCountGenerator">
    <description>
			Number of child records is constant for every parent record. This is fastest implementation.
		</description>
    <properties>
			<property name="recordCount" type="integer" required="true">
				Number of child record to generate for every parent record.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ConvertPhoneNumbersAlgorithm">
    <introduction>Transforms phone numbers according to the definition based on a dictionary file.</introduction>
    <description>
			Transforms phone numbers from the old Czech numbering system to the new one which was
			established in September, 2002. Input of the step consists of the area code and the actual phone number.
			Only strings which do not contain letters are accepted as valid input, special characters are removed.
			<br/>
			The input file contains the columns &#39;original area code&#39;, &#39;original phone number&#39;
			and new &#39;national number&#39;. Phone numbers (both original and national)
			end with a letter mask to specify the format of the whole number.
			The number is therefore given as a prefix and its mask. The length of the
			mask for particular prefixes and national numbers is given by a
			renumbering plan. The schema is currently usable only in the Czech Republic,
			we are not aware of any other country where it might be applicable.
			<br/>
			The resulting dictionary is an indexed table with columns containing the 
			prefix of the original number including the leading zero (source prefix), the length of the mask
			in characters and the prefix of the new national number. The table is
			indexed by the source prefix.
		</description>
    <properties>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="areaCode" type="string" required="true">
			Column that contains input area codes.
			</property>
			<property name="conversionTableFileName" type="string" required="true">
				Name of the file containing the conversion table, see
					<strong>Dictionary files</strong> for the file format description.
			</property>
			<property name="nationalNumber" type="string" required="true">
			Column that stores the resulting phone numbers.
			</property>
			<property name="omitIfNotConverted" type="boolean" required="true">
				Flag specifying whether invalid input phone numbers should be written to the 
				output (flag set to <code>false</code>) or not (flag set to <code>true</code>).
				If the flag is set to <code>false</code> and the input number cannot be converted
				(either not found in the <strong>dictionary file</strong> or of incorrect length)
				then the input phone number is sent to the output. Connection of the area code and the phone number is stored
				in the output property <code>National Number</code>.
				Default value: <code>True</code> (not to send to output).
			</property>
			<property name="phoneNumber" type="string" required="true">
			Column that contains input phone numbers.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="CPN_PN_NULL">
				A scoring flag indicating that the value of the input property &quot;phoneNumber&quot; is empty.
			</scoringKey>
			<scoringKey name="CPN_AC_NULL">
				A scoring flag indicating that the value of the input property &quot;areaCode&quot; is empty.
			</scoringKey>
			<scoringKey name="CPN_PN_UNKNOWN">
				A scoring flag indicating that the phone number is unknown (could not be found in the indexed table).
			</scoringKey>
			<scoringKey name="CPN_PN_NONSENSE">
				A scoring flag indicating that the input property &quot;phoneNumber&quot; contains
				data other than a phone number.
			</scoringKey>
			<scoringKey name="CPN_AC_NONSENSE">
				A scoring flag indicating that the input property &quot;areaCode&quot; contains
				data other than an area code.
			</scoringKey>
			<scoringKey name="CPN_PN_LENGTH">
				A scoring flag indicating that the input phone number (a combination of the area code and phone number)
				is in the indexed table but the length of the rest of the input is different than required
			    for the conversion (the required length is defined by the mask length in the <strong>dictionary file</strong>).
			</scoringKey>
			<scoringKey name="CPN_PN_NEW_FORMAT">
				A scoring flag indicating that the input phone number is already in the new format.
			</scoringKey>
			<scoringKey name="CPN_PN_CONVERTED">
				A scoring flag indicating that the input phone number was transformed to the new format.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfCountLinesInFileTask">
    <introduction>Counts number of lines in a text file.</introduction>
    <description>
			The task counts number of lines in the specified text file.
			The task will store its output into 3 task variables:
			<ul>
				<li>
          <strong>TOTAL_LINE_COUNT</strong>. Number of all lines in the file</li>
				<li>
          <strong>IGNORED_LINE_COUNT</strong>. Number of lines ignored by ignoredRowRegEx condition</li>
				<li>
          <strong>DATA_LINE_COUNT</strong>. Number of lines that contain data. It is calculated via the following formula:
				<br/>DATA_LINE_COUNT = totalLineCount - ignoredLineCount - numberOfLinesInHeader - numberOfLinesInFooter </li>
			</ul>
		</description>
    <properties>
			<property name="encoding" type="string" required="true">
				File data encoding. The possible encodings are all encodings supported by the
				target Java platform. Some commonly used encodings are: ISO-8859-1,
				ISO-8859-2, and UTF-8.
			</property>
			<property name="ignoredRowRegEx" type="string" required="false">
				A regular expression that is compared to lines in the input file. If a line (read as a string) matches the
				regular expression, the line will be ignored.
			</property>
			<property name="lineMaxReadLength" type="string" required="true">
				Specified maximum number of characters per line to be read and processed.
				The behaviour for that event is configured by <strong>failOnLongLine</strong> property.
			</property>
			<property name="failOnLongLine" type="boolean" required="true">
				If the option is set to true, fail processing if line is longer than the limit.
				<br/>If the option is set to false, instead of failing it throws a warning into log file.
				The warning is logged only for first 100 lines.
				If the number of lines which size exceeds allowed, the total number is put into logs.
			</property>
			<property name="lineSeparator" type="string" required="true">
				Specifies the string to be recognized as a line delimiter. The line delimiter
				can be any sequence of letters, although a specific symbol is often used
				which usually depends on the operating system where the file originated from.
				The special symbols are:  \r = CR, \l = LF, \n = LF. <strong>Escaped string property.</strong>
			</property>
			<property name="numberOfLinesInFooter" type="string" required="true">
				Specifies the number of lines from the end of the file that will be excluded from
				processing (footer lines).
			</property>
			<property name="numberOfLinesInHeader" type="string" required="true">
				Specifies the number of lines from the beginning of the file that will be excluded from
				processing (header lines, comments, etc).
			</property>
			<property name="progressInterval" type="string" required="false">
				If a value for progress interval is defined, the task will store its progress into task log.
			</property>
			<property name="sourceFile" type="string" required="true">
				Name of the file containing the input data.
			</property>
			<property name="stringQualifier" type="string" required="false">
				String enclosing a text string. Not defined by default. <strong>Escaped string property.</strong>
			</property>
			<property name="stringQualifierEscape" type="string" required="false">
				Escape character escaping the <code>String Qualifier</code> in the original meaning of
				this character. Not defined by default. <strong>Escaped string property.</strong>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.CreatePostalAddress">
    <introduction>
			Creates an address in a format suitable for the post office from 
			input parsed values or an identified address.</introduction>
    <description>
			Based on the input data (address components or address id) this step creates a 
			uniform address to be printed on an envelope.
			
			There are two ways of specifying the address components: either component
			values given directly as columns or address id to be queried in 
			the address reference data for components.
			 
			If some fields are missing, this situation is reported by means of NULL flags, although
			this reporting is not generally applied to all components. There
			are several components that are required for generating addresses,
			so these must be non-empty, regardless of how they are defined.
			The other components may or may not be reported as missing, depending
			on the way how they were acquired. If the address is to be generated
			from the reference data, these are not reported as missing since it is assumed 
			that this is the correct situation, whereas if defined directly, they
			are reported as missing.
			
			Additionally, if any of the required components are missing, the step will not
			generate an address .			
			
			The required components are:
			<ul>
				<li>ZIP code and post office</li>
				<li>Street, if SN is defined</li>
				<li>Land registry number</li>
				<li>Locality</li>
				<li>Locality part</li>
			</ul>
			Components that can be missing are:
			<ul>
				<li>SN</li>
				<li>City part</li>
			</ul> 
			
			If the address cannot be generated, the CPA_CANNOT_GENERATE flag is set on.
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="mode" type="com.ataccama.dqc.addresses.commons.AddressModeType" required="false">
				Defines the method. <br/>Possible values: <code>UIR-ADR</code> and <code>RUIAN</code>.
				UIR-ADR defines legacy method, whereas RUIAN stands for the method defined by notice
				of Czech Office for Surveying, Mapping and Cadastre from November 24th, 2011.
				Default value: UIR-ADR.
			</property>
			<property name="addressId" type="string" required="false">
				Identification number of an address point (address ID).
				If this property is linked to an existing output column (i.e., property and its column are defined),
				the address is determined via this value. The rest of bindings MUST NOT be linked to any column.
			</property>
			<property name="locality" type="string" required="false">
				Column that contains the input locality (city name).
				Required if a column for addressId is not specified.
			</property>
			<property name="localityPart" type="string" required="false">
				Column that contains the input locality part.
				Required if a column for addressId is not specified.
			</property>
			<property name="street" type="string" required="false">
				Column that contains the input street name.
			</property>
			<property name="landRegistryNumber" type="string" required="false">
				Column that contains the input land registry number.
				Required if a column for addressId is not specified.
			</property>
			<property name="postalCode" type="string" required="false">
				Column that contains the input postal code.
				Required if a column for addressId is not specified.
			</property>
			<property name="postOffice" type="string" required="false">
				Column that contains the input post office.
				Required if a column for addressId is not specified.
			</property>
			<property name="streetNumber" type="string" required="false">
				Column that contains the input street number.
			</property>
			<property name="cityPart" type="string" required="false">
				Column that contains the input city part.
			</property>
			<property name="districtOfPrague" type="string" required="false">
				Column that contains the input district of Prague (&quot;mestsky obvod&quot;, Praha 1 - 10).
				Relevant only when mode is set to <code>RUIAN</code>.
			</property>
			<property name="cadastralArea" type="string" required="false">
				Column that contains the input cadastral area. This value is used
				only for addresses at area of Prague.
				Relevant only when mode is set to <code>RUIAN</code>.
			</property>
			<property name="topRow" type="string" required="true">
				Column that stores the first row of the address to be printed.
			</property>
			<property name="middleRow" type="string" required="true">
				Column that stores the second row of the address to be printed.
			</property>
			<property name="bottomRow" type="string" required="true">
				Column that stores the third row of the address to be printed.
			</property>
			<property name="dataFolder" type="string" required="false">
				Path to the UIR-ADR reference data.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="CPA_ADDR_ID_NULL">
				A scoring flag indicating the input address identifier is missing. This occurs when the property
				<code>Address Id</code> is linked to an existing column. If not,	this scoring flag is not used.
			</scoringKey>
			<scoringKey name="CPA_INVALID_ADDR_ID">
				A scoring flag indicating that the input address ID is incorrect (not found in the UIR-ADR reference
				data). This occurs when the property <code>Address Id</code> is linked to an existing column. If not,
				this scoring flag is not used.
			</scoringKey>
			<scoringKey name="CPA_LOCALITY_NULL">
				A scoring flag indicating that input city name is missing.
			</scoringKey>
			<scoringKey name="CPA_LOCALITY_PART_NULL">
				A scoring flag indicating that input locality (city) part is missing.
			</scoringKey>
			<scoringKey name="CPA_STREET_NULL">
				A scoring flag indicating that input street name is missing but the input street number is available.
			</scoringKey>
			<scoringKey name="CPA_LRN_NULL">
				A scoring flag indicating that input land registry number is missing.
			</scoringKey>
			<scoringKey name="CPA_SN_NULL">
				For components at input, this scoring flag indicates that the input 
				street name is available but the input street number is missing.
				This situation is indicated also for addresses in which the street number is actually (in reality) missing
				(since the step does not verify this information in the UIR-ADR reference data).
				Moreover, this flag is set when both land registry number and SN are missing, regardless of input. 
			</scoringKey>
			<scoringKey name="CPA_ZIP_NULL">
				A scoring flag indicating that the input ZIP code is missing.
			</scoringKey>
			<scoringKey name="CPA_POST_OFFICE_NULL">
				A scoring flag indicating that the input post office name is missing.
			</scoringKey>
			<scoringKey name="CPA_CITY_PART_NULL">
				A scoring flag indicating that the input city part name is missing.
			</scoringKey>
			<scoringKey name="CPA_CANNOT_GENERATE">
				A scoring flag indicating that the step cannot generate an output
				address due to missing values.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.domain.CustomDomainAnalysis">
    <description>
			User defined domain.
		</description>
    <properties>
			<property name="name" type="string" required="true">
			Name of domain.
			</property>
			<property name="condition" type="string" required="true">
			Boolean expression which tells if the value belongs to this domain.
			The column value can be accesed by pseudo-column named <code>value</code> and
			its data type is equal to type specified in <code>forType</code> property.
			</property>
			<property name="forType" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
			Data type for which the rule will be applied.
			</property>
			<property name="threshold" type="integer" required="true">
			Minimal percentage. The column belongs to this domain if
			its values satisfy <code>condition</code> in
			at least <code>threshold</code> percent of input records
				<br/>Default = 80%.
			</property>
			<property name="active" type="boolean" required="true">
				Specifies whether the analysis will be performed.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.global.domain.CustomDomainParams">
    <description>Custom Domain Parameters are list of used defined rules for Custom Domain Analysis.</description>
    <properties>
			<property name="allowedTypes" type="com.ataccama.dqc.model.elements.data.ColumnType[]" required="false">When this option is turned on only specified data types are used for evaluation of expression (only numbers, strings, etc.).</property>
			<property name="condition" type="string" required="true">Applied for specifying condition when the data will be profiled (<code>Boolean</code>).</property>
			<property name="considerNulls" type="boolean" required="true">When this option is on <code>NULL</code> values will be consider in results.</property>
			<property name="invalidExamplesCount" type="integer" required="true">Number of distinct invalid results.</property>
			<property name="name" type="string" required="false">Name of Parameter</property>
			<property name="sourceTransformation" type="com.ataccama.one.profiling.linear.simple.params.global.domain.transformation.SourceTransformation" required="false">Type of the source transformation (Type or Mask).</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.web.console.custom.CustomWebConsoleCategory">
    <description>Each custom category corresponds to a section in the Admin Center navigation panel. Pages within the section are defined in the configuration file.</description>
    <properties>
			<property name="configFile" type="string" required="true">Configuration file for a custom category.</property>
			<property name="label" type="string" required="true">Category label displayed in the Admin Center navigation panel.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.console.custom.CustomWebConsolePagesComponent">
    <introduction>Adds Custom Pages section to Admin Center and enables using and creating custom pages within this section.</introduction>
    <description>Adds Custom Pages section to Admin Center and enables using and creating custom pages within this section.
		<p align="justify">
			The following page classes are available:
			<ul>
    			<li>FileBrowserPage – displays a list of files in a directory including size and last modification date.</li>
  				<li>FileTablePage – sorts files in a directory into one or more columns; each column has it own regular expression filter.</li>
   				<li>DatabaseQueryPage – displays results of one or more SQL queries, supports linking to other pages.</li>
    		</ul>
		</p>
		</description>
    <properties>
			<property name="customCategories" type="com.ataccama.dqc.web.console.custom.CustomWebConsoleCategory[]" required="false">Each custom category corresponds to a section in the Admin Center navigation panel.</property>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.nlp.CzechStemmer">
    <introduction>Performs stemming of input in Czech language.</introduction>
    <description>
            <p align="justify">Step uses algorithm by Ljiljana Dolamic and Jacques Savoy. The algorithm was originally published in
                <code>http://dx.doi.org/10.1016/j.ipm.2009.06.001.</code>
      </p>
            <p align="justify">Stemming a word is conducted in several steps. After each step, the current word form is searched in user defined lookup. If the form is found in lookup, the stemming process stops. When no lookup file is supplied, all stemming steps are performed.
      </p>
            <p align="justify">Optional tokenizer may be configured to process composed records. The tokenization is done only for internal use. A record is tokenized, tokens are stemmed separately and then reassembled to one record. All non-alphabetic characters are passed through without any change.
      </p>
            <p align="justify">Algorithm can run in two modes: aggressive and light. The light version only removes case endings. The aggressive version tries to remove possessives endings, comparative endings, diminutive endings, augmentative suffixes and derivational suffixes.</p>
        </description>
    <properties>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="aggressiveStemming" type="boolean" required="true">Checked for aggressive version, unchecked for light version.</property>
            <property name="inputColumn" type="string" required="true">Column that contains the input text. To properly stem multiple words in a record, configurable tokenizer should be used.</property>
            <property name="outputColumn" type="string" required="true">Column for stemmed output.</property>
            <property name="lookupFile" type="string" required="false">Lookup file used for checking partial stems.</property>
            <property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="false">Configurable Tokenizer configuration.</property>
            <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
        </properties>
    <scoring/>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfDeleteFileOperation">
    <introduction>Deletes a target file or folder.</introduction>
    <description>Deletes a target file or folder. The task fails when it does not have permissions to delete the target file/folder.</description>
    <properties>
			<property name="recursiveFlag" type="boolean" required="true">Permission to delete sub-directories.</property>
			<property name="targetFile" type="string" required="true">Path to the mask on target file/folder. Task fails when no file/directory is found to mask.
				<p align="justify">Supports wildcards.</p>
      </property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.ci.attribute.CiAttrAggrReader">
    <introduction>This step allows the user to read results of attribute aggregations from <strong>ONE Web Application</strong>.
        </introduction>
    <description>
            Returns results of certain DQ aggregations for attributes.
        </description>
    <properties>
            <!--XXX-->
            <property name="attributeId" type="string" required="true">.</property>
            <property name="catalogItemId" type="string" required="true">.</property>
            <property name="aggregationId" type="string" required="false">.</property>
            <property name="limit" type="long" required="false">.</property>
            <property name="timeRangeFrom" type="datetime" required="false">.</property>
            <property name="timeRangeTo" type="datetime" required="false">.</property>

            <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
                Explorer
            </strong> &gt; <strong>Servers</strong>)
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
                used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
                of <strong>Default Expression</strong>.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.ci.ci.CiCiAggrReader">
    <introduction>This step allows the user to read results of catalog item aggregations from <strong>ONE Web Application</strong>.
        </introduction>
    <description>
            Returns results of DQ aggregations for catalog item.
        </description>
    <properties>
            <!--XXX-->
            <property name="catalogItemId" type="string" required="true">.</property>
            <property name="aggregationId" type="string" required="false">.</property>
            <property name="limit" type="long" required="false">.</property>
            <property name="timeRangeFrom" type="datetime" required="false">.</property>
            <property name="timeRangeTo" type="datetime" required="false">.</property>

            <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
                Explorer
            </strong> &gt; <strong>Servers</strong>)
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
                used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
                of <strong>Default Expression</strong>.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.mp.aggregations.MpAggrsReader">
    <introduction>This step allows the user to read monitoring project aggregations from <strong>ONE Web Application</strong>.
        </introduction>
    <description>
            Provides results of certain aggregations
        </description>
    <properties>
            <!--XXX-->
            <property name="monitoringProjectId" type="string" required="true">.</property>
            <property name="catalogItemId" type="string" required="true">.</property>
            <property name="aggregationId" type="string" required="true">.</property>
            <property name="limit" type="long" required="false">.</property>
            <property name="timeRangeFrom" type="datetime" required="false">.</property>
            <property name="timeRangeTo" type="datetime" required="false">.</property>

            <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
                Explorer
            </strong> &gt; <strong>Servers</strong>)
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
                used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
                of <strong>Default Expression</strong>.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.mp.checks.MpChecksReader">
    <introduction>This step allows the user to read monitoring project check results from <strong>ONE Web Application</strong>.
        </introduction>
    <description>
            Returns results of certain DQ checks. Validity checks include also explanations that provide invalidy reasons.
        </description>
    <properties>
            <!--XXX-->
            <property name="monitoringProjectId" type="string" required="true">.</property>
            <property name="catalogItemId" type="string" required="true">.</property>
            <property name="dqCheckId" type="string" required="true">.</property>
            <property name="limit" type="long" required="false">.</property>
            <property name="timeRangeFrom" type="datetime" required="false">.</property>
            <property name="timeRangeTo" type="datetime" required="false">.</property>

            <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
                Explorer
            </strong> &gt; <strong>Servers</strong>)
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
                used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
                of <strong>Default Expression</strong>.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.mp.values.MpValuesReader">
    <introduction>This step allows the user to read monitoring project processing filter values from the <strong>ONE Web Application</strong>.
    </introduction>
    <description>
        Provides data values of filter attributes. It lives under monitoringProjectProcessing entity - these values can change in each processing.    </description>
    <properties>
        <!--XXX-->
        <property name="monitoringProjectProcessingId" type="string" required="true">.</property>
        <property name="catalogItemId" type="string" required="true">.</property>

        <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
            Explorer
        </strong> &gt; <strong>Servers</strong>)
        </property>
        <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
            used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
            of <strong>Default Expression</strong>.
        </property>
    <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.mp.project.MpProjectReader">
    <introduction>This step allows the user to read monitoring project results from the <strong>ONE Web Application</strong>.
        </introduction>
    <description>
            Returns project validity results over time. The results are aggregated over all catalog items in MP.
        </description>
    <properties>
            <!--XXX-->
            <property name="monitoringProjectId" type="string" required="true">.</property>
            <property name="limit" type="long" required="false">.</property>
            <property name="timeRangeFrom" type="string" required="false">.</property>
            <property name="timeRangeTo" type="string" required="false">.</property>

            <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
                Explorer
            </strong> &gt; <strong>Servers</strong>)
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
                used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
                of <strong>Default Expression</strong>.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.ci.rule.CiRuleInstanceReader">
    <introduction>This step allows the user to read results of rule instances from <strong>ONE Web Application</strong>.
    </introduction>
    <description>
        Returns results of DQ rule instances. It lives under catalogItem entity. Results include also explanations that provide invalid reasons.
    </description>
    <properties>
        <!--XXX-->
        <property name="attributeId" type="string" required="true">.</property>
        <property name="catalogItemId" type="string" required="true">.</property>
        <property name="ruleId" type="string" required="false">.</property>
        <property name="limit" type="long" required="false">.</property>
        <property name="timeRangeFrom" type="datetime" required="false">.</property>
        <property name="timeRangeTo" type="datetime" required="false">.</property>

        <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
            Explorer
        </strong> &gt; <strong>Servers</strong>)
        </property>
        <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
            used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
            of <strong>Default Expression</strong>.
        </property>
    <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.ci.term.CiTermAggrReader">
    <introduction>This step allows the user to read results of term aggregations from <strong>ONE Web Application</strong>.
        </introduction>
    <description>
            Returns aggregated result of DQ for whole term. It lives under term entity. It takes last (see at parameter) results from all attributes where is the term assigned and sums them together.
        </description>
    <properties>
            <!--XXX-->
            <property name="termId" type="string" required="true">.</property>
            <property name="at" type="datetime" required="false">.</property>
            <property name="limit" type="long" required="false">.</property>
            <property name="timeRangeFrom" type="datetime" required="false">.</property>
            <property name="timeRangeTo" type="datetime" required="false">.</property>

            <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
                Explorer
            </strong> &gt; <strong>Servers</strong>)
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
                used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
                of <strong>Default Expression</strong>.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dq.ci.attribute.CiTermAttrAggrReader">
    <introduction>This step allows the user to read results of term aggregation for attribute from <strong>ONE Web Application</strong>.
        </introduction>
    <description>
            Returns results of Term aggregation for attribute.
        </description>
    <properties>
            <!--XXX-->
            <property name="termId" type="string" required="true">.</property>
            <property name="attributeId" type="string" required="true">.</property>
            <property name="limit" type="long" required="false">.</property>
            <property name="timeRangeFrom" type="datetime" required="false">.</property>
            <property name="timeRangeTo" type="datetime" required="false">.</property>

            <property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>. (<strong>File
                Explorer
            </strong> &gt; <strong>Servers</strong>)
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are
                used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result
                of <strong>Default Expression</strong>.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.dqi.DQIRule">
    <properties>
			<property name="name" type="string" required="true">
				Rule name.
			</property>
			<property name="code" type="string" required="true">
				Code of rule. Must not contain spaces and all codes must be unique.
			</property>
			<property name="shortDescription" type="string" required="false">
				Short description of rule.
			</property>
			<property name="description" type="string" required="false">
				Description of rule.
			</property>
			<property name="expression" type="string" required="true">
				Boolean expression.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.dqi.DQIStep">
    <introduction>
			Computes boolean expressions for each input row and gives results of them to the output 
			together with input rows.
		</introduction>
    <description>
			The step evaluates a set of named boolean expressions (<code>Rules</code>) 
			and writes the result to an output column and also creates a summary report. 
			It contains rules which are types of coded boolean conditions. The other fields are not 
			required for step functionality. 
			The step works as follows:
			<ul>
				<li>
					Computes all rule conditions for each row from the input. 
				</li>
				<li>
					Sends each row to the &#39;out&#39; endpoint and adds boolean columns which are named
					according to the code of rules to the output format. This implies that no code 
					can be the same as any of the input column names. 
					Then it stores the results of the conditions into these added columns.
				</li>
				<li>
					Finally, it creates a report with as many <em>slots</em> as there are rules. 
					Each <em>slot</em> can contain one or more rows depending on how grouping has been defined.
					When no grouping is used, then each slot consists of just one row. When the grouping
					is employed, each slot contains as many rows as there are groups in the input data.
					Data in each slot are calculated from data matching that rule (when condition)
					and particular group.
					Generally, each row in a slot contains the rule with all its fields as columns and the following
					added columns:
				<ul>
					<li>
						Success_count - how many times the condition of this rule returned a true value
					</li>
					<li>
						Total - count of input rows matching any rule. 
					</li>
					<li>
						Total_Per_Rule - count of input rows matching this rule
					</li>
					<li>
						Total_Exposure_Value - total exposure value over all records matching rhis rule
					</li>
					<li>
						Group_By - grouping key
					</li>
				</ul>
				</li>
			</ul>

		</description>
    <properties>
			<property name="rules" type="com.ataccama.dqc.tasks.experimental.dqi.Rule[]" required="true">
				An array of rules.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="defaultErrorAssignments" type="com.ataccama.dqc.tasks.experimental.dqi.ErrorAssignment[]" required="false">
				Default error assignments to be performed when the record is not valid for this rule.
			</property>
			<property name="groupBy" type="string" required="false">
				Definition of grouping.
			</property>
			<property name="outputAllRecords" type="boolean" required="true">
				Indicates to output records valid for rules. Records thar are not valid for any rule
				are always sent to output. On contrary, records that don&#39;t match any rule (when condition
				is false for all rules) are always discarded.
			</property>
			<property name="codeColumn" type="string" required="false">
				Name of the column where to write code of the applied rule.
			</property>
			<property name="tableNameColumn" type="string" required="false">
				Name of the column where to write table name of the applied rule.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.parse.DataFormatParameters">
    <introduction>
			<p align="justify">
				Data format parameters are parameters used for data formatting when an
				internal/external data format conversion is required. This task typically
				occurs when [branding:product.name.abbreviation] needs to load data from an external file or needs to store
				data to an external file. Data format parameters then describe how
				to convert data to the desired form based on the reading and writing file data formats.
			</p>
			<p align="justify">
				Processing steps supporting DataFormatParameters (DFP) can define DFP at the top level
				of a step as well as on the &quot;local&quot; level of each column. If there are no
				DFP defined on the local level, the global DFP are used. If global data format parameters
				are not defined, the default values are assumed. When a column defines its own DFP,
				this DFP must contain all attributes needed for successful parsing (those attributes
				must be assigned valid values). The only exception to this rule is
				<code>Thousands Separator</code>.
				In contrast with the rest of DFP attributes that must always have some value,
				<code>Thousands Separator</code> may remain empty (meaning that no thousands
				separator is used).
			</p>
		</introduction>
    <description>

			<strong>Information about formatting dates</strong>

				<p align="justify">
					For datetime and date types there is an existing output format defined. This format definition is given by a
					textual string that follows the convention used in the Java
					<a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html" target="_blank">SimpleDateFormat</a>.
				</p>
				<p align="justify">
					The meanings of the most used characters in the formatting string are as follows:<br/>
					y ... year, M ... month in year, d ... day in month. By changing the number of those
					formatting characters it is possible to change the meaning of the characters. <br/>
					NOTE: the formatting string is case sensitive, so the same character has different
					meaning when used as upper or lower case.
				</p>
				<p align="justify">
					Reading a year:<br/>
					If the formatting string contains more than two characters, then the input number
					is interpreted as is, without accounting for the century.<br/>
					If the formatting string contains a shortened version (&quot;y&quot; or &quot;yy&quot;), then the input
					number is parsed against the current data where the resulting date is in the range -80, +20 years
					from the current date. It is important to note that the number of digits in the year must
					strictly comply with the number of its formatting characters. Otherwise, the year is
					read as specified in the input (for format &#39;..yy&#39; and input &#39;...765&#39; the
					resulting year is 765.
				</p>
				<p align="justify">
					Year output format:<br/>
					If the formatting string includes the &quot;yy&quot; form, then the year is transformed into 2 characters,
					otherwise it is formatted as the original number (including completion).
				</p>
				<p align="justify">
					Month output format:<br/>
					If the number of formatting characters for month is &gt;=3,
					then the output is the full month&#39;s name (for example, January), otherwise the output
					is represented by the number (so, for January, it is 1).
				</p>
				<p align="justify">
					Numerical output format: <br/>
					Numerical padding functionality dictates there must be at least as many characters representing the
					digits of the number as contained in the biggest number to be displayed. Shorter numbers
					are filled with zeroes from the left.
				</p>
				<p align="justify">
					When formatting numbers, a number is represented by a template containing the sequence
					of formatting characters. Each formatting character in the template represents one digit
					of the number. Usually it is not necessary to specify the number of digits in the
					template exactly (a number can have a different number of digits and will still be
					parsed correctly). The only exception is when there are two neighboring numbers to
					be parsed. In order to determine which character belongs to which number, the parsing
					templates are applied in their exact form (and therefore the number of characters in
					the template matters).
				</p>
				<p align="justify">
					Processing date from text:<br/>
					If at least 4 formatting characters are specified, then the
					full text form is used, otherwise the short form is used (or at least shortened -
					January/Jan, etc). For reading, the number of formatting characters does not matter
					and all forms are accepted.
				</p>
				<p align="justify">
					Example of input: &quot;yyyy-MM-dd&quot; - accepts input &quot;1970-01-01&quot; <br/>
					Example of output: &quot;d.M.yyyy&quot; - output is 1.1.1970
				</p>

			<strong>Information about parsing boolean values</strong>

				<p align="justify">
					It is possible to define an input/output format for types with the form
					&quot;true-text | false-text&quot;, where true-text (or false-text respectively) is the
					string representing <code>true</code> (or <code>false</code>) values. By default these
					values are set to &quot;true&quot; and &quot;false.&quot;
				</p>
		</description>
    <properties>
			<property name="dateFormatLocale" type="string" required="false">
				<p align="justify">
				Defines the locale for parsing non-numerical data (for example short forms of months in dates -
				e.g., Sep 18, 1999). The value is the same as the value of the corresponding locale in Java
				(for detail see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html" target="_blank">Java locales</a>).
				</p>
				Default value: <code>en_US</code> (English - United States)
			</property>
			<property name="dateTimeFormat" type="string" required="false">
				<p align="justify">
				Defines the format that should be used for processing &#39;datetime&#39; data. The template is
				based on <code>SimpleDateFormat</code>, which uses the Java convention.
				</p>
				Default value: <code>yyyy-MM-dd HH:mm:ss</code>
			</property>
			<property name="dayFormat" type="string" required="false">
				<p align="justify">
				Defines the format that should be used for processing &#39;date&#39; data. The template is based on
				<code>SimpleDateFormat</code>, which uses the Java convention.
				</p>
				Default value: <code>yyyy-MM-dd</code>
			</property>
			<property name="decimalSeparator" type="string" required="false">
				<p align="justify">
				Defines what character is used as the decimal separator.
				<strong>Escaped string property.</strong>
				</p>
				Default value: <code>.</code>
			</property>
			<property name="falseValue" type="string" required="false">
				<p align="justify">
				String value that represents a logical &#39;false&#39; value in the given data. The comparison is
				not case sensitive.
				</p>
				Default value: <code>false</code>
			</property>
			<property name="thousandsSeparator" type="string" required="false">
				<p align="justify">
				Defines the string that represents the thousands separator (used in numbers). A non-escaped
				character is expected. Numbers to be read do not need to contain this separator, but
				when the separator is present it is processed (stripped) accordingly. <strong>Escaped string property.</strong>
				</p>
				Default value: <code>,</code>
			</property>
			<property name="trueValue" type="string" required="false">
				<p align="justify">
				String value representing a logical &#39;true&#39; value in the given data. The comparison is not case
				sensitive.
				</p>
				Default value: <code>true</code>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.dqi.DataQualityIndicator">
    <introduction>Evaluates a set of boolean expressions and writes the results and a summary report.</introduction>
    <description>
			The step evaluates a set of named boolean expressions (rules) and writes the result to an output column and also creates a summary report.
			It contains rules which are types of coded boolean conditions. The other fields are not required for step functionality.
			The step works as follows:
			<ul>
				<li>
					Computes all rule conditions for each row from the input.
				</li>
				<li>
				    If at least one of the rules was evaluated to false then the <code>code</code> is
				    appended to the <code>explainedColumn</code>.
				</li>
				<li>
					Finally, it creates a report with as many rows as there are rules with the following
					columns:
				<ul>
					<li>
					   Name - name of the rule
					</li>
					<li>
					   Code - code from the rule
					</li>
					<li>
					   Short Description - short description of the rule
					</li>
					<li>
					   Description - description of the rule
					</li>
					<li>
					   Success Count - number of input rows where all rules were evaluated to true
					</li>
					<li>
					   Total - number of input rows
					</li>
				</ul>
				</li>
			</ul>
		</description>
    <properties>
			<property name="rules" type="com.ataccama.dqc.tasks.dqi.DQIRule[]" required="true">
				An array of rules.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="explainedColumn" type="string" required="true">
				Codes of rules which were evaluated to false are appended to this column.
				If there was some non-null value in the input record in this column then
				the codes are appended to this value.
			</property>
			<property name="outRecordsFilterType" type="com.ataccama.dqc.tasks.dqi.RecordsOutFilterType" required="true">Specification of which records are sent to the output.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.datasampler.DataSamplerAlgorithm">
    <introduction>Creates a representative data sample.</introduction>
    <description>
			This step is used to obtain a representative data sample from input data.
			It computes sizes of groups of records with the same keys. For each cluster of same-sized groups
			it selects a number of groups based on the percentage given. The sample groups are selected
			uniformly from the cluster in order to obtain a uniform data distribution across the whole
			input data source. At least one entire group is selected even the percentage
			is too low to cover at least one whole group.
			More grouping rules can be defined to be applied to the records.
			Same-sized groups within a cluster can optionally be sorted.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="groups" type="com.ataccama.dqc.tasks.experimental.datasampler.DataSamplerGroup[]" required="true">
			A list of group sorting/filtering properties.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.datasampler.DataSamplerGroup">
    <description>
		A data record group constructed using specified sampling criteria.
		</description>
    <properties>
			<property name="keyComponents" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
			A list of grouping keys.
			</property>
			<property name="name" type="string" required="true">
			The group name.
			</property>
			<property name="percentage" type="integer" required="true">
			Percantage of the selection.
			</property>
			<property name="sorting" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
			A list of keys used to sort groups with similar counts.
			</property>
			<property name="when" type="string" required="false">
			A condition expression used to apply grouping rules.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.DataTypeParameters">
    <properties>
			<property name="decimalPrecision" type="integer" required="true">Float Precision is the number of all digits (including also numbers after decimal point).</property>
			<property name="decimalScale" type="integer" required="true">Float Scale is the number of digits after decimal point.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.generator.beans.ColumnGeneratorDateFormat">
    <description>
			One possible format in <strong>ColumnGeneratorDate</strong>,
			optionally with frequency.
		</description>
    <properties>
			<property name="value" type="string" required="true">
				Date format.
				<p align="justify">Following table lists most useful tokens:</p>
				<table border="1">
					<th>
						<th>Token</th>
            <th>Description</th>
            <th>Example/range</th>
					</th>
					<tr>
            <td>yyyy</td>
            <td>year</td>
            <td>2015</td>
          </tr>
					<tr>
            <td>MM</td>
            <td>month</td>
            <td>01-12</td>
          </tr>
					<tr>
            <td>dd</td>
            <td>day</td>
            <td>01-31</td>
          </tr>
					<tr>
            <td>HH</td>
            <td>hour</td>
            <td>00-23</td>
          </tr>
					<tr>
            <td>mm</td>
            <td>minutes</td>
            <td>00-59</td>
          </tr>
					<tr>
            <td>ss</td>
            <td>seconds</td>
            <td>00-59</td>
          </tr>
					<tr>
            <td>SSS</td>
            <td>miliseconds</td>
            <td>000-999</td>
          </tr>
				</table>
				<p align="justify">See <a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html" target="_blank">documentation of SimpleDateFormat</a>
				</p>
			</property>
			<property name="frequency" type="integer" required="false">Format value frequency. If omitted defaults to 1.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.domain.DatetimeDomainAnalysis">
    <description>
			String or numeric values are tested whether contains date or date and time in some format.
			Well-known patterns like &quot;yyyy-mm-dd&quot; are checked. Numeric values are
			analyzed if conform to some sequence of date/time numbers (e.g. 20080312).
			In the end, numbers found in generic text are examined wheter conform some date/time
			component values in proper combination, e.g. can discover as date text like &quot;Born 1976, April 12th&quot;.
		</description>
    <properties>
			<property name="threshold" type="integer" required="true">
				Specifies minimal rate (in percent) of values containing date/datetime to be
				column assumed in datetime domain.
				<br/>Default = 80%.
			</property>
			<property name="active" type="boolean" required="true">
				Specifies whether the analysis will be performed.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.global.domain.DatetimeParams">
    <description>Parameters for Domain Analysis when you are trying to evaluate if the data contains date/time data types.</description>
    <properties>
			<property name="formats" type="string[]" required="false">Specifies date/time formats used for parsing.</property>
			<property name="invalidExamplesCount" type="integer" required="true">Number of distinct invalid results.</property>
			<property name="removeSpaces" type="boolean" required="true">This option remove spaces from input data.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.rjoin.StaticRefSourceConfig" name="com.ataccama.dqc.rjoin.DbRefSource">
    <description>
			Reference data is stored into database.
		</description>
    <properties>
			<property name="dataSource" type="string" required="true">
				Data source name.
			</property>
			<property name="name" type="string" required="true">
				Name of the reference repository. Used as common table name prefix.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.scheduler.persister.IRunResultPersister" name="com.ataccama.adt.scheduler.persister.DbStateResultPersister">
    <introduction>Stores execution information into a database.</introduction>
    <description>Stores execution information into a database.</description>
    <properties>
			<property name="dataSource" type="string" required="true">Name of the connection to the database where logs will be stored. The connection definition must be present in the Runtime Configuration.</property>
			<property name="dialectFile" type="string" required="true"> DB module descriptor file that describes the target database. Module files for the most commonly used databases are located at <code>&lt;DQC_HOME&gt;/db/modules</code>.</property>
			<property name="prefix" type="string" required="false">Prefix added to the names of DB persistence tables. Default value: <code>SCHDEF_</code>.</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.runtime.state.storage.IStateStorageProvider" name="com.ataccama.adt.runtime.state.storage.DbStateStorageProvider">
    <introduction>Stores information about workflow and its task states to a database.</introduction>
    <description>Stores information about workflow and its task states to a database.</description>
    <properties>
			<property name="dataSource" type="string" required="true">Name of the connection to the database where logs will be stored. The connection name must be present in Runtime Configuration.</property>
			<property name="dialectFile" type="string" required="true">DB module descriptor file that describes the target database. Module files for the most commonly used databases are located at <code>&lt;DQC_HOME&gt;/db/modules</code>.</property>
			<property name="prefix" type="string" required="false">Prefix added to the names of DB persistence tables. 
				<br/>Default value: <code>WISP_</code>
      </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.dbf.read.DbfFileReader">
    <introduction>Reads data from a DBF file.</introduction>
    <description>
			This step reads data from an input file representing a DBF (database) data source.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="true">
				Contains definitions of columns which will be read from the DBF file.
			</property>
			<property name="encoding" type="string" required="true">
				Encoding of the input file.
			</property>
			<property name="fileName" type="string" required="true">
				Name of the <code>.dbf</code> file.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.security.DefaultSecurity">
    <introduction>Similar to <strong>No Security</strong>, can be used for demo and development.</introduction>
    <description>Similar to <strong>No Security</strong>, can be used for demo and development.</description>
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.DependencyAnalysis$Dependant">
    <introduction>
		Specifies the dependant and the threshold for assuming it depends on the determinant.
		</introduction>
    <properties>
			<property name="expression" type="string" required="true">
			Expression for dependant value.
			</property>
			<property name="threshold" type="integer" required="true">
			Percentage threshold - for a particular determinant value, the dependant of relevant records
			can take several values. The most frequent dependant value (modus) has to be included in at least
			<code>threshold</code> percent of relevant records to assume to be dependent.
			<br/>For example, for 90% threshold and 25 records having a particular determinant value,
			at least 23 records of them must have the same dependant to be assumed dependent
			(23/25 = 92% still satisfies the threshold 90%).
			<br/>The value should be at least 50%.
			<br/>Default = 90%.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.DependencyAnalysis">
    <introduction>
			Specifies analysis of dependencies between given key
			(determinant) and one or
			more expressions (dependants).
		</introduction>
    <description>
			Dependency Analysis discovers whether values of Dependants (selected
			columns or expressions) depend on the value of a Determinant (one or
			more columns combined into a single key).
			Each group of records with
			the same Determinant value is examined and if
			the most frequent
			Dependant value is present in at least
			<code>Threshold</code>
			percent of records, the whole group is considered to be dependent.
			Otherwise the whole group is violating the dependency.
			<br/>
			Records with NULL Determinant value are not analyzed.
		</description>
    <properties>
			<property name="name" type="string" required="false">
				Descriptive
				name for this analysis.
			</property>
			<property name="determinant" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
				Defines determinant value. It may consist of several
				components.
			</property>
			<property name="dependants" type="com.ataccama.dqc.tasks.profiling.config.DependencyAnalysis$Dependant[]" required="true">
				One or more dependants to analyze.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.config.EwfVariables$EwfDerivedVariable">
    <description>Derived variable. Use derived variables to calculate a value of a particular data type (depending on the result of the expression) before the workflow is started without user input. The values of these variables are &quot;hard-coded&quot; when the variables are defined. Derived variables are a convenient way for defining a value in one place and using it in different tasks across the workflow. If a change is necessary, it needs to be done just once.</description>
    <properties>
			<property name="name" type="string" required="true">
			Variable name.
			</property>
			<property name="expression" type="string" required="true">
			Variable expression.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.addresses.commons.model.components.EntityComponent" name="com.ataccama.dqc.addresses.commons.model.components.DictionaryEntityComponent">
    <description>
    		Entity component that validates the values against the dictionary.
    	</description>
    <properties>
            <property name="matchingValue" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="false">
                Definition of matching value for this component&#39;s dictionary.
                If the definition is missing, then definition from parent reference data
                is used. <br/>
                Default value: undefined (i.e. use definition from 
                <strong>reference data definition</strong> configuration element).
    		</property>
    	<property name="id" type="string" required="true">
	        	Identifier of the component.
	        </property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.DictionaryLookupBuilder">
    <introduction>Compiles the source of reference data for the Dictionary Lookup Identifier.</introduction>
    <description>
			Generates reference data from a single input stream. NOTE: it removes the old content 
			of the reference data folder.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="referenceData" type="com.ataccama.dqc.addresses.commons.model.etalon.ReferenceDataDefinition" required="true">
				Specification of the reference data.
			</property>
      		<property name="componentMappings" type="com.ataccama.dqc.addresses.commons.model.components.ComponentMapping[]" required="false">
      			Mapping of reference data entity components to columns.
      		</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.DictionaryLookupIdentifier">
    <introduction>Parses and identifies the input against reference data and creates proposals.</introduction>
    <description>
			Identifier that uses dictionary based lookups. Identifies the input record possibly down to 
			its primary key. It writes address proposals determined during the processing
			into a dedicated output endpoint (out_proposals).
			
			The step proceeds as follows:<br/>
			<ul>
			<li>
				Examines input stream - it searches for occurrences of known values
				of the reference data component. Uses dictionaries defined in the reference data.
			</li>
			<li>
				Matches the found values with supporting vectors and performs
				lookups into indices for proposals. Note that each vector might 
				match input values more than once - there exist &quot;variants&quot; of
				matching input to the vector.
			</li>
			<li>
				Each vector from step 2 possibly returns a bulk of proposals. Each bulk is
				processed independently - each proposal is compared with input
				and scored by means of user defined scoring and the proposal with the best
				score is selected as the best proposal. If there is a proposal with a 
				score less than or equal to the predefined value (see SupportingVectorDefinition),
				it is selected as the result and no more vectors are processed.
				When comparing proposal components with input text approximately,
				spaces occurring between two letters of different types (such as
				between a dot and a letter) can be missing in the input text and such
				cases are NOT considered as an error (no scoring case can be triggered by this
				situation).
			</li>
			<li>
				If required, reduces proposals to be rated (and then processed in the subsequent steps).
			</li>
			<li>
				Calculates rate of the input.
			</li>
			<li>
				Writes results to output. If required, limits number of proposals written to the 
				<code>out_proposals</code> end point.
			</li>
			</ul>
			
			Note: each vector may map onto the input string more than once. See
			the description of SupportingVectorCase. 
		</description>
    <properties>
			<property name="referenceData" type="string" required="true">
				Name of the folder where reference data are located. Reference data metadata
				are being read from the .metadata file located directly in that
				folder. The folder must exist.
			</property>
	        <property name="outPattern" type="string" required="false">
	        	Name of the column (type STRING) where the pattern corresponding
	        	to the best matching input record should be written.
	        </property>
	        <property name="outComponentPattern" type="string" required="false">
	        	Name of the column (type STRING) where the pattern consisting 
	        	only of components corresponding to the best matching input record should be written.
	        </property>
	        <property name="outSupportingVectorName" type="string" required="false">
	        	Name of the column (type STRING) where the name of the supporting
	        	vector that has been used for finding the address/proposal should be written.
	        </property>
	        <property name="componentOutputMapping" type="com.ataccama.dqc.addresses.commons.model.components.ComponentMapping[]" required="false">
	        	Array of component mappings from identified address to record columns.
	        </property>
	        <property name="components" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentUsage[]" required="true">
	        	Definition of component usage. 
	        </property>
	        <property name="abbreviationsFilename" type="string" required="false">
	        	Name of the file holding the string lookup dictionary with common abbreviations.
	        	The file name is NOT relative to the reference data folder.
	        </property>
	        <property name="outProposalCount" type="string" required="false">
	        	Name of the column (type INTEGER) where the number of proposals found
	        	and written out for the input address should be written. This number will always
	        	be the same as number of proposals written to the <code>out_proposals</code> endpoint.
	        </property>
	        <property name="inputLayout" type="com.ataccama.dqc.tasks.addresses.dictionary.InputLayout" required="true">
	        	Definition of input elements forming data to identify.
	        </property>
	        <property name="score" type="string" required="false">
	        	Name of the column (type INTEGER) where the score of the input entity should be written.
	        </property>
	        <property name="explanation" type="string" required="false">
	       		Name of the column (type STRING) where the explanation of the score for the input entity should be written.
	       	</property>
  	 		<property name="scoring" type="com.ataccama.dqc.tasks.addresses.dictionary.model.evaluation.Scoring[]" required="false">
				Definition of scoring rules.
			</property>
			<property name="supportingVectorCases" type="com.ataccama.dqc.addresses.commons.model.SupportingVectorCase[]" required="true">
				Defines which vectors to use and under which conditions.
			</property>
			<property name="maxScoreToAcceptVector" type="integer" required="true">
				Defines the maximum value of the score for the best proposal of the currently 
				processed supporting vector case to accept this result and stop
				further processing of vector cases.
				This is default for all vector cases.
				Default value: 0.
			</property>
			<property name="expertSettings" type="com.ataccama.dqc.tasks.addresses.dictionary.ExpertDLISettings" required="true">
				Expert settings of the step. Here, &quot;internal&quot; properties such as input search method, 
				proposal evaluation method, etc. can be modified.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
			<property name="limitOutputProposals" type="com.ataccama.dqc.tasks.addresses.dictionary.ProposalCount[]" required="false">
				Definition of limitation expressions for reducing proposal count written into <code>out_proposals</code> endpoint.
				These elements are scanned one by one possibly stopping at the first
				one whose <code>when</code> condition is evaluated to TRUE. Its
				<code>limit</code> expression is then used as maximum number
				of proposals that can be written to <code>out_proposals</code> endpoint. 
			</property>
			<property name="limitRatedProposals" type="com.ataccama.dqc.tasks.addresses.dictionary.ProposalCount[]" required="false">
				Definition of limitation expressions for reducing number of proposals to be rated and then sent to output 
				(however <code>limitOutputProposal</code> is still effective).
			</property>
			<property name="ratings" type="com.ataccama.dqc.tasks.addresses.dictionary.model.evaluation.RatingCase[]" required="false">
				Definition of rating cases. All cases are evaluated.
			</property>
    	<property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.DictionaryLookupReader">
    <introduction>
			Reads given dictionary and creates row for each entity.
		</introduction>
    <description>
			This step is intended for reading data from the dictionary for which source data are not
			available or to check that the dictionary has been generated as requested.
		</description>
    <properties>
			<property name="dictionaryFolder" type="string" required="true">
				Folder containing the dictionary.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.addresses.commons.model.components.EntityComponent" name="com.ataccama.dqc.addresses.commons.model.components.DictionaryRegularExpressionComponent">
    <description>
   			Dictionary entity component that not only validates against the dictionary,
   			but also parses through a provided regular expression.
    	</description>
    <properties>
      		<property name="pattern" type="string" required="true">
      			Regular expression to search with.
      		</property>
      		<property name="template" type="string" required="true">
      			Template that defines how to recompose the value to be matched against the dictionary.
      			The template uses strings and the $n construct to put either the desired string or
      			group matched during regexp matching. Group are numbered from 1.
      			Example: PSC might be defined as (\d\d\d)[]?(\d\d), so the template will
      			be $1$2 to remove the possible space. To place either $ sign into the result,
      			escape it with a backslash character (\). The whole matched string is available
      			as $&amp;.
      		</property>
            <property name="matchingValue" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="false">
                Definition of matching value for this component&#39;s dictionary.
                If the definition is missing, then definition from parent reference data
                is used. <br/>
                Default value: undefined (i.e. use definition from 
                <strong>reference data definition</strong> configuration element).
            </property>
    	<property name="id" type="string" required="true">
	        	Identifier of the component.
	        </property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.diff.DiffAlgorithm">
    <introduction>Joins two separate data flows into a single data flow (vertical merge). Related to Join step, optimized to identify differences in 2 <strong>similar</strong> data flows.</introduction>
    <description>
			<p align="justify">This step joins two separate input data flows into a single output data flow based on corresponding input data flow keys. The data entry points (endpoints) are named respectively <code>in_left</code> and <code>in_right</code>. All data input flows (<code>in_left</code> and <code>in_right</code>) must contain columns with key values (primary keys), which are defined as column properties <code>leftKey</code> and <code>rightKey</code>. The keys govern how the data records are paired up across the data input flows. All basic data types can be used as a key.
			</p>
			<p align="justify">The step is optimized to identify differences in 2 similar data flows (i.e., the data has to be more or less ordered). Using Diff step in its use case (ordered data) brings the following advantages over the Join step:
				<ul>
					<li>Efficiency. The step looks for a match in the window defined by the buffer property, not in the whole data set.
					</li>
					<li>Specificity. Diff step sends each record to the output exactly once, even when multiple records match. Join step in this case outputs Cartesian product of all matching records.
					</li>
					<li>Diff step is non-blocking. To join the data flows, Join step needs to read all the records; Diff starts outputting data immediately. If it finds a match, it will output it straightaway. If it does not, it will output the record after reading buffer number of records.
					</li>
				</ul>
			</p>
			<p align="justify">Note: Make sure the data is ordered, otherwise the step does not find matches.
			</p>
			<strong>The step behavior:</strong>
		<br/>1. Read buffer number of records from left and right input data flows.
		<br/>2. Compare the records: use <code>leftKey</code> and <code>rightKey</code> values to determine whether left and right records are the same:
					<ul>
					<li>If the records match, put them on the output and return to step 1.</li>
					<li>If the records do not match, compare the <code>orderColumns</code>: loop up through <code>Buffer</code> records on the side of the record with higher <code>orderColumn</code> value and compare them with the other record:
						<ul>
							<li>If match is found, put it on output and remove the used record from the buffer.</li>
							<li>If match is not found, put the record with lower order column on the output (the one from the side that was not looped through) and remove it from the buffer.</li>
						</ul>
					</li>
					</ul>
			<br/>3. Return to step 1.
		<p align="justify">If the data input flow contains multiple records with the same key values, the data output flow contains the matched records (not a Cartesian product of data input records as the Join step does).</p>
<p align="justify">Records having a null key value are not joined with any other (null-keyed) records and are processed as unpaired.</p>
<p align="justify">Note: Only data defined in the expression property of the <code>columnDefinition</code> properties are written to the output. If the property <code>columnDefinitions</code> is empty or missing, then the output remains empty.
</p>
    </description>
    <properties>
			<property name="bufferSize" type="integer" required="true">Buffer is used to set the size of the window (number of records) in which the step will search for a match.</property>
			<property name="columnDefinitions" type="com.ataccama.dqc.tasks.merge.ColumnDefinition[]" required="false">Defines output data. Contains a set of <code>columnDefinition</code> properties which define operations executed on the conjuncted input data. The content of the output data is the result of expressions operated on the conjuncted input data.</property>
			<property name="id" type="string" required="false">Step identification string.
</property>
			<property name="leftKey" type="com.ataccama.dqc.tasks.common.components.Key" required="true">
        <p align="justify">Column that contains key values of the left (first) input flow. The keys are used to decide whether the left and right records are the same.
</p>
        <p align="justify">The key can be defined as a composite key.</p>
      </property>
			<property name="leftOrderColumn" type="string" required="false">Values in this column are used to order the records within the buffer window. Typically a timestamp, or an order of the records.</property>
			<property name="rightKey" type="com.ataccama.dqc.tasks.common.components.Key" required="true">
        <p align="justify">Column that contains key values of the left (first) input flow. The keys are used to decide whether the left and right records are the same.
</p>
        <p align="justify">The key can be defined as a composite key.</p>
      </property>
			<property name="rightOrderColumn" type="string" required="false">Values in this column are used to order the records within the buffer window. Typically a timestamp, or an order of the records.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.unify.config.UnifyOperation$DiscardedIdsSpecification"/>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.DomainAnalysis">
    <introduction>This is an analysis to determine the likely type of the data in each column (whether the data is text, a number or a date, for example). The probable types are listed, along with exceptions (such as a text string found in a list of dates).</introduction>
    <properties>
			<property name="customDomainNames" type="string[]" required="false">Custom domains that you can define and use in Domain Analysis.</property>
			<property name="datetimeAnalysis" type="boolean" required="true">Date Time Analysis</property>
			<property name="enumAnalysis" type="boolean" required="true">Enumeration Analysis</property>
			<property name="numericAnalysis" type="boolean" required="true">Numeric Analysis</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.DomainAnalysisCfg">
    <description>
			Domain analysis are rules that will be applied on all columns to discover
			business meaning of theirs values.
		</description>
    <properties>
			<property name="datetime" type="com.ataccama.dqc.tasks.profiling.domain.DatetimeDomainAnalysis" required="true">
				Specifies discovering date or datetime values coded as string.
			</property>
			<property name="numeric" type="com.ataccama.dqc.tasks.profiling.domain.NumericDomainAnalysis" required="true">
				Specifies discovering numeric values coded as string.
			</property>
			<property name="enum" type="com.ataccama.dqc.tasks.profiling.domain.EnumDomainAnalysis" required="true">
				Discovering that column acquires limited number of values.
			</property>
			<property name="specval" type="com.ataccama.dqc.tasks.profiling.domain.SpecvalDomainAnalysis" required="true">
				Discovering that column acquires one or a few values significantly more frequently
				than is common.
			</property>
			<property name="pattern" type="com.ataccama.dqc.tasks.profiling.domain.PatternAnalysis" required="true">
				Analysing that string values conform to a few patterns.
			</property>
			<property name="customs" type="com.ataccama.dqc.tasks.profiling.domain.CustomDomainAnalysis[]" required="false">
				List of used defined rules.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.global.domain.DomainParams">
    <description>Domain analysis are rules that will be applied on all columns to discover business meaning of theirs values. </description>
    <properties>
			<property name="customDomainParams" type="com.ataccama.one.profiling.linear.simple.params.global.domain.CustomDomainParams[]" required="false">Custom Domain Parameters</property>
			<property name="datetimeParams" type="com.ataccama.one.profiling.linear.simple.params.global.domain.DatetimeParams" required="true">Parameters for Date and Time</property>
			<property name="enumParams" type="com.ataccama.one.profiling.linear.simple.params.global.domain.EnumParams" required="true">Enumeration Parameters</property>
			<property name="numberParams" type="com.ataccama.one.profiling.linear.simple.params.global.domain.NumberParams" required="true">Number Parameters</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.timeseries.settings.ModelSettings" name="com.ataccama.dqc.tasks.ai.timeseries.settings.DoubleExponentialSmoothingSettings">
    <introduction>
            Double exponential smoothing.
        </introduction>
    <description>
            s(t) = alpha * x(t) + (1 - alpha) * (s(t-1) + b(t-1))
            <br/>
            b(t) = beta * (s(t) - s(t-1)) + (1 - beta) * b(t-1)
            <br/>
            prediction: F(t+m) = s(t) + m * b(t)
        </description>
    <properties>
            <property name="settings" type="com.ataccama.dqc.tasks.ai.timeseries.settings.ExponentialSmoothingSingleParameterSettings[]" required="true">
                <strong>Alpha</strong> - Alpha values to try in the grid search.
                <br/>
                <strong>Beta</strong> - Beta values to try in the grid search.
            </property>
        <property name="active" type="boolean" required="true">
                If this model should be used in the grid search.
            </property>
    </properties>
  </class>
  <class name="com.ataccama.epp.dqc.steps.DqitImportMode">
    <description>
		</description>
  </class>
  <class name="com.ataccama.dqc.tasks.common.data.table.DuplicityHandleType">
    <introduction>
			Specifies handling of duplicate keys. Duplicity in both key and data in additional columns
			(identical rows) is not assumed as duplicit key and redundant rows are ignored.
		</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.expressions.DynamicExpressionAssigner">
    <introduction>
			Algorithm similar to <strong>Column Assigner</strong>
			but the source expressions contains expression that are dynamically evaluated.  
		</introduction>
    <properties>
			<property name="assignments" type="com.ataccama.dqc.tasks.expressions.DynamicExpressionAssigner$Assignment[]" required="false">
				List of assignments.
			</property>
			<property name="cacheSize" type="integer" required="false">
				Size of cache storing compiled expressions.
				<br/>Default = 10.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.parquet.EParquetCompression">
    <description>
			<p align="justify">
				Defines compression type to be used when writing file in parquet format.
			</p>
		</description>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.simpledatasampler.ESimpleDataSampler">
    <introduction>
			Type of data sampling.
		</introduction>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfExistFileOperation">
    <introduction>Verifies the existence of a source file/folder.</introduction>
    <description>Verifies the existence of a source file/folder.</description>
    <properties>
			<property name="sourceFile" type="string" required="true">Path to the source file or directory. The task fails when the source does not exist.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.encoding.columns.EncoderFeatureConfig">
    <introduction>Configuration of features used to preform the encoding transformation.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be present in model file.
            </property>
            <property name="sourceColumn" type="string" required="true">
                Data input column for encoding transformation.
            </property>
            <property name="resultColumn" type="string" required="true">
                Output column, where the result of encoding transformation will be outputted to. Can be equal to source column.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.encoding.columns.EncoderFeatureTrainerConfig">
    <introduction>Configuration of features used for normalization.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be used in classification step.
            </property>
            <property name="sourceColumn" type="string" required="true">
                Data input column for training the encoding model.
            </property>
            <property name="resultColumn" type="string" required="false">
                When filled, the trained model will do encoding on the source column and output it into result column.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.nlp.EnglishStemmer">
    <introduction>Performs stemming of input in English language.</introduction>
    <description>
            <p align="justify">Step uses Porter algorithm, originally published in Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14, no. 3, pp 130-137,
      </p>
            <p align="justify">Publicly available at:
                <code>http://tartarus.org/martin/PorterStemmer/def.txt</code>
      </p>Step uses adapted implementation of Porter algorithm available at:
            <code>http://tartarus.org/martin/PorterStemmer/java.txt</code>
            <p align="justify">Stemming a word is conducted in several steps. After each step, the current word form is searched in user defined lookup. If the form is found in lookup, the stemming process stops. When no lookup file is supplied, all stemming steps are performed.</p>
            <p align="justify">Optional tokenizer may be configured to process composed records. The tokenization is done only for internal use. A record is tokenized, tokens are stemmed seprarately and then reassembled to one record. All non-alphabetic characters are passed through without any change.</p>
    </description>
    <properties>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="inputColumn" type="string" required="true">Column that contains the input text. To properly stem multiple words in a record, configurable tokenizer should be used.</property>
            <property name="outputColumn" type="string" required="true">Column for stemmed output.</property>
            <property name="lookupFile" type="string" required="false">Lookup file used for checking partial stems.</property>
            <property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="false">Configurable Tokenizer configuration.</property>
            <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.addresses.commons.model.components.EntityComponent">
    <introduction>
			Definition of the component. This is the base definition common to all entity
			component types (see dictionary entity component, regular expression entity
			component, etc.).
		</introduction>
    <properties>
			<property name="id" type="string" required="true">
	        	Identifier of the component.
	        </property>
	    </properties>
  </class>
  <class name="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference">
    <description>
			References an entity component.
		</description>
    <properties>
			<property name="id" type="string" required="true">
				ID of the referenced component.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.addresses.commons.model.components.EntityComponentUsage">
    <introduction>
  			Definition of how the component is to be used.
  		</introduction>
    <properties>
  			<property name="id" type="string" required="true">
  				Component id.
  			</property>
  			<property name="input" type="boolean" required="true">
  				Indicates whether to explain the given component (search in the input text).<br/>
  				Default value: false.
  			</property>
  			<property name="mapToNumber" type="boolean" required="true">
  				Indicates that this component holds numbers so that any number found
  				in the input text is searched in this component&#39;s dictionary. Use only
  				for dictionary components.
  				<br/>
  				Default value: false. 
  			</property>
  			<property name="approximativeInputErrorLimit" type="integer" required="true">
  				Maximum string distance of component value to be accepted as found in input text.<br/>
  				Default value: 0.
  			</property>
  			<property name="approximativeInputErrorRatio" type="float" required="true">
  				Relative <code>Approximative Input Error Limit</code>. Relative to dictionary value length.<br/>
  				Default value: 1.0.
  			</property>
  			<property name="approximativeExplainErrorLimit" type="integer" required="true">
  				Maximum string distance of component value to be accepted as explained in input text.<br/>
  				Default value: 0.
  			</property>
  			<property name="approximativeExplainErrorRatio" type="float" required="true">
  				Relative <code>Approximative Explain Error Limit</code>. Relative to dictionary value length.<br/>
  				Default value: 1.0.
  			</property>
  		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.relation.EntityInput">
    <description>
			Specifies populating of entity records on output by informations about
			key cardinality on both sides.
			It is meaningful only when relevant output endpoint is connected.
		</description>
    <properties>
			<property name="localCountColumn" type="string" required="false">
				Name of the integer column storing the number of records in this input
				with the same key as the current record. For example, a record with unique keys
				will have a 1 in this column, and a record with a null key will a have 0.
			</property>
			<property name="relationCountColumn" type="string" required="false">
				Name of the integer column storing the number of records in the other input
				with the same key as the current record.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.domain.EnumDomainAnalysis">
    <description>
			Discovers that number of distinct values is small and probably belongs to
			some given set.
		</description>
    <properties>
			<property name="valueCountLimit" type="integer" required="true">
				Maximum number of distinct values.
				<br/>Default = 20.
			</property>
			<property name="active" type="boolean" required="true">
				Specifies whether the analysis will be performed.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.global.domain.EnumParams">
    <description>Enumeration Parameters</description>
    <properties>
			<property name="distinctValuesLimit" type="integer" required="true">Specifies the limit when input data are considered to be an enumeration data type. If the data will pass over this limit input data are no longer considered to be enumeration data type.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.io.jdbc.writer.ErrorAction">
    <description>
			<p align="justify">
				Note that when setting <code>Error Action</code> to <code>ROLLBACK</code> or
				<code>ROLLBACK_AND_STOP</code> it is possible that the step	may end up with an
				exception if it is not possible to set <code>autocommit</code> to off
				for the	respective database connection. Nevertheless, for now, it seems to be a
				specific problem of some types of ODBC connections (writing to Excel files, for
				example). On all other connections it is possible to disable <code>autocommit</code>
				and therefore it is safe to set up the &quot;rollback&quot; <code>Error Action</code>.
			</p>
		</description>
  </class>
  <class name="com.ataccama.dqc.tasks.io.collibra.write.CollibraWriterErrorHandler$ErrorAction"/>
  <class name="com.ataccama.dqc.tasks.experimental.dqi.ErrorAssignment">
    <properties>
			<property name="column" type="string" required="true">
				What column to assign.
			</property>
			<property name="expression" type="string" required="true">
				Expression controlling when assign to the column.
			</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.io.error.ErrorFixType">
    <description>
			<p align="justify">
				This class defines actions to be taken as a response to the ErrorType reported.
				Each error must have some action associated with it in order to define a valid
				<strong>error handling strategy</strong>.
			</p>
		</description>
  </class>
  <class name="com.ataccama.dqc.io.jdbc.writer.ErrorHandler">
    <description>
			Error handling element that defines the behavior of the step in case of writing problems.
		</description>
    <properties>
			<property name="errorAction" type="com.ataccama.dqc.io.jdbc.writer.ErrorAction" required="true">
				Defines the action to take when an error occurs.
			</property>
			<property name="errorReporting" type="com.ataccama.dqc.io.jdbc.writer.ErrorReporting" required="true">
				Defines the style of error reporting.
			</property>
			<property name="errorFieldName" type="string" required="true">
				Specifies the name of the column that will be added to the input record format containing
				the error explanation as returned by the database.
			</property>

		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.io.error.ErrorHandlingStrategy">
    <description>
			<p align="justify">
				The error handling strategy defines the behavior of steps in case of error.
				This strategy consists of a set of
				<strong>ErrorInstructions</strong>
				that instruct the step how to behave in case of each type of error.
				See	<strong>ErrorInstructions</strong>
				for more details.
			</p>
			<p align="justify">
				The following table shows all possible error statuses:
				<table border="1">
					<th>
						<th>State</th>
						<th>Description</th>
					</th>
					<tr>
						<td>SHORT_LINE</td>
						<td>Input line is too short or contains fewer fields than expected.</td>
					</tr>
					<tr>
						<td>EXTRA_DATA</td>
						<td>Input line is longer or contains more fields than expected.</td>
					</tr>
					<tr>
						<td>LONG_LINE</td>
						<td>Input line exceeds the maximum allowed length specified in the configuration.</td>
					</tr>
					<tr>
						<td>UNPARSABLE_FIELD</td>
						<td>Input field contains data which cannot be converted to the specified data type.</td>
					</tr>
					<tr>
						<td>INVALID_DATE</td>
						<td>Input field contains data which cannot be parsed as date or datetime.</td>
					</tr>
					<tr>
						<td>PROCESSING_ERROR</td>
						<td>Other error during parsing data.</td>
					</tr>
				</table>
			</p>
		</description>
    <properties>
			<property name="errorInstructions" type="com.ataccama.dqc.tasks.common.io.error.ErrorInstruction[]" required="false">
				List of error instructions.
			</property>
			<property name="rejectFileName" type="string" required="false">
				Name of the file that will be used for rejected data records.<br/>
				Default value: <code>rejected.txt</code>.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.io.error.ErrorInstruction">
    <introduction>
			The error instruction describes how to process certain errors with regards to data records
			and processing. An error instruction consists of an
			<strong>error type</strong> to handle and an
			<strong>action</strong> to take if such
			error occurs. For each error type some error-handling action must be defined.
		</introduction>
    <description>
			<p align="justify">
			The following table shows the meaning of instructions that may be created as combinations
			of error types and error actions to be taken:
				<table border="1">
					<th>
						<th>Error State</th>
            <th>Action</th>
            <th>Description</th>
					</th>
					<tr>
						<td>any</td>
            <td>SKIP_LINE</td>
											   <td>will cause skipping of the line that causes the
											   error from processing</td>
					</tr>
					<tr>
						<td>any</td>
            <td>STOP</td>
											   <td>causes data loading interrupt</td>
					</tr>

					<tr>
						<td>SHORT_LINE</td>
            <td>NULL_VALUE</td>
											   <td>
              <code>null</code> entry is written to
											   		the output</td>
					</tr>
					<tr>
						<td/>
            <td>READ_POSSIBLE</td>
										       <td>values possible to parse will be written to
										       the output, the rest will have <code>null</code>
										       values</td>
					</tr>
					<tr>
						<td>UNPARSABLE_FIELD</td>
            <td>NULL_VALUE</td>
										       <td>
              <code>null</code> will be written to the
										       output field</td>
					</tr>
					<tr>
						<td/>
            <td>READ_POSSIBLE</td>
										       <td>
              <code>null</code> will be written to the
										       output field</td>
					</tr>
					<tr>
						<td>INVALID_DATE</td>
            <td>NULL_VALUE</td>
										       <td>
              <code>null</code> will be written to the
										       output field</td>
					</tr>
					<tr>
						<td/>
            <td>READ_POSSIBLE</td>
										       <td>the result of processing
										       with <code>lenient=on</code> is written to the result
										       </td>
					</tr>
					<tr>
						<td>PROCESSING_ERROR</td>
            <td>NULL_VALUE</td>
										       <td>
              <code>null</code> values are written to the
										       		output field</td>
					</tr>
					<tr>
						<td/>
            <td>READ_POSSIBLE</td>
										       <td>values that have been parsed before the error
										       occurred are written to the output, for the rest
										       of values <code>nulls</code> are written to the output</td>
					</tr>
				</table>
			</p>
			<p align="justify">
				Any entries that cause an error can be written to a log file and/or excluded from further
				processing. By default the <code>errorHandlingStrategy</code> is set up
				as follows:
				<table border="1">
					<th>
						<th>Error</th>
            <th>Log</th>
            <th>Reject</th>
            <th>Fix Type</th>
					</th>
					<tr>
						<td>PROCESSING_ERROR</td>
            <td>X</td>
            <td/>
            <td>STOP</td>
					</tr>
					<tr>
						<td>INVALID_DATE</td>
            <td>X</td>
            <td/>
            <td>READ_POSSIBLE</td>
					</tr>
					<tr>
						<td>UNPARSABLE_FIELD</td>
            <td>X</td>
            <td/>
            <td>NULL_VALUE</td>
					</tr>
					<tr>
						<td>SHORT_LINE</td>
            <td>X</td>
            <td>X</td>
            <td>READ_POSSIBLE</td>
					</tr>
					<tr>
						<td>EXTRA_DATA</td>
            <td>X</td>
            <td/>
            <td>READ_POSSIBLE</td>
					</tr>
					<tr>
						<td>LONG_LINE</td>
            <td>X</td>
            <td>X</td>
            <td>STOP</td>
					</tr>
				</table>
			</p>
		</description>
    <properties>
			<property name="dataStrategy" type="com.ataccama.dqc.tasks.common.io.error.ErrorFixType" required="true">
				Specifies what action to take when this instruction is invoked.
			</property>
			<property name="errorType" type="com.ataccama.dqc.tasks.common.io.error.ErrorType" required="true">
				The error type to handle. Error types vary from step to step, each step
				may define its own error types that must be handled. For each error type there must
				be an error strategy defined which describes how to process it. For possible error
				types to handle see the step&#39;s description.
			</property>
			<property name="putToLog" type="boolean" required="true">
				Defines whether to record the error in the excecution log. Unless otherwise specified
				(see <strong>logging</strong>), log data is written to the console window.
				Messages coming from error handling strategies are prefixed with the text <code>EHS</code>.
			</property>
			<property name="putToReject" type="boolean" required="true">
				Defines whether to put the data causing the error in the &#39;reject file&#39;.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.io.jdbc.writer.ErrorReporting">
    <description>
			Defines how the step will report problems.
			The <code>WARNING</code> or <code>ERROR</code> log message is issued only once per step run.
		</description>
  </class>
  <class name="com.ataccama.dqc.tasks.common.io.error.ErrorType">
    <description>
			This class defines possible error types that may occur during processing of input/output
			data. <br/>
		</description>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.global.sampling.SamplingParams" name="com.ataccama.one.profiling.linear.simple.params.global.sampling.EveryNthItemSamplingParams">
    <introduction>Every Nth item will be sampled.</introduction>
    <properties>
			<property name="n" type="integer" required="true">Nth item.</property>
			<property name="startWithFirst" type="boolean" required="true">Starts with first item.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.adt.file.operations.IEwfFileOperationTask">
    <properties/>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfSendMailTask$EwfSendMailTaskAttach">
    <description>Path to the attachment relative to the workflow file.</description>
    <properties>
			<property name="attachFile" type="string" required="true">Path to the attachment relative to the workflow file.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfSendMailTask$EwfSendMailTaskRecipient">
    <description>Recipient of the email: a valid email address.</description>
    <properties>
			<property name="recipient" type="string" required="true">Recipient of the email: a valid email address.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.adt.core.EwfTaskAcceptMode">
    <description>Available types of accept mode.</description>
  </class>
  <class name="com.ataccama.adt.internal.core.runtime.services.EwfTaskResourceRequestBean">
    <description>Task resource requirements. See Workflow Resource Management for more information.</description>
    <properties>
			<property name="id" type="string" required="true">
			Resource identification string.
			</property>
			<property name="units" type="integer" required="true">
			Number of resource units required by the task.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.config.EwfVariables">
    <description>Variables.</description>
    <properties>
			<property name="derived" type="com.ataccama.adt.config.EwfVariables$EwfDerivedVariable[]" required="false">
			Derived variables. Use derived variables to calculate a value of a particular data type (depending on the result of the expression) before the workflow is started without user input. The values of these variables are &quot;hard-coded&quot; when the variables are defined. Derived variables are a convenient way for defining a value in one place and using it in different tasks across the workflow. If a change is necessary, it needs to be done just once.
			</property>
			<property name="input" type="com.ataccama.adt.config.EwfVariables$EwfInputVariable[]" required="false">
			Input variables. Use input variables to pass a value to the workflow before the workflow is started. All input variables are considered to be of a data type STRING.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.ExactAddressIdentifier">
    <introduction>
			Parses input value and identifies an address. It assumes that all component
			values form the address. It performs neither heuristics nor approximations.  
		</introduction>
    <description>
			The algorithm parses input text given as an expression and tries to 
			find the address defined in the reference data. It uses components exactly as parsed
			(i.e. it performs no approximations on input values or no heuristics
			based on component relation) and searches for address id in internal
			index lookups.<br/>
			Patterns are organized into groups and the algorithm parses them one by one
			potentionally stopping when (for a group) either only one address 
			or several different addresses are found. In other cases the algorithm
			continues with the next group.<br/>
			In ideal case, the algorithm returns address id, pattern name, group name, 
			reference address components and parsed address components. 
			If there are multiple address ids available, it returns only common 
			value (the same for all addresses or null) for each component 
			(for both, parsed and clean components). 
		 	Pattern name is returned only if there is exactly one address, whereas
		 	group name is returned only if the address can be determined or is
		 	ambiguous (since processing stops after parsing particular group).
		 	<br/>
		 	Note that the algorithm always needs value of postal code
		 	and one or both numbers (LRN and/or SN) for successful identification.
		 	According to data it might need to have other components (locality part, 
		 	locality and street). It doesn&#39;t use municipality part (CITY_PART - městská část),
		 	district (DISTRICT - okres) nor post office to find address id.
		 	<br/>
		 	The identification process needn&#39;t to use all pased components, however,
		 	all of them are used in verification that the address contains them.
		</description>
    <properties>
			<property name="addressExpression" type="string" required="true">
				Expression evaluating into string that is to be examined. Must evaluate
				into a value of type <code>STRING</code>.
			</property>
			<property name="referenceFolder" type="string" required="true">
				Path to the reference data folder containing compiled &quot;UIR-ADR&quot; 
				files extended with this algorithm&#39;s specific indices. Reference data
				can be generated with 
				<strong>UirAdrGenerator</strong> algorithm 
				(property <code>generateExactIndices</code> must be turned on). 
			</property>
			<property name="replacements" type="com.ataccama.dqc.tasks.addresses.uiradr.Replacement[]" required="false">
				Partial and full replacement files for particular components if required.
				There replacements will be applied on parsed component values for both,
				standardization with reference data and &quot;typing errors&quot; correction. 
			</property>
			<property name="patternGroupName" type="string" required="false">
				Name of the column, where to store name of the group. Expected column
				of type <code>STRING</code>.
			</property>
			<property name="parserRuleName" type="string" required="false">
				Name of the column, where to store name of the pattern. Expected column
				of type <code>STRING</code>.
			</property>
			<property name="outputComponents" type="com.ataccama.dqc.tasks.addresses.ExactAddressIdentifier$ComponentOutputSet" required="true">
				Definition of output columns where to store result.
			</property>
			<property name="patternGroups" type="com.ataccama.dqc.tasks.addresses.parser2.AddressPatternGroup[]" required="false">
				Definition of pattern groups.
			</property>
			<property name="components" type="com.ataccama.dqc.tasks.addresses.components.LookupComponent[]" required="false">
				Definition of user components that can be used in patterns - these
				components match text against reference data only - the data
				is not processed later in searching for address id.				
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
      		<scoringKey name="EAI_NO_PATTERN">
      			Input text doesn&#39;t match any of the patterns.
      		</scoringKey>
      		<scoringKey name="EAI_NOT_FOUND">
      			Address either cannot be determined due to invalid combination
      			of components or there is at least one component whose value
      			doesn&#39;t conform to the address determined from others.
      		</scoringKey>
      		<scoringKey name="EAI_NO_EXACT_RESULT">
      			Address cannot be determined due to ambiguity - there are 
      			multiple addresses determinable using input components and
      			there are no other components that can help select the right address.
      		</scoringKey>
			<scoringKey name="EAI_ADDRESS_AMBIGUOUS">
				There were multiple patterns in a group which determined different
				addresses (each pattern returned only one).
			</scoringKey>
      		<scoringKey name="EAI_FOUND">
      			Input text represents one address.
      		</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.msoffice.excel.read.ExcelFileReader">
    <introduction>Reads data from an Excel format file (.xls or .xlsx).</introduction>
    <description>
			Reads rows of table from one sheet of an Excel spreadsheet file.
			<p align="justify">
				The step is able to read from new Office 2007 file format (OOXML format, extension .xlsx).
			</p>
		</description>
    <properties>
		 	<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="fileName" type="string" required="true">
				Name of the input file.
			</property>
			<property name="sheet" type="integer" required="false">
				Number of the sheet in the file from which data will be read
				(numbering is zero-based, so the first sheet is numbered 0).
				<br/>Ignored if <code>Sheet Name</code> is specified.
				<br/>Default value: 0.
			</property>
			<property name="sheetName" type="string" required="false">
				Name of sheet in the file from which data will be read.
				<br/>Default value: the parameter <code>Sheet</code> is used.
			</property>
			<property name="startCell" type="string" required="true">
				Specification of the first row and column of the input portion of the sheet.
				Use the traditional cell reference form [column letter][row number].
				<br/>Default value: &#39;A1&#39;.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="true">
				Contains definitions of the columns that will be read from the input file.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
			<property name="skipEmptyRows" type="boolean" required="true">
				Indicates whether rows which contain no data should be ignored.
				<br/>Default value: false (all rows including empty will be sent to output).
			</property>
			<property name="useModelApi" type="boolean" required="true">
				Reading large file may cause memory leak when using underlying model API for it.
				When this is unchecked, efficient reading method instead model API is used.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.msoffice.excel.write.ExcelFileWriter">
    <introduction>Writes data into a Microsoft Excel file (*.xls or *.xlsx).</introduction>
    <description>
			Creates a new, or writes to an existing, Excel file and fills the specified sheet with rows of data.
			<p align="justify">
				The step is able to create or write into new Office 2007 file format (see property <code>Excel 2007</code>),
				but the condition described in <strong>ExcelFileReader</strong>
				has to be satisfied.
			</p>
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="fileName" type="string" required="true">
				Name of the output file.
			</property>
			<property name="templateFile" type="string" required="false">
				Name of input file. The content of this file is copied (and possibly changed by input) into output file.
				This allows to have prefilled some sheets, charts, calculations etc
				which will be then applied to written data.
			</property>
			<property name="templateFormulaRecalculate" type="boolean" required="true">
				The formulas contained in template will have been recalculated before saving of output file.
				<br/>Default = true.
			</property>
			<property name="inputs" type="com.ataccama.dqc.tasks.msoffice.excel.write.ExcelSheetInput[]" required="true">
				List of sheets and related inputs. It is possible to simultaneously write into more sheets.
			</property>
			<property name="dateFormat" type="string" required="false">
				Specifies an optional format for date values stored in the sheet.
				Use the format according to <a href="http://support.microsoft.com/kb/264372/" target="_blank">this specification</a>
				(see the paragraph &quot;Custom Number Formats&quot;. For example, &quot;d.m.yyyy&quot;.)
				<br/>Default: the implicit format is used.
			</property>
			<property name="excel2007" type="boolean" required="true">
				Specifies the new Office 2007 file format should be created.
				<br/>Default = false.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.msoffice.excel.write.ExcelSheetInput">
    <properties>
			<property name="inputName" type="string" required="true">
				Name of input endpoint from which the rows will be written.
			</property>
			<property name="sheet" type="integer" required="false">
				Number of the sheet in file into which the data will be written
				(numbering is zero-based, so the first sheet is numbered 0).
				<br/>Ignored if <code>Sheet Name</code> is specified.
				<br/>Default value: 0.
			</property>
			<property name="sheetName" type="string" required="false">
				Name of the sheet in the file into which data will be written.
				<br/>Default value: the parameter <code>Sheet</code> is used.
			</property>
			<property name="clearSheet" type="boolean" required="true">
				Specifies whether the existing sheet from the template file
				should be cleared before filling it with input rows.
				If this parameter is not set and the template sheet contains some data,
				only a portion of cells (depending on <code>Start Cell</code>
				and the number of rows and columns in the input) will be overwritten.
				<br/>Default value: false.
			</property>
			<property name="startCell" type="string" required="true">
				Specification of the first row and column of the area of the sheet to be written.
				Use the traditional cell reference form [column letter][row number].
				<br/>Default value: &#39;A1&#39;.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
				A list of columns to be written to the database.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				Specifies whether to write out all columns as defined in the input format. This attribute is exclusive
				to column definitions. If this value is set to on, then there must be no columns defined
				in the columns element, otherwise an error is reported.
			</property>
			<property name="writeHeader" type="boolean" required="true">
				Specifies whether to write the column&#39;s header to the output file.<br/>
				A header line is not written by default.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfSqlTask">
    <introduction>Executes an SQL Query.</introduction>
    <description>Executes an SQL Query. The task does not process the possibly returned result in any way, therefore it is suitable for commands returning no result, such as inserts, updates, etc.</description>
    <properties>
			<property name="connectionName" type="string" required="true">Connection name to use for query invocation. Connection names are taken from Runtime Configuration.</property>
			<property name="query" type="string" required="true">Query to execute.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.ExecutionEngine">
    <description>Selects the data processing engine (MapReduce or Spark) to run plans on a cluster.</description>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.ExpertDLISettings">
    <introduction>
    		Definition of expert settings for the dictionary lookup identifier.
    		These settings generally don&#39;t need to be configured for the identifier to
    		work properly and serve primarily to boost performance and/or quality in
    		certain cases.
    	</introduction>
    <properties>
    		<property name="inputSearchMethod" type="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ISearchMethodDefinition" required="true">
    			Definition of the input text examination method. The input text is scanned 
    			for instances of known values.
    		</property>
      		<property name="evaluatorDefinition" type="com.ataccama.dqc.tasks.addresses.dictionary.evaluation.IProposalEvaluatorDefinition" required="false">
      			Definition of the method that evaluates and compares the input text with proposals.
    			Default value: <strong>single component element evaluator</strong>.
      		</property>
      		<property name="advancedScoring" type="boolean" required="true">
      			Indicates to use additional scoring pseudo inputs (z,d,x).<br/>
      			Default value: false.
      		</property>
      		<property name="approximativeSearchImmediately" type="boolean" required="true">
      		    Deprecated property. It has no effect.
      		</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.timeseries.settings.ExponentialSmoothingSingleParameterSettings">
    <properties>
            <property name="min" type="float" required="true">
                Minimum value (inclusive) for given parameter.
            </property>
            <property name="max" type="float" required="true">
                Maximum value (inclusive, if <code>Number Of Steps</code> is at least 2) for given parameter.
            </property>
            <property name="numberOfSteps" type="integer" required="true">
                Number of parameter values between <code>Min</code> and <code>Max</code> bounds.
            </property>
        </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorExpression">
    <description>
			Column value is result of expression. Useful for constant or use random() function to generate random numbers or strings.
			Example: <code>&quot;room &quot; + random(1, 99)</code>.
		</description>
    <properties>
			<property name="expression" type="string" required="true">
				An expression whose result is assigned to the output.
				For a list of all available expressions and their definitions, refer to <strong>Expressions</strong>.
			</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.unify.repository.ExtendedRepositoryReader">
    <introduction>Reads data from repository used by <strong>Extended unification</strong>.</introduction>
    <description>
			This step reads all records from database repository used by extended unification step.
			The input timestamp, last update timestamp and unification keys can be read, too.
			<br/>
			Note: fetching of unification keys together with records slows performance, use
			it only when really needed.
		</description>
    <properties>
			<property name="dataSource" type="string" required="true">
				Name of the data source for connection to the database repository.
			</property>
			<property name="repositoryName" type="string" required="true">
				Name of the repository determining the table names in the database.
			</property>
			<property name="pkColumn" type="string" required="false">
				Column name that stores the primary key value.
			</property>
			<property name="keyColumn" type="string" required="false">
				Name of string column for storing the unification key values. This column usually
				contains all keys needed for fetching candidate groups of all unify operations
				(generally all operations using grouping), then the keys are specially serialized:
				Keys are separated by &quot;/&quot; character, this separator contained in key value itself
				is replaced by &quot;\-&quot;. For example, two keys &quot;0:1:840514/1457&quot; and &quot;2:0:John Smith\London&quot;
				containing these specials will be converted to string
				&quot;0:1:840514\-1457/2:0:John Smith\\London&quot;.
			</property>
			<property name="inputTimestampColumn" type="string" required="false">
				Name of datetime column for storing timestamp of record, when used.
			</property>
			<property name="updateTimestampColumn" type="string" required="false">
				Name of datetime column for storing last update timestamp.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnRef[]" required="false">
				Contains a set of repository columns that conforms output record. 
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.unify.ExtendedUnify">
    <introduction>
			Enables incremental and parallel processing of selected [branding:product.name.abbreviation] operations.
		</introduction>
    <description>
			<p align="justify">
			Some operations in [branding:product.name.abbreviation] are based on certain record groupings. These operations
			then need to hold complete groups of records. This involves the need to preserve all historical
			data to allow the collection of whole groups when only part of them comes to
			the input. The storage for the historical data is called the <em>Repository</em>.
			</p>
			<p align="justify">
			This step retrieves historical records and forms groups 
			of them from the repository, as well as storing them back. Moreover, this service manages
			coordination between several process running in parallel and ensures logical integrity
			of record groups concurrently updated in the repository.
			</p>
			<p align="justify">
			Supported operations are:
			<ul>
				<li>Unification, collecting groups of matching records</li>
				<li>Classification of groups</li>
				<li>Creating of representatives of groups</li>
				<li>Regrouping groups (adding next grouping level)</li>
				<li>General expression evaluating and assigning
					(not technically a group operation, but can be usable in cooperation with others)</li>
			</ul>
			</p>
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="primaryKeyColumn" type="string" required="false">
				Column containing a unique primary key of records.
				<br/>Not used when <code>Processing Mode</code> is <code>NONINCREMENTAL</code> or <code>(QUICK)IDENTIFY</code>.
			</property>
			<property name="minimumIdToAssign" type="long" required="true">
				Minimal value for newly assigned group ids. This parameter is related to all unification operations, which
				may assign new unique ids to candidate or  groups during processing. The real last assigned id is
				always stored in the repository and this value is only the lower limit for newly assigned ids.
				The minimal value is 1.
				<br/>Default value: 1.
			</property>
			<property name="directUpdate" type="boolean" required="true">
				Specifies that repository will be updated regardless to relationship of records. This improves performance but doesn&#39;t ensure
				consistency of repository in case of crash. Suitable especially for initial full-load. Implies exclusive access to repository (exclusiveMode=true) 
				<br/>Default value: False.
			</property>
			<property name="exclusiveMode" type="boolean" required="true">
				Specifies that only one batch can be processed at a time. Suitable for unification running as batch.
				When false, fully concurrent processing of (online) requests will be enabled.
				<br/>Default value: True.
			</property>
			<property name="processingMode" type="com.ataccama.dqc.unify.common.ProcessingMode" required="true">
				Specifies processing mode.
			</property>
			<property name="dataSource" type="string" required="false">
                Name of the data source for connection to the database repository.
				<br/>Mandatory when <code>Processing Mode</code> is not <code>NONINCREMENTAL</code>.
			</property>
			<property name="repositoryName" type="string" required="false">
				Name of the repository determining the table names in the database.
				<br/>Mandatory when <code>Processing Mode</code> is not <code>NONINCREMENTAL</code>.
			</property>
			<property name="readOnly" type="boolean" required="true">
				Specify that the repository will not be updated.
				<br/>Default value: False.
			</property>
			<property name="deleteFlagColumn" type="string" required="false">
				Boolean column or expression indicating whether the record must be removed from the repository.
			</property>
			<property name="timestampColumn" type="string" required="false">
				Datetime column containing an optional last record update time. The time comes from source external system.
			</property>
			<property name="processingStatusColumn" type="string" required="false">
				String column for storing a flag indicating if and how the record has changed in the repository.
				<br/>The flag can have the following values:
				<ul>
					<li>
            <code>A</code> - input record added to the repository</li>
					<li>
            <code>U</code> - input record updated in the repository</li>
					<li>
            <code>D</code> - input record deleted from the repository</li>
					<li>
            <code>R</code> - reloaded record changed in the repository</li>
					<li>
            <code>N</code> - reloaded record which has not changed</li>
					<li>
            <code>I</code> - identified input record (when processionMode=IDENTIFY)</li>
					<li>
            <code>X</code> - input record which is older than its repository image and has been discarded</li>
					<li>
            <code>Y</code> - input record which has an empty or duplicate primary key and has been discarded</li>
				</ul>
				If not specified, discarded older records which would obtain the flag &quot;X&quot;, are not sent to the output.
			</property>
			<property name="processingTimestampColumn" type="string" required="false">Datetime column for storing the time stamp when the record was written to the repository. The time can be used to synchronize target external system.</property>
			<property name="operations" type="com.ataccama.dqc.unify.config.IOperationConfig[]" required="false">
				List of operations.
			</property>
			<property name="outputStrategy" type="com.ataccama.dqc.unify.ExtendedUnify$OutputStrategy" required="true">
				Detailed specification of manner how the records will be sent to output.  
			</property>
			<property name="mapAllColumns" type="boolean" required="true">
				Specifies that all columns of input record format will be stored in the repository.
				Property <code>Repository Columns</code> must be empty when true.
				<br/>Default value: True.
			</property>
			<property name="repositoryColumns" type="com.ataccama.dqc.tasks.common.column.ColumnRef[]" required="false">
				List of columns stored in the repository. At least all columns needed for unification
				must be present.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.conditions.ExtractFilter">
    <introduction>Extracts records into separate data flow branches based on an expression.</introduction>
    <description>
		This step extracts records from the data flow. The output endpoint
		<code>out_extract</code> contains records satisfying the specified <code>Condition</code>.
		The output endpoint <code>out</code> contains all records.
		<br/>
	
		</description>
    <bindings>
		</bindings>
    <properties>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="condition" type="string" required="true">
			Condition that filters records for output &quot;out_extract&quot;.

			For a detailed description of the construction of expressions, please refer to the section
			<strong>expressions</strong>.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.Extremes">
    <introduction>Specifies the number of first and last values to be computed. If set to zero, extremes are not counted.<br/>
				Default value: <code>10</code>.</introduction>
    <properties>
			<property name="numberOfFirstValues" type="integer" required="false">Specifies number of first values that will be listed.</property>
			<property name="numberOfLastValues" type="integer" required="false">Specifies the number of last values that will be listed.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.ai.commons.steps.column.FeatureColumn">
    <introduction>A way how to parse feature from the column.</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.FeatureTransformation">
    <introduction>Transformations, that are done on this feature before using it for fitting the model.</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.avro.reader.FieldColumn">
    <properties>
		 	<property name="name" type="string" required="true">
		 	Name of column in the format of the output end point which is defined in the
		 	parent <code>RecordsOutput</code> configuration element.
		 	</property>
		 	<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
		 	Type of the column.
		 	</property>
		 	<property name="path" type="string" required="true">
		 	This is the Avro path to the primitive element whose value will be filled to this attribute column. The
		 	basics of Avro path are described in <code>Path</code>.
		 	In this case, there are two additional types of tokens that can be used in the path:
		 	<ul>
			 	<li>
			 		<code>..</code> - reference to the parent element.
			 	</li>
			 	<li>
			 		<code>.</code> - reference to the current element.
			 	</li>
		 	</ul>
		 	</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
					  See <code>Data Format Parameters</code> at the root level of the configuration.
    		  </property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfWaitForFileTask$FileApperMode">
    <description>If the value is set to &quot;appear&quot;, the task waits for a file appearance. If the value is &quot;disappear&quot;, the task waits for the file removal (i.e. some lock file).</description>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.IPasswordBasedIdentityProvider" name="com.ataccama.dqc.communication.auth.server.FileBasedIdentityProvider">
    <introduction>Retrieves identity information from the configuration file.</introduction>
    <description>Retrieves identity information from the configuration file. The provider uses the username and password provided in the request and (if defined in the configuration file) assigns roles.</description>
    <properties>
			<property name="configFile" type="string" required="true">Path (relative to the server configuration file) or absolute to the role assignment configuration file.</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.task.iterators.ITaskIterator" name="com.ataccama.adt.task.iterators.FileIterator">
    <introduction>Runs child workflows for all files in the <strong>Directory</strong>.</introduction>
    <description>Runs child workflows for all files in the <strong>Directory</strong>. When <strong>Iteration Type</strong> is set to SERIAL, the task iterates in the order corresponding to the alphabetical order of files specified in <strong>Directory</strong> and <strong>Mask</strong>.</description>
    <properties>
			<property name="directory" type="string" required="true">Location of files. The directory can be local, on Amazon S3 server and on HDFS (if your product package contains Big Data Engine).</property>
			<property name="iterableItem" type="string" required="true">Variable name, which will be passed to the child workflow (i.e. the same variable name should be defined in the child workflow as an input variable). The variable value will be the processed file name (including full path) in each iteration.</property>
			<property name="mask" type="string" required="true">File name mask used to select files to iterate over.
			<p align="justify">Supports the following wildcards:</p>
			<ul>
				<li>
            <code>?</code>: 1 character, except file separators &#39;/&#39; and &#39;\&#39;</li>
				<li>
            <code>*</code>: 0…N characters, except file separators &#39;/&#39; and &#39;\&#39;</li>
			</ul>
			</property>
			<property name="order" type="com.ataccama.adt.task.iterators.order.IOrder" required="false"> </property>
			<property name="parameterMapping" type="com.ataccama.adt.task.base.KeyValueMapping$Mapper" required="false">Set of user defined parameters to pass to the workflow as global variable values.</property>
			<property name="recursive" type="boolean" required="true">Files in all sub-directories of the directory are either used for iteration too (true) or not (false).</property>
			<property name="continueOnError" type="boolean" required="true">When file or folder information cannot be used, report to log and continue, do not fail the task.</property>
			<property name="condition" type="string" required="false">Expression evaluated for each candidate entry to check if it should be included in output or not. Supports following variables:
				<ul>
					<li>
            <code>name</code> (<code>string</code>) - filename of the item</li>
					<li>
            <code>fullName</code> (<code>string</code>) - full name of the item, contains complete path</li>
					<li>
            <code>isDirectory</code> (<code>boolean</code>) - true if item is directory, false otherwise (when it is file)</li>
					<li>
            <code>size</code> (<code>long</code>) - item size in bytes</li>
					<li>
            <code>timestamp</code> (<code>date/time</code>) - item last modified time</li>
				</ul>
				Note that not all filesystems return all the properties so some of them can be empty (<code>null</code>).
			</property>

		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.web.FileProviderComponent">
    <introduction>Enables access to the files in a server directory through HTTP.</introduction>
    <description>
      <p align="justify">Enables access to the files in a server directory through HTTP. If a file specified in the request exists, its content is sent in a response. The response depends on the file type:
			<ul>
				<li>for recognizable files (e.g., <code>.txt</code> or <code>.xml</code>), the browser displays the file content as a text</li>
				<li>for non-recognizable files (e.g., <code>.profile</code>), the browser offers to download the file</li>
			</ul>
			<p align="justify">For example, if HTTP Dispatcher contains definition of the <code>default</code> listener on the port 8888, setting the File Provider Component <strong>Listeners</strong> to <code>default</code> and <strong>Location</strong> to <code>files</code> exposes the files at http://myserver:8888/files. To enable access to files located in the <code>directory</code> folder, set <strong>Files Directory</strong> to <code>directory</code>: then, a request to http://myserver:8888/files/subdirectory/file.txt returns the content of <code>file.txt</code> from the <code>directory/subdirectory</code> folder.
			</p>
		</p>
    </description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="filesDirectory" type="string" required="false">Relative (to the server configuration file) or absolute path to the root directory of the exposed filesystem. You can access any file located in the <strong>Files Directory</strong> or its subfolders.</property>
			<property name="listeners" type="string" required="true">Comma-separated list of names of HTTP listeners where the service should be accessible.</property>
			<property name="location" type="string" required="true">Path to the location within the listener where the service will be accessible. The path has to start with slash, e.g., <code>/files</code>. </property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.rjoin.StaticRefSourceConfig" name="com.ataccama.dqc.rjoin.FileRefSource">
    <description>
			Reference data is stored in four files in specified folder.
		</description>
    <properties>
			<property name="folderName" type="string" required="true">
				Folder with reference files.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.IRoleMappingProvider" name="com.ataccama.dqc.communication.auth.server.FileRoleMapping">
    <introduction>Reads role assignment configuration from the file. The role is be assigned to the user if conditions defined in child elements are fulfilled.</introduction>
    <description>Reads role assignment configuration from the file. The role is be assigned to the user if conditions defined in child elements are fulfilled.</description>
    <properties>
			<property name="configFile" type="string" required="true">Path (relative to the server configuration file) or absolute to the role assignment configuration file.</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.scheduler.persister.IRunResultPersister" name="com.ataccama.adt.scheduler.persister.FileStateResultPersister">
    <introduction>Stores execution information into a <code>.sjr</code> file.</introduction>
    <description>Stores execution information into a <code>.sjr</code> file.</description>
    <properties/>
  </class>
  <class super="com.ataccama.adt.runtime.state.storage.IStateStorageProvider" name="com.ataccama.adt.runtime.state.storage.FileStateStorageProvider">
    <introduction>Stores information about workflow and its task states to a <code>.wis</code> file.</introduction>
    <description>
      <p align="justify">Stores information about workflow and its task states to a <code>.wis</code> file. Every workflow execution generates a new <code>.wis</code> file. The file contains information about current state of the workflow and all included tasks and is updated every time the status of any part of the workflow changes (e.g., a task is scheduled or executed).</p>
		<p align="justify">
			The file location is resolved with this priority:
				<ul>
					<li>Resources folder specified in Workflow Server Component.</li>
					<li>Resources folder specified in Runtime Configuration.</li>
					<li>The folder containing Server Configuration.</li>
				</ul>
		</p>
	</description>
    <properties/>
  </class>
  <class name="com.ataccama.adt.variables.read.IFileVariables">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.conditions.Filter">
    <introduction>Filters only records which pass the specified condition.</introduction>
    <description>
		Controls the processing of each data record and determines if the record can pass through
		in the data flow. Only data records that satisfy the given condition will be allowed to
		pass through.

		<p align="justify">
			For a detailed description of the construction of expressions, please refer to the section
			<strong>expressions</strong>.
		</p>
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="condition" type="string" required="true">
			Logical expression that controls record filtering.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property> 
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.IFilter">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.web.config.FilterBean">
    <description>
      <p align="justify">Defines the actions that have to be done for each incoming request. One example of a filter is logging of requests and responses, another is encryption of requests. Filters are applied on the incoming HTTP requests before they invoke the service itself.</p>
				<p align="justify">Every filter has its own parameters in the <strong>Mappings</strong> subsection with subelements that define conditions when the filter will be activated, such as which listener is used to accept the request, url prefix of the request and set of tests that must all succeed. If the <strong>Mappings</strong> are not specified, the filter will be mapped to all listeners and all requests.</p>
				<p align="justify">If the request conforms to several patterns, the filters will be applied in the order of appearance in the filters section.</p>
		</description>
    <properties>
			<property name="filter" type="com.ataccama.dqc.web.IFilter" required="true">Filter definition. Possible implementations: Request Response Time Logger, Logging Filter, Xslt Transform Filter.</property>
			<property name="mappings" type="com.ataccama.dqc.web.config.MappingBean[]" required="false">Filter mappings.</property>
		</properties>
  </class>
  <class name="com.ataccama.server.http.FilterChain">
    <description>Specify which filter (defined in servletFilters) should be used when accessing a location defined by <strong>path</strong> and the <strong>conditions</strong> that trigger the filters.</description>
    <properties>
			<property name="conditions" type="com.ataccama.server.http.IFilterChainCondition[]" required="false">Filters are applied only if all conditions are met. The following implementations are available: <strong>inetAddressCondition</strong>, <strong>requestHeaderCondition</strong>, <strong>requestParamCondition</strong>, <strong>soapActionCondition</strong>
      </property>
			<property name="filters" type="string" required="true">Comma-separated list of filters that should be applied to incoming requests. Use the names of filters that were defined in the <strong>servletFilters</strong> section. Use the <code>securityFilter</code> name to refer to the security filter for the context.</property>
			<property name="path" type="string" required="true">Mapping location of the filter chain.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.jms.JmsProviderComponentInstance$FilterMappingBean">
    <description>Limits the logging filter to specific connections and destinations. When no mapping (or mapping attribute) is present, the filter affects all connections and destinations.</description>
    <properties>
			<property name="connection" type="string" required="false">Connection name.</property>
			<property name="destination" type="string" required="false">Queue/Topic name.</property>
		</properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.Fingerprint">
    <introduction>Compressed information about all values in column.</introduction>
    <properties/>
    <scoring/>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.global.sampling.SamplingParams" name="com.ataccama.one.profiling.linear.simple.params.global.sampling.FirstItemsSamplingParams">
    <introduction>First Nth items will be sampled.</introduction>
    <properties>
			<property name="numberOfItems" type="long" required="true">Number of  first Nth items.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.io.gdr.reader.member.StructuredMemberBase" name="com.ataccama.dqc.tasks.io.gdr.reader.member.FixedIteration">
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.text.read.FixedWidthColumn">
    <description>
			Describes a single data column with fixed width (data length).
		</description>
    <properties>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				  Data format parameters used by the processing step. This definition overrides
				  globally defined DataFormatParameters.
				  Please refer to <strong>DataFormatParameters</strong>
				  for more details.
			</property>
			<property name="fillChar" type="string" required="false">
				Character that is used to fill remaining empty space in a field. These characters are
				trimmed from the field value (both start and end of the input string) and only the trimmed value is processed.
				Default: no trimming occurs and the whole input string is processed (space characters are trimmed by default).
			</property>
			<property name="name" type="string" required="true">
				Specifies the name of a column.
			</property>
			<property name="skip" type="integer" required="true">
				Specifies how many characters should be skipped after the end of the previous
				field. These &quot;skipped&quot; characters are not counted in in the <code>Width</code> value.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
				Data type of the column data.
			</property>
			<property name="width" type="integer" required="true">
				Width of the field in characters (field length).
			</property>
			<property name="ignore" type="boolean" required="true">
			    Indicates whether the column appears in the output record format. The default value is false.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.text.read.FixedWidthFileReader">
    <introduction>
			Reads data from a text file (possibly compressed) with a fixed-width delimiter.
		</introduction>
    <description>
			<p align="justify">
			A text file is expected as the input of this step, containing data presented line-by-line.
			Each line may contain several fields (columns) that are identified by their start
			position and length. Values are not separated by any separator, the data start and stop
			positions on the line are figured out from the current position (which depends on fields that
			have been read so far) and the column&#39;s attributes (<code>skip</code> and <code>width</code>).
			</p>
			<p align="justify">
				The step is capable of processing compressed files using either ZIP or GZIP format.
				When processing ZIP file, it searches for a file named after the archive itself (without the extension)
				or uses the only file present in the archive (regardless of its name).
			</p>
			<p align="justify">
			Similar to <strong>Text File Reader</strong>,
			this step supports all encodings
			supported by Java, including Unicode formats (supported Unicodes are: UTF-8, UTF-16,
			UTF-16BE, UTF-16LE). Input data is processed the same way (via a Unicode aware reader), allowing
			correct processing of all files including those ones with a Byte Order Mark (BOM) signature.
			More detailed information about supported encodings can be found in the
			<strong>Text File Reader</strong> step.
			</p>
			<p align="justify">
				The line structure is described by individual column definitions.
				Each column must define:
				<ul>
					<li>How many characters should be skipped from the previous field stop
						(those characters are considered as the separator) - this value is stored in the parameter
						<code>skip</code>
          </li>
			 		<li>how many characters define the value (attribute <code>width</code>)</li>
			 		<li>type of the data (attribute <code>type</code>)</li>
					<li>and possibly more configuration data for parsing (<code>DataFormatParameters</code>)
					</li>
				</ul>
				Values specified here are relative values from the end of the previous (last) field.
				The step computes absolute values from the sequence of fields, therefore the fields must be
				defined in an order matching the data record column order.
			</p>
			<p align="justify">
				Input data are processed utilizing parameters specified in the <code>Data Format Parameters</code>
				element. For a detailed description refer to
				<strong>DataFormatParameters</strong>.
			</p>
			<p align="justify">
				This step may produce the following errors: <code>SHORT_LINE</code>,
				<code>INVALID_DATE</code>, <code>UNPARSABLE_FIELD</code>,
				<code>LONG_LINE</code>, <code>EXTRA_DATA</code>,
				<code>PROCESSING_ERROR</code>.<br/>
				If a <code>SHORT_LINE</code> error occurs, the value given to further processing
				depends on the <code>SHORT_LINE</code> instruction&#39;s action. If the action is
				<code>NULL_VALUE</code> then <code>null</code> is passed to further parsing. If
				the action is <code>READ_POSSIBLE</code> then the returned value represents the value
				read from the field: it means either <code>null</code> if there were no data for the
				given field or a non-null value if data were present, but insufficient, in the
				field.
			</p>
			<p align="justify">
				Error management is defined by the element <code>Error Handling Strategy</code>.
				The error handling strategy allows the step to exclude incorrect records from processing, and such
				records can be sent to the &quot;rejected&quot; output file. For more information about error handling
				consult <strong>data parsing strategies</strong>.
			</p>

			<p align="justify">
			When creating a reject file, the following rules are observed:<br/>

			<ul>
				<li>The initial name for the reject file is <code>rejected.txt</code>.
				</li>

				<li>The encoding defined for the input data file is used as the encoding of the rejected file.
				</li>

				<li>The line separator defined for the input data file is used as the line separator.</li>

				<li>Every input row is written to the reject file at most once. So,
					even if there are more error fields in the same row whose instructions
					require writing to the reject file the row is written there only once.
				</li>

				<li>Empty reject files are not created. A reject file is created when
					an instruction requires writing to this file.
				</li>

			</ul>
			</p>


				The following example assumes that the input line consists of the following fields:
				<code>DATE</code>, <code>DATETIME</code> and <code>STRING</code> - configured as in the
				example below.<br/>
				<br/>
				Consider the following input data:<br/>
      <br/>
				<code>11.12.2001xxx12-10-2000 12:51+GMT0----|||***This is a test***</code>
				<br/>
      <br/>
				The processing ouput is (assuming that <code>DATETIME</code> uses the <code>yyyy-MM-dd HH:mm:ss</code>
				format,<code>DATE</code> uses <code>yyyy-MM-dd</code> formatting and the delimiter &#39;;&#39;):<br/>
				<br/>
				<code>2001-12-11;2000-10-12 12:51:00;This is a test</code>
      <br/>
		</description>
    <properties>
			<property name="columns" type="com.ataccama.dqc.tasks.io.text.read.FixedWidthColumn[]" required="true">
				Contains definitions of columns which will be read from the input file.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				Contains data formatting information for the whole step. For details refer to the
				<strong>DataFormatParamaters</strong> section.
			</property>
			<property name="encoding" type="string" required="true">
				Specifies encoding used in the input file.
			</property>
			<property name="errorHandlingStrategy" type="com.ataccama.dqc.tasks.common.io.error.ErrorHandlingStrategy" required="true">
				Definitions of error state management. Defines how to handle each error which
				can occur during processing. For a detailed description of error strategies see
				<strong>Error Handling Strategies</strong>.
			</property>
			<property name="fileName" type="string" required="true">
				Name of the input file to process.
			</property>
			<property name="compression" type="com.ataccama.dqc.tasks.io.compression.CompressionType" required="true">
				Defines compression type of the input file.<br/>
				Default value: NONE.
			</property>
			<property name="ignoredRowRegEx" type="string" required="false">
				A regular expression that is compared to lines in the input file. If a line (read as a string) matches the
				regular expression, the line will be ignored.
			</property>
			<property name="numberOfLinesInHeader" type="integer" required="true">
				Specifies the number of lines from the beginning of the file that will be excluded from
				processing (header lines, comments, etc).
			</property>
			<property name="numberOfLinesInFooter" type="integer" required="true">
				Specifies the number of lines from the end of the file that will be excluded from
				processing (footer lines).
			</property>
			<property name="lineMaxReadLength" type="integer" required="true">
				Specifies the maximum number of characters per line to be read and processed.
				If the length of the line exceeds this value, an error occurs.<br/>
			</property>
			<property name="lineSeparator" type="string" required="false">
				Specifies the string to be recognized as a line delimiter. The line delimiter
				can be any sequence of letters, although a specific symbol is often used
				which usually depends on the operating system where the file originated from.
				The special symbols are:  \r = CR, \l = LF, \n = LF.
				<br/>This parameter is not needed for files with a fixed line length. <strong>Escaped string property.</strong>
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.FkAnalysis">
    <introduction>
		Defines two keys on two inputs - left and right.
		The analysis checks whether the key can be considered a foreign key in relation between left and right input (entities).
		The result of analysis consists of three basic counters - the number of keys which are unique in the parent,
		the number of keys not unique in the parent and the number of keys not found in the parent. This means that the condition
		for foreign key quality is that the second and third counters are empty or very low.
		</introduction>
    <properties>
			<property name="name" type="string" required="false">
			Descriptive name of this analysis.
			</property>
			<property name="leftInputName" type="string" required="true">
			Name of input defined in the top level <code>inputs</code> element.
			This input is assumed to be the source of left entity data.
			</property>
			<property name="rightInputName" type="string" required="true">
			Name of input defined in the top level <code>inputs</code> element.
			This input is assumed to be the source of right entity data.
			</property>
			<property name="components" type="com.ataccama.dqc.tasks.profiling.config.FkComponent[]" required="true">
			Defines components of the analyzed key.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.FkComponent">
    <introduction>
		Defines one component of the key in foreign key analysis.
		</introduction>
    <properties>
			<property name="leftColumn" type="string" required="true">
			Column or expression specifying the component value obtained from the left input records (left entity).
			</property>
			<property name="rightColumn" type="string" required="true">
			Column or expression specifying the component value obtained from the right input records (right entity).
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.rjoin.RefSourceConfig" name="com.ataccama.dqc.rjoin.FlowRefSource">
    <description>
			Special case when second input flow provides reference data.
		</description>
    <properties>
			<property name="keys" type="com.ataccama.dqc.rjoin.SourceKey[]" required="true">
				Definitions of reference keys.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.server.interfaces.to.Folder">
    <description>Folder</description>
    <properties>
			<property name="path" type="string" required="true">Path to a folder.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.frequency.FrequencyAnalysisAlgorithm">
    <introduction>Creates a frequency analysis of input data.</introduction>
    <description>
				<p align="justify">
					Generates frequency analysis (a histogram), computes value counts
					in a given data set, either using all discrete values or using determined intervals.
					All data types supported by [branding:product.name.abbreviation] can be used.
				</p>
				<p align="justify">
				  This step can perform frequency analysis over multiple columns of input data in a single pass.
				</p>
				<p align="justify">This step has two outputs: statistical and data set.</p>
				<p align="justify">
					Statistical Output - output format of String
					[stat_name], String
					[stat_value/classification_label], String
					[record_count].
				</p>
				<p align="justify">
					The output data set has the same number of columns and records as the input data set.
				</p>
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="analyses" type="com.ataccama.dqc.tasks.analysis.frequency.Analysis[]" required="true">
			The root node for analyses.
			</property>
			<property name="defaultLocale" type="string" required="true">
			Locale definition representing a specific geographical, political, or cultural region,
			with respect to data parsing and comparison as performed by the step.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.ProfiledData$FrequencyAnalysis">
    <description>
			Specifies whether and how frequency counters of the given value set will be counted.
		</description>
    <properties>
			<property name="calculate" type="boolean" required="true">
			Specifies whether frequency or groupsize analysis should be performed.<br/>
			Default value: <code>true</code>
			</property>
			<property name="range" type="com.ataccama.dqc.tasks.profiling.config.RangeCfg" required="false">
			Range for a given interval. If not specified, discrete analysis will be used.
			For groupsize analysis, the intervals are related to sizes of groups, not the values themselves.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.FrequencyAnalysis">
    <introduction>It shows the number of times that each non-null frequency count is repeated. If all values are unique, the group size will be 1, as there are no duplicate values. Each time a value is repeated, it forms a new group.</introduction>
    <properties>
			<property name="distinctValuesLimit" type="integer" required="false">Specifies the limit when input data are considered to be an enumeration data type. If the data will pass over this limit input data are no longer considered to be enumeration data type.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.transliterate.FromColumnToColumn">
    <description>
			It declares a pair - an expression and an output column.
		</description>
    <properties>
			<property name="from" type="string" required="true">
			The input expression.
			</property>
			<property name="to" type="string" required="true">
			The output column.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="TLT_NULL">
				A scoring flag indicating that the input value was null.
			</scoringKey>
			<scoringKey name="TLT_CHANGED">
				A scoring flag indicating that the input value changed during applying of the rules.
			</scoringKey>
		</scoring>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.multi.IRandomRecordCountGeneratorConfig" name="com.ataccama.dqc.tasks.generator.multi.GaussianRecordCountGenerator">
    <description>
			Number of child records is random number from gaussian distribution with given <code>mean</code> and <code>standard deviation</code>.
			<p align="justify">
			Because gaussian distribution has no minimum or maximum, number of child records can be limited - 
			random number is generated until it is between <code>minRecordCount</code> and <code>maxRecordCount</code> (inclusive).
			Therefore it is wise to have <code>mean</code> between <code>minRecordCount</code> and <code>maxRecordCount</code> to avoid infinite loop.
			</p>
			<p align="justify">
			Unfortunately Java implementation of gaussian distribution is flawed so that with mean=0 and standardDeviation=1 generated numbers will be all between -6 and 6.
			</p>
		</description>
    <properties>
			<property name="mean" type="integer" required="true">
				Mean of gaussian distribution.
			</property>
			<property name="standardDeviation" type="integer" required="true">
				Standard deviation of gaussian distribution.
			</property>
			<property name="minimum" type="integer" required="true">
				Minimum number of child reocrds per one parent records.
			</property>
			<property name="maximum" type="integer" required="true">
				Maximum number of child reocrds per one parent records.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.gdr.reader.GenericDataReader">
    <introduction>Reads generic binary files.</introduction>
    <description>
			Reads a generic binary file. The format of the file has to be specified by the hierarchical configuration
			of this step - structures, fields, iterations etc. Each structured member (not a field) can
			be drawn out as an endpoint, enabling access to all its fields as columns (except filler types). It can also
			have additional shadow columns that are capable of referencing the data of parent structures by specifying
			their name as prefix (for instance &quot;parent.column&quot;). This hierarchical streams concept is similar to that of a
			<strong>XML Reader step</strong>.
		</description>
    <properties>
			<property name="fileName" type="string" required="true">Input file.</property>
			<property name="iterative" type="boolean" required="false">
				Controls if the input file is to be treated as a sequence of repeating data.
				Default value is: false.
			</property>
			<property name="streams" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IStructuredMember" required="true">Root of the hierarchical format structure.</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.reconcile.GlAccount">
    <introduction>Defines structure of account hierarchy.</introduction>
    <description>
			Each account in the calculation hierarchy is identified
			by its number. It can contain sub accounts whose values
			are added to this account&#39;s own values.
		</description>
    <properties>
			<property name="accountNumber" type="long" required="true">
				Account number
			</property>
      		<property name="name" type="string" required="true">
      			Name of the account
      		</property>
      		<property name="children" type="com.ataccama.dqc.tasks.experimental.reconcile.GlAccount[]" required="false">
      			Children of the account in the calculation hierarchy.
      		</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.config.EwfGroup">
    <description>Group</description>
    <properties>
			<property name="name" type="string" required="true">
			Group name.
			</property>
			<property name="taskIds" type="string[]" required="false">
			Task identifiers.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.select.Group">
    <description>
		Rule definition governing group creation. The key definition determines how records are grouped.
		</description>
    <properties>
			<property name="components" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
			List of composite fields for key creation used in group creation.
			</property>
			<property name="name" type="string" required="false">
			Group name.
			</property>
			<property name="results" type="com.ataccama.dqc.tasks.experimental.select.Result[]" required="false">
			Criteria list for group record selection.
			</property>
			<property name="when" type="string" required="false">
			Expression used to filter records by the defined key and assign them into specified group.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.aggregator.GroupAggregator">
    <introduction>Computes aggregated values for one or more sets of record groups.</introduction>
    <description>
			Produces output similar to using SELECT ... GROUP BY ... SQL statements.
			Each grouping is defined in the <code>Aggregation Sets</code> element which defines
			grouping key components and a set of aggregating expressions.
			Component values and aggregated results are collected into new output
			records which are sent to the <code>out_results</code> endpoint.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="aggregationSets" type="com.ataccama.dqc.tasks.analysis.aggregator.AggregationSet[]" required="true">
				Set of definitions of aggregation.
			</property>
			<property name="when" type="string" required="false">
				Condition for performing all aggregation calculations.
				Input record is ignored when evaluated as <code>false</code>.
				<br/>
				Default value = <code>true</code>.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.GroupAssigner">
    <introduction>Calculates aggregated expressions on group generated by a multiplicative step.</introduction>
    <description/>
    <properties>
			<property name="recordDescriptorColumn" type="string" required="true">
				Name of string input column in which special recordDescriptor is stored.
				The descriptor contans group id, group size and record number in group as
				three numbers separated by colon. For example <code>4152:3:2</code>.
			</property>
			<property name="assignments" type="com.ataccama.dqc.tasks.flow.AbstractGroupAssigner$Assignment[]" required="false">
				List of assignments that will be performed on each group record.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.timeseries.GroupByComponent">
    <properties>
            <property name="expression" type="string" required="true">
                Expression for grouping key components.
            </property>
            <property name="name" type="string" required="true">
                Name of output column storing the grouping key component value.
            </property>
        </properties>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.ILdapRoleResolver" name="com.ataccama.dqc.communication.auth.server.GroupByMemberResolver">
    <introduction>Tests if the group identified by the <strong>Base Path</strong> contains the authenticated user&#39;s distinguished name in the <strong>Attribute</strong> property.</introduction>
    <description>Tests if the group identified by the <strong>Base Path</strong> contains the authenticated user&#39;s distinguished name in the <strong>Attribute</strong> property. Difference from the Reverse Member Attribute Resolver: the search is recursive, starting from the node defined in the <strong>Base Path</strong> attribute.</description>
    <properties>
			<property name="attribute" type="string" required="false">Name of LDAP attribute that contains the distinguished name (identifier) of the signed in user.</property>
			<property name="basePath" type="string" required="false">All search queries in the LDAP source will be done in the subtree defined by this path.</property>
			<property name="dnAttribute" type="string" required="false">Sets the name of the attribute that stores the user&#39;s distinguished name. Defaults to &#39;distinguishedName&#39; as it is used by <code>ActiveDirectory</code>
      </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.GroupIdStrategy">
    <description>
			Parameters determines how group IDs will be assigned to changed candidate or matching groups.
			The newly composed group can contain none, one or more records signed as survivor in previous
			unification. Such survivor then determines, which ID the group aquires. 
		</description>
    <properties>
			<property name="recalculateSurvivor" type="boolean" required="true">
				The new merge survivor record of group is determined again in each unify.
				When false, original merge survivor is kept even the better record appears in group.
				This switch is usable only when <code>Use Pivot As Survivor</code> is false.
				<br/>Default: false.
			</property>
			<property name="degradeDeletedSurvivor" type="boolean" required="true">
				When the merge survivor is deleted, it will be used (and its group will keep
				their ID) only when no other non-deleted survivor appears in the group and moreover 
				it is the best of all other deleted survivors.
				<br/>Default: true.
			</property>
			<property name="substituteDeletedSurvivor" type="boolean" required="true">
				When the merge survivor is deleted, its ID will be used if another record with
				this ID can be selected as the best survivor. 
				<br/>Default: true.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.select.GroupSelectorEngine">
    <introduction>Creates samples of groups of records based on given criteria.</introduction>
    <description>
			<linkTarget id="GSE_desc"/>
			<p align="justify">
				This step creates groups of records based on specified key definitions.
				The step will select records from each group based on specified criteria.
				Records can be selected multiple times based on different criteria. The resulting
				records of selection criteria for each group may be dependent on sort order. For example when
				selecting the first N records, the sort order of the group determines which records will be selected.
			</p>
			<p align="justify">
			Selection/Grouping Methods:
			<table border="1">
				<tr>
            <td nowrap="nowrap">
              <term>all</term>
            </td>
            <td>
              <definition>
						Select all records of a group.
					</definition>
            </td>
          </tr>
				<tr>
            <td nowrap="nowrap">
              <term>min</term>
            </td>
            <td>
              <definition>
						Select the first N (<code>count</code>) records of a group.
					</definition>
            </td>
          </tr>
				<tr>
            <td nowrap="nowrap">
              <term>max</term>
            </td>
            <td>
              <definition>
						Select the last N (<code>count</code>) records of a group.
					</definition>
            </td>
          </tr>
				<tr>
            <td nowrap="nowrap">
              <term>median</term>
            </td>
            <td>
              <definition>
						Select the middle N (<code>count</code>) records of a group.
					</definition>
            </td>
          </tr>
				<tr>
            <td nowrap="nowrap">
              <term>proportional</term>
            </td>
            <td>
              <definition>
						Select N (<code>count</code>) uniformly distributed <code>count</code> records of a group.
					</definition>
            </td>
          </tr>
				<tr>
            <td nowrap="nowrap">
              <term>mincard</term>
            </td>
            <td>
              <definition>
						Select all group records where each group has at least N (<code>count</code>) records.
					</definition>
            </td>
          </tr>
				<tr>
            <td nowrap="nowrap">
              <term>maxcard</term>
            </td>
            <td>
              <definition>
						Select all group records where each group has at most N (<code>count</code>) records.
					</definition>
            </td>
          </tr>
			</table>
		</p>
		</description>
    <properties>
			<property name="groupName" type="string" required="false">
			Field storing the group name of the grouping criteria/rules.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="selectionName" type="string" required="false">
			Field storing the name of the selection criteria/rules.
			</property>
			<property name="commonResults" type="com.ataccama.dqc.tasks.experimental.select.Result[]" required="false">
			Default record selection criteria. These are applied for every group (defined by <strong>group rule</strong>).
			</property>
			<property name="defaultLocale" type="string" required="false">
			Locale represents a specific geographical, political, or cultural region, 
			with respect to data parsing and comparison as performed by the step.
			</property>
			<property name="groups" type="com.ataccama.dqc.tasks.experimental.select.Group[]" required="false">
			List or rules governing group creation.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod">
    <introduction>

		</introduction>
    <properties>
			<property name="when" type="string" required="false">
				Boolean condition for using the current grouping method.<br/>
				Default value: true.
			</property>
			<property name="pivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting the &quot;Pivot record&quot; from a set of candidates.
				A matching group is constituted of one pivot record and candidates which
				are near to the pivot record, i.e. which satisfy one of the matching rules.
			</property>
			<property name="maxIterations" type="integer" required="false">
				Maximum number of iterations of the matching group assigning process. Consequently,
				it is maximum number of matching groups in one candidate group.
			</property>
			<property name="mergeSurvivorSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting one &quot;Merge survivor record&quot;, which must be
				assigned for each newly created group (candidate or matching). This
				criterion is used when more than one prior MSR records occurs in group.
				<br/>Ignored when <code>Use Pivot As Survivor</code> is specified.
			</property>
			<property name="matchingRules" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Set of rules used for determining when a candidate record is near the pivot record
				and belongs to its matching group.
				<br/>Note: two records named &quot;pivot&quot; and &quot;candidate&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
			<property name="matchNearest" type="boolean" required="true">
				If specified, candidate will be assigned to matched group with minimal value of <code>Match Quality Expression</code>.
				If not specified, candidate will be assigned to matched group with the best pivot (default behavior). 
			</property>
			<property name="matchQualityExpression" type="string" required="false">
				Numeric (integer, long or float) expression that can be used to evaluate match quality of candidate record with it&#39;s pivot record.
				<br/>Similarly as in <code>Expression</code>
				compared records are referred by two dot-sources <code>pivot</code> and <code>candidate</code>.
				Results of <strong>Matching Measure</strong>
				referred via dot-source <code>measures</code> are accessible, too.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.GuessNameSurnameAlgorithm">
    <introduction>Parses and validates names.</introduction>
    <description>
			The step identifies a first name and a last name from specified data input. This identification and parsing is
			dependent on dictionaries that contain a list of known first names and last names (see the properties).
			<br/>
			It is also possible to specify that in case diacritics (accents) within the found first name or last name are different from the source
			value, then the original diacritics are retained (preserved).
			<br/>
			This step uses a parser to examine the input string. For more details about
			it please see the description of <strong>Pattern Parser</strong>.
			Besides standard components there are the following predefined ones available.
			These components are verified against corresponding dictionaries and can be configured by <code>Word Definition</code>, <code>Multi Word Definition</code>
			and <code>Interlaced Word Definition</code> properties.<br/>
			<ul>
				<li>
          <code>FIRST_NAME</code> - syntactically {WORD}.</li>
				<li>
          <code>LAST_NAME</code> - syntactically {WORD}.</li>
				<li>
          <code>FIRST_NAME_INTERLACED</code> - syntactically {INTERLACED_WORD}.</li>
				<li>
          <code>LAST_NAME_INTERLACED</code> - syntactically {INTERLACED_WORD}.</li>
				<li>
          <code>MULTI_FIRST_NAME</code> - syntactically {MULTIWORD}, word separator defined in <code>wordSeparators</code>.</li>
				<li>
          <code>MULTI_LAST_NAME</code> - syntactically {MULTIWORD}, word separator defined in <code>wordSeparators</code>.</li>
			</ul>
			Components <code>MULTI_FIRST_NAME</code> and <code>MULTI_LAST_NAME</code> consider following 
			word separators (parameter wordSeparators): <code>-&#39;`&quot;~</code>.
			<br/>
			For a multiplicative version of the step see
			<strong>Multiplicative Guess Name Surname</strong>
		</description>
    <properties>
			<property name="in" type="string" required="true">
				Column that contains both input first name and last name.
			</property>
			<property name="firstName" type="string" required="true">
				Column that stores the final output first name (corresponding to the dictionary value).
			</property>
			<property name="lastName" type="string" required="true">
				Column that stores the final output last name (corresponding to the dictionary value).
			</property>
			<property name="firstNameOrig" type="string" required="false">
				Column that stores the original (input) first name.
			</property>
			<property name="lastNameOrig" type="string" required="false">
				Column that stores the original (input) last name.
			</property>
			<property name="patternName" type="string" required="false">
				Column that stores the name of the applied parsing pattern.
			</property>
			<property name="hintName" type="string" required="false">
				Column that stores the name of the applied parsing pattern hint.
			</property>
			<property name="trash" type="string" required="false">
				Column that stores the trash information. Trash information is the part
				of the input text which was not recognized
				as a known component or, when the <code>Full Trash Scope</code> flag is true,
				text parsed by component not having its own output column <code>Store Parsed Into</code>.
				The binding is not mandatory, thus the property <code>Full Trash Scope</code>
				is effective only when this binding is set.
			</property>		
			<property name="components" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.Component[]" required="false">
				List of user defined components.
			</property>
			<property name="fullTrashScope" type="boolean" required="true">
				Specifies whether text parsed by components which don&#39;t define the <code>Store Parsed Into</code> parameter is
				stored in the column defined by the binding <code>Trash</code>. Text not parsed by any component is stored in any case.
				This parameter has an effect only if the binding <code>Trash</code> is defined.
				<br/>
				Default value: <code>False</code>.
			</property>
			<property name="firstNameLookupFileName" type="string" required="true">
				Dictionary file that contains known first names. This dictionary
				contains <strong>single-word</strong> first names.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="hints" type="com.ataccama.dqc.tasks.clean.config.Hint[]" required="false">
				Contains a list of definitions of parsing hints. A parsing hint defines how to parse input data when more than
				one parsing pattern is found which can be applied to the input string. It assists the step in picking
				the preferred parsing pattern in case of such ambiguity. In particular, hints are defined using property <code>hint</code>.
			</property>
			<property name="lastNameLookupFileName" type="string" required="true">
				Dictionary file that contains known last names. This dictionary	contains <strong>single-word</strong> last names.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="multiFirstNameLookupFileName" type="string" required="false">
				Dictionary file that contains known first names. This dictionary
				contains <strong>multi-word</strong> first names (multi-word components work with this dictionary).
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="multiLastNameLookupFileName" type="string" required="false">
				Dictionary file that contains known last names. This dictionary
				contains <strong>multi-word</strong> last names (multi-word components work with this dictionary).
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="patternGroups" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.PatternGroup[]" required="true">
				Tag associating the group of patterns <code>patternGroup</code>.
			</property>
			<property name="preserveIfDiffers" type="com.ataccama.dqc.tasks.clean.AbstractGuessNameSurnameAlgorithm$PreserveDifferentType" required="true">
				Defines whether the original value of the input firstname, lastname or both 
				should be retained if the final standardized value 
				(the selected dictionary value which conforms most closely
				with the original value) differs from the original value.
				The word &#39;differs&#39; here means that the values are different
				when compared for equality ignoring case but are the same when
				transformed by matching value generator defined by appropriate
				dictionary.<br/>
				Possible values: <code>PRESERVE_FIRSTNAME</code>, <code>PRESERVE_LASTNAME</code>,
				<code>PRESERVE_BOTH</code> and <code>PRESERVE_NONE</code>
        <br/>
				Default value: <code>PRESERVE_NONE</code>.
			</property>
			<property name="wordDefinition" type="string" required="true">
			  Default value: {WORD}
			</property>
			<property name="interlacedWordDefinition" type="string" required="true">
			  Default value: {INTERLACED_WORD}
			</property>
			<property name="multiWordDefinition" type="string" required="true">
			  Default value: {MULTIWORD:wordSeparators=&quot;-&#39;`&quot;&quot;~&quot;}
			</property>
			<property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Tokenizer Definition.
			</property>
			<property name="proposalSelectionStrategy" type="com.ataccama.dqc.tasks.clean.AbstractGuessNameSurnameAlgorithm$ProposalSelectionStrategy" required="true">
				Defines strategy to select from matched patterns.<br/>
				Possible values are:
				<ul>
					<li>DISTANCE_BASED selects only those patterns whose distance calculated over all matched names is the losest.</li>
					<li>FIRST_MATCH selects only the first matched pattern regardless of others.</li>
				</ul>
				Default value: <code>DISTANCE_BASED</code>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
    <scoring>
            <scoringKey name="NM_NO_PATTERN">
                A scoring flag indicating that input &quot;in&quot; contains a NULL value or that no appropriate names were found in the dictionary.
            </scoringKey>
            <scoringKey name="NM_PART_PATTERN">
                A scoring flag indicating that only appropriate part of the pattern was found for a particular part of the input string.
                (i.e., the input string conforms to one of the defined parsing patterns but only part of the string was verified using dictionaries).
            </scoringKey>
            <scoringKey name="NM_MORE_PATTERNS">
                A scoring flag indicating that more than one pattern that conforms to the input string was found.
            </scoringKey>
            <scoringKey name="NM_DIFFERENT">
                A scoring flag indicating that a pattern was found but its components do not conform precisely to the appropriate
                parts of the input string.
            </scoringKey>
            <scoringKey name="NM_HINT">
                A scoring flag indicating that final pattern was applied according to the hint definition. The name of the hint applied
                is available in the binding <code>Hint Name</code>.
            </scoringKey>
            <scoringKey name="NM_TRASH">
                A scoring flag indicating that some text wasn&#39;t parsed or was parsed by a component having no
                special output if <code>Full Trash Scope</code> is specified. This flag is set even if the binding <code>trash</code>
                is not defined.
            </scoringKey>
            <scoringKey name="NM_NULL">
                A scoring flag indicating an empty input.
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.hcatalog.writer.HCatalogColumn">
    <description>
		Columns of a Hive table.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
				Data type of created column.
			</property>
			<property name="partition" type="boolean" required="true">
				Determines whether the column will be written as a Hive partition. The order of columns marked as partition is important for processing data.
				<a href="https://cwiki.apache.org/confluence/display/Hive/Tutorial#Tutorial-DataUnits" target="_blank">See more.</a>
			</property>
		</properties>
  </class>
  <class super="com.ataccama.server.component.hadoop.IHadoopService" name="com.ataccama.server.component.hadoop.hcatalog.jdbc.HCatalogJdbcService">
    <introduction> </introduction>
    <description> </description>
    <properties>
			<property name="dataSourceName" type="string" required="true"> </property>
			<property name="disabled" type="boolean" required="true">Specify whether component should be disabled.</property>
			<property name="prefix" type="string" required="true"> </property>
		</properties>
  </class>
  <class super="com.ataccama.server.component.hadoop.IHadoopService" name="com.ataccama.server.component.hadoop.hcatalog.HCatalogService">
    <introduction> </introduction>
    <description> </description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specify whether component should be disabled.</property>
			<property name="prefix" type="string" required="true"> </property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfGetHttpTask">
    <introduction>Downloads resource via HTTP(S) protocol.</introduction>
    <description>Downloads resource via HTTP(S) protocol. URL resource or URL must be defined. If URL resource is used, then credentials for authorization can be defined in <strong>Url Resource</strong> configuration. If URL is used, then credentials for authorization can be defined in <strong>User Name</strong> and <strong>Password</strong> properties. Task will send requests until it receives HTTP 200 OK status code, or until it exceeds the number of requests specified in <strong>Retry</strong> property.
		<p align="justify">Note: To use the HTTPS protocol, make sure you import the certificate to the Java truststore file: <code>&lt;JAVA_HOME&gt;/lib/security/cacerts</code>.</p>
		</description>
    <properties>
			<property name="fileName" type="string" required="true">Path to file where the result of the request is saved. The file can be local, on Amazon S3 server and on HDFS (if your product package contains Big Data Engine).</property>
			<property name="httpHeaders" type="com.ataccama.adt.task.base.KeyValueMapping$Mapper" required="false">Set of user defined parameters to pass to request header.</property>
			<property name="overwriteFlag" type="boolean" required="true">Permission to overwrite target file. The task fails when <strong>Overwrite Flag</strong> is false and <strong>File Name</strong> already exist.</property>
			<property name="pollingInterval" type="string" required="true">The interval to wait between two requests (ms). Value &gt;0 required.</property>
			<property name="postParams" type="com.ataccama.adt.task.base.KeyValueMapping$Mapper" required="false">Set of user defined parameters to pass to POST request.</property>
			<property name="retry" type="integer" required="true">Specifies how many times a request is re-sent before the task fails.</property>
			<property name="urlResource" type="com.ataccama.adt.task.base.IUrlResourceConfig" required="true">Implementation and configuration of URL Resource. Possible implementations: URL Expression, URL Resource Bean.</property>
			<property name="usePostMethod" type="boolean" required="true">When enabled, the task uses HTTP POST method. Additional parameters can be defined in <strong>Post Params</strong>.
		</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.call.JsonCall$HTTPMethod">
    <description>The HTTP method to be used.</description>
  </class>
  <class name="com.ataccama.server.component.hadoop.IHadoopService">
    <properties>
			<property name="disabled" type="boolean" required="true">Specify whether component should be disabled.</property>
			<property name="prefix" type="string" required="false"> </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.call.JsonCall$Header">
    <description>HTTP header.</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of the
				header.
			</property>
			<property name="value" type="string" required="true">
				Value of the
				header.
				The column values can be substituted into the header as &quot;{column_name}&quot;.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.server.http.filters.ResponseHeadersFilter$Header">
    <description>Adds specified headers to server responses that are processed with this filter.</description>
    <properties>
			<property name="name" type="string" required="false">Fill in header name.</property>
			<property name="value" type="string" required="false">Fill in header value.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.server.services.HealthStateLogger">
    <introduction>Logs all sensor status changes to the standardly configured logger (i.e. to the configured file or stdout).</introduction>
    <description>
			Logs all sensor status changes to the standardly configured logger (i.e. to the configured file or stdout).
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.server.services.HealthStateProviders">
    <introduction>Adds several sensors that report health status of the server parts such as the path variables and database connections.</introduction>
    <description>
			Adds several sensors that report health status of the server parts such as the path variables and database connections.
		</description>
    <properties>
			<property name="dataSourceRefreshRate" type="integer" required="true">Frequency (s) of the database connections health state refresh.</property>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="pathVariableRefreshRate" type="integer" required="true">Frequency (s) of the path variables health state refresh.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.health.HealthStateWebConsole">
    <introduction>Adds Server Health Status section to the Admin Center to display all server&#39;s health sensor statuses.</introduction>
    <description>
			Adds Server Health Status section to the Admin Center to display all server&#39;s health sensor statuses.
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod" name="com.ataccama.dqc.tasks.identify.grouping.Hierarchical">
    <introduction>
        	Unification method where candidate groups are based on one primary key and appended records having no primary key but a common secondary key.
        </introduction>
    <properties>
	        <property name="primary" type="com.ataccama.dqc.tasks.common.components.CondKey" required="true">
	        	Defines the key of the primary group.
	        </property>
	        <property name="secondary" type="com.ataccama.dqc.tasks.common.components.CondKey" required="true">
	        	Defines the key of the secondary group.
	        </property>
		<property name="when" type="string" required="false">
				Boolean condition for using the current grouping method.<br/>
				Default value: true.
			</property>
      <property name="pivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting the &quot;Pivot record&quot; from a set of candidates.
				A matching group is constituted of one pivot record and candidates which
				are near to the pivot record, i.e. which satisfy one of the matching rules.
			</property>
      <property name="maxIterations" type="integer" required="false">
				Maximum number of iterations of the matching group assigning process. Consequently,
				it is maximum number of matching groups in one candidate group.
			</property>
      <property name="mergeSurvivorSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting one &quot;Merge survivor record&quot;, which must be
				assigned for each newly created group (candidate or matching). This
				criterion is used when more than one prior MSR records occurs in group.
				<br/>Ignored when <code>Use Pivot As Survivor</code> is specified.
			</property>
      <property name="matchingRules" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Set of rules used for determining when a candidate record is near the pivot record
				and belongs to its matching group.
				<br/>Note: two records named &quot;pivot&quot; and &quot;candidate&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
      <property name="matchNearest" type="boolean" required="true">
				If specified, candidate will be assigned to matched group with minimal value of <code>Match Quality Expression</code>.
				If not specified, candidate will be assigned to matched group with the best pivot (default behavior). 
			</property>
      <property name="matchQualityExpression" type="string" required="false">
				Numeric (integer, long or float) expression that can be used to evaluate match quality of candidate record with it&#39;s pivot record.
				<br/>Similarly as in <code>Expression</code>
				compared records are referred by two dot-sources <code>pivot</code> and <code>candidate</code>.
				Results of <strong>Matching Measure</strong>
				referred via dot-source <code>measures</code> are accessible, too.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod" name="com.ataccama.dqc.tasks.identify.grouping.HierarchicalUnion">
    <introduction>
        	Unification method where candidate groups are based on one primary key and appended records having no primary key but some secondary keys in common.
        </introduction>
    <properties>
	        <property name="primary" type="com.ataccama.dqc.tasks.common.components.CondKey" required="true">
	        	Defines the key of the primary group.
	        </property>
	        <property name="secondaries" type="com.ataccama.dqc.tasks.common.components.UnionKey[]" required="true">
	        	Set of union keys. Records which have at least one those keys in common and non-null will
	        	belong to one secondary group.
	        </property>
		<property name="when" type="string" required="false">
				Boolean condition for using the current grouping method.<br/>
				Default value: true.
			</property>
      <property name="pivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting the &quot;Pivot record&quot; from a set of candidates.
				A matching group is constituted of one pivot record and candidates which
				are near to the pivot record, i.e. which satisfy one of the matching rules.
			</property>
      <property name="maxIterations" type="integer" required="false">
				Maximum number of iterations of the matching group assigning process. Consequently,
				it is maximum number of matching groups in one candidate group.
			</property>
      <property name="mergeSurvivorSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting one &quot;Merge survivor record&quot;, which must be
				assigned for each newly created group (candidate or matching). This
				criterion is used when more than one prior MSR records occurs in group.
				<br/>Ignored when <code>Use Pivot As Survivor</code> is specified.
			</property>
      <property name="matchingRules" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Set of rules used for determining when a candidate record is near the pivot record
				and belongs to its matching group.
				<br/>Note: two records named &quot;pivot&quot; and &quot;candidate&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
      <property name="matchNearest" type="boolean" required="true">
				If specified, candidate will be assigned to matched group with minimal value of <code>Match Quality Expression</code>.
				If not specified, candidate will be assigned to matched group with the best pivot (default behavior). 
			</property>
      <property name="matchQualityExpression" type="string" required="false">
				Numeric (integer, long or float) expression that can be used to evaluate match quality of candidate record with it&#39;s pivot record.
				<br/>Similarly as in <code>Expression</code>
				compared records are referred by two dot-sources <code>pivot</code> and <code>candidate</code>.
				Results of <strong>Matching Measure</strong>
				referred via dot-source <code>measures</code> are accessible, too.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.config.Hint">
    <description>
			Contains a hint definition for the parsing pattern.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				The name of the hint (string saved into the <code>Hint Name</code> column).
			</property>
			<property name="preferedRule" type="string" required="true">
				Comma separated list of patterns which, in case they all conform to the input, invokes the actual application of the hint.
			</property>
			<property name="ruleNames" type="string" required="true">
				Pattern to be applied (the preferred pattern) when the hint is applicable.<br/>
				It is necessary to keep in mind that the list of names of patterns defined in <code>Rule Names</code> must
				be complete - it must include all the possible patterns which conform to the input string.
				If only a subset of such patterns is defined, the hint will not be applied.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.hcatalog.reader.HCatalogReader">
    <introduction>
            Reads data from a <a href="https://cwiki.apache.org/confluence/display/Hive/" target="_blank">Hive</a> table.
        </introduction>
    <description>
        	<ul>
			<li>Reads data from a <a href="https://cwiki.apache.org/confluence/display/Hive/Tutorial" target="_blank">Hive</a> table.</li>
			<li>In local mode, it is using <a href="https://cwiki.apache.org/confluence/display/Hive/HCatalog+ReaderWriter" target="_blank">HCatalog ReaderWriter</a> interface.</li>
			<li>In MapReduce mode, it is using <a href="https://cwiki.apache.org/confluence/display/Hive/HCatalog+InputOutput" target="_blank">HCatalog InputOutput</a> interface.</li>
			<li>In Spark mode, it is using <a href="https://spark.apache.org/sql/" target="_blank">Apache Spark SQL</a> interface.</li>
			</ul>
			<p align="justify">
			<strong>Note</strong>
        <br/>
			<ul>
			<li>Usage of the Hortonworks Hive 3 via Spark engine is supported.</li>
			<li>When using <strong>Hive</strong> version of Hadoop it is not allowed to use upper case in column name.</li>
			<li>When using <strong>Databricks</strong> version you can use both upper and lower cases in column names.</li>
			</ul>
			</p>
		</description>
    <properties>
            <property name="cluster" type="string" required="true">
            	Name of the Hadoop Cluster with Hive service to be used.
           	</property>
            <property name="databaseName" type="string" required="false">
                Name of the source database (leave empty for default database).
            </property>
            <property name="tableName" type="string" required="true">
                Name of the table to be read.
            </property>
            <property name="filter" type="string" required="false">
                In Local and MapReduce mode, the filter condition can be used to read specific partitions via the <a href="https://cwiki.apache.org/confluence/display/Hive/HCatalog+InputOutput#HCatalogInputOutput-FilterOperators" target="_blank">HCatalog operations</a>.
                In Spark mode, it may contain SQL functions which will be used after &quot;where&quot; condition in SQL Query.
            </property>
            <property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="true">
                Definition of HCatalog table columns (corresponding by order, names and types).<br/>
					<strong>Note:</strong>
        <br/>
					<ul>
					<li>When using <strong>Hive</strong> version of Hadoop it is not allowed to use upper case in column name.</li>
					<li>When using <strong>Databricks</strong> version you can use both upper and lower cases in column names.</li>
					</ul>
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
                Definition of shadow columns (additional to those ones read from HCatalog).
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.hcatalog.writer.HCatalogWriter">
    <introduction>
            Writes data to a <a href="https://cwiki.apache.org/confluence/display/Hive" target="_blank">Hive</a> table. If the Hive table does not use partitions, Hive Writer step appends the data to the existing table.
        </introduction>
    <description>
			<p align="justify">
			<ul>
			<li>Writes the incoming data to a <a href="https://cwiki.apache.org/confluence/display/Hive" target="_blank">Hive</a> table. The target table with appropriate schema must already exist before writing the data.</li>
			<li>In local mode, it is using <a href="https://cwiki.apache.org/confluence/display/Hive/HCatalog+ReaderWriter" target="_blank">HCatalog ReaderWriter</a> interface.</li>
			<li>In MapReduce mode, it is using <a href="https://cwiki.apache.org/confluence/display/Hive/HCatalog+InputOutput" target="_blank">HCatalog InputOutput</a> interface.</li>
			<li>In Spark mode, it is using <a href="https://spark.apache.org/sql/" target="_blank">Apache Spark SQL</a> interface.</li>
			<li>Use button <strong>Create / Alter table...</strong> to create new or adapt an existing table for writing. After pushing this button you will be prompted to confirm the changes. If you are altering partitions of existing table the original data in this table will be deleted.</li>
			<li>Due to Hive <a href="https://cwiki.apache.org/confluence/display/Hive/Tutorial#Tutorial-DataUnits" target="_blank">partition concept</a> the order of columns marked as partition is important.</li>
			</ul>
			</p>
				<p align="justify">
				<strong>Note</strong>
        <br/>
				<ul>
				<li>Usage of the Hortonworks Hive 3 via Spark engine is supported.</li>
				<li>When using <strong>Hive</strong> version of Hadoop it is not allowed to use upper case in column name.</li>
				<li>When using <strong>Databricks</strong> version you can use both upper and lower cases in column names.</li>
				</ul>
				</p>
				<p align="justify">
				<strong>Known issues</strong>
				<ul>
				<li>It is not possible to write into existing partitions repeatedly when running via MapReduce engine. This functionality is supported only in Local and Spark modes.</li>
				<li>Reported for local and MapReduce modes.
							Hive throws NullPointerException in case if it encounters nulls in partition values.
							Should be fixed since Hive 1.2.2 and Hive 2+. <a href="https://issues.apache.org/jira/browse/HIVE-11470" target="_blank">HIVE-11470</a>
							When using partitioning, please make sure that the values in partition do not contain empty strings.  </li>
				<li>Local run is affected by this bug <a href="https://issues.apache.org/jira/browse/HIVE-10809" target="_blank">HIVE-10809</a>.</li>
				<li>When running plan on local computer with Windows operating system, spaces characters in partition values are escaped whereas on other OS they aren&#39;t. It causes a problem when you want to write into one partitioned table repeatedly from two 		different computers and one runs on Windows.</li>
				</ul>
				</p>
		</description>
    <properties>
            <property name="cluster" type="string" required="true">
            	Name of the Hadoop Cluster with Hive service to be used.
            </property>
            <property name="databaseName" type="string" required="false">
                Name of the target database (leave empty for default database).
            </property>
            <property name="tableName" type="string" required="true">
                Name of the table to be written to.
            </property>
            <property name="columns" type="com.ataccama.dqc.tasks.hadoop.io.hcatalog.writer.HCatalogColumn[]" required="true">
                Definition of HCatalog table columns (corresponding by order, names and types).<br/>
				<strong>Note:</strong>
        <br/>
				<ul>
				<li>When using <strong>Hive</strong> version of Hadoop it is not allowed to use upper case in column name.</li>
				<li>When using <strong>Databricks</strong> version you can use both upper and lower cases in column names.</li>
				</ul>
            </property>
            <property name="batchSize" type="integer" required="true">
                The size of one batch to be written at once. Each partition is counted separately.
                This only applies to local mode - in MapReduce and Spark contexts,
                the writing does not happen in batches.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.web.HttpDispatcher">
    <introduction>Basic component that enables communication via HTTP protocol and responds to HTTP requests.</introduction>
    <description>
			<p align="justify">
				Basic component that enables communication via HTTP protocol and responds to HTTP requests. It receives all HTTP requests, distributes them for processing to deployed services, and initiates request role resolution.
			</p>
			<p align="justify">
				The incoming HTTP request is analyzed, and if it contains an Authorization header, the username and password is extracted. Then the dispatcher contacts the <strong>Authentication Service Component</strong> on the server and resolves user roles assigned according to the provided username, password and IP address of the incoming request. Resolved roles are stored into the request context and may be used later in the <strong>Online Services Component</strong> to check if access to the service should be allowed or not.
			</p>
			<p align="justify">
				The component is required by many other components which register themselves into
				Http Dispatcher on the specified URL path so that the HttpDispatcher can redirect handling of
				requests.
			</p>
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="filters" type="com.ataccama.dqc.web.config.FilterBean[]" required="false">
				<p align="justify">Defines the actions that have to be done for each incoming request. One example of a filter is logging of requests and responses, another is encryption of requests. Filters are applied on the incoming HTTP requests before they invoke the service itself.</p>
				<p align="justify">Every filter has its own parameters in the <strong>Mappings</strong> subsection with subelements that define conditions when the filter will be activated, such as which listener is used to accept the request, url prefix of the request and set of tests that must all succeed. If the <strong>Mappings</strong> are not specified, the filter will be mapped to all listeners and all requests.</p>
				<p align="justify">If the request conforms to several patterns, the filters will be applied in the order of appearance in the filters section.</p>			
			</property>
			<property name="listeners" type="com.ataccama.dqc.web.config.ListenerBean[]" required="false">
				Defines listener threads that receive requests on the specified TCP ports and specifies if the listener should communicate via SSL or not. It is possible to define several listeners, each of them accepting requests on a different TCP/IP port.
			</property>
			<property name="servletFilters" type="com.ataccama.dqc.web.config.ListenerBean[]" required="false">
			Filters which can be used to filter traffic, requests and responses to and from Java servlets.
			</property>
			<property name="workerQueues" type="com.ataccama.dqc.web.config.WorkerQueueBean[]" required="false">
				Defines dedicated thread pools to some services or requests. The <strong>Worker Queues</strong> has <strong>Mappings</strong> subsection with subelements that define conditions when the worker queue is activated. All requests that meet the URL pattern and listener defined in the <strong>Mappings</strong> section are handled by the queue defined. If the <strong>Mappings</strong> are not specified, the Worker Queue will be mapped to all listeners and all requests. 
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.soap.HttpRequestHeaderDefinition">
    <description>
			Defines HTTP header fields for SOAP call.
		</description>
    <properties>
			<property name="name" type="string" required="true">HTTP header
				field name.</property>
			<property name="value" type="string" required="true">Dynamic
				expression for a value of HTTP header field.</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfFileInfoOperation">
    <introduction>Saves information about a source file/folder to task variables.</introduction>
    <description>Saves information about a source file/folder to task variables.</description>
    <properties>
			<property name="sourceFolder" type="string" required="true">Path to the source file/folder. The task fails when the source does not exist.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.commons.security.IIdentity">
    <properties/>
  </class>
  <class name="com.ataccama.server.http.security.keycloak.IdentityProvider">
    <description>Authentication is managed by Keycloak. This is the only recommended implementation.</description>
    <properties>
			<property name="clientId" type="string" required="false">Specifies the name of your application. (e.g., <code>one-admin-center</code>)</property>
			<property name="configFile" type="string" required="false">Specifies path to Keycloak configuration file.</property>
			<property name="configName" type="string" required="false">Specifies name for Keycloak configuration file.</property>
			<property name="pattern" type="string" required="true">Specifies the location of the service to secure. (e.g., Admin Center - <code>/console/**</code>, Ataccama Remote Executor - <code>/executor/**</code>, DQD Management API - <code>/api/dqd/**</code>.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.imputing.ImputerConfig">
    <introduction>Trains imputing model.</introduction>
    <description>
            <p align="justify">
                Imputing servers for filling in missing data. These missing data are computed based on the type of imputer selcted.
                This step loads imputers from model located in file specified by field &quot;model file&quot;.
                After loading the model, it applies the specified features on selected columns.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.transformation.imputing.columns.ImputerFeatureConfig[]" required="true">
                Configuration of features used to impute the data based on the model file loaded.
            </property>
            <property name="modelFile" type="string" required="true">
                Name of file with trained model that will be used for imputing.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.imputing.columns.ImputerFeatureConfig">
    <introduction>Configuration of features used to perform the imputing transformation.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be present in model file.
            </property>
            <property name="sourceColumn" type="string" required="true">
                Data input column for imputing transformation.
            </property>
            <property name="resultColumn" type="string" required="true">
                Output column, where the result of imputing transformation will be outputted to. Can be equal to source column.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.imputing.columns.ImputerFeatureTrainerConfig">
    <introduction>Configuration of features used for imputing.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be used in classification step.
            </property>
            <property name="sourceColumn" type="string" required="true">
                Data input column for training the imputing model.
            </property>
            <property name="resultColumn" type="string" required="false">
                When filled, the trained model will do imputing on the source column and output it into result column.
            </property>
            <property name="imputer" type="com.ataccama.dqc.tasks.ai.transformation.imputing.definition.ImputingFeatureTransformation" required="true">
                Type of imputing.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.imputing.ImputerTrainerConfig">
    <introduction>Trains imputing model.</introduction>
    <description>
            <p align="justify">
                Imputing servers for filling in missing data. These missing data are computed based on the type of imputer selcted.
                Based on specified features, this steps trains imputing model and saves the trained model to the specified file.
                Each feature can have different type of imputing defined. Multiple imputers can be defined for single feature.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.transformation.imputing.columns.ImputerFeatureTrainerConfig[]" required="true">
                Configuration of features used to train the model and perform imputing on training input data.
            </property>
            <property name="outputModelFile" type="string" required="true">
                Name of the model output file.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.imputing.definition.ImputingFeatureTransformation">
    <introduction>Type of imputer.</introduction>
  </class>
  <class name="com.ataccama.dqc.components.addresses.can.CANAddressesGenerated$InEndPoint">
    <description>
            Input column mappings.

<ul>
    <li>street number, unit and po box designators and numbers require the address to be identified up to delivery point in order to use standardized values in output (else input values are sent to output)</li>
    <li>street name, street directions, street type, route service type and route service number require the address to be indentified at least up to street level to use standardized values in output</li>
    <li>standardized values of province, municipality and postal code are sent to output every time the address is identified at least up to station level</li>
</ul>
        </description>
    <properties>
			<property name="srcAddressLine1" type="string" required="false">
		    Additional address information. Often required for delivery to a rural address that does not have a civic address. In such cases, a SITE and COMP (compartment) is assigned. This should be placed above the rural route identifier and station information.
		    </property>
		    <property name="srcAddressLine2" type="string" required="true">
		    Required. Delivery Address Line. Delivery information comprised of the following elements depending on the address type: Unit Identifier, Civic number, Civic number suffix, Street name, Street type, Street direction, General delivery indicator, Postal Box number, Rural route identifier, Station information.
		    </property>
		    <property name="srcMunicipality" type="string" required="true">
		    Required. The official name of the municipality. Abbreviations and valid alternates can be used, but cannot be translated, for example: official name TROIS-RIVIÈRES cannot be translated to THREE RIVERS, official name Sainte-Anne-de-Bellevue can be replaced with official abbreviation STE-ANNE-BELL.
			</property>
		    <property name="srcProvinceCode" type="string" required="true">
		    Required. The official name of the Province or territory. Should be printed in the official two-letter postal abbreviation (e.g. QC, ON).
		    </property>
		    <property name="srcPostalCode" type="string" required="true">
		    Required. Should be printed in uppercase with one space between the first three and the last three characters. A hyphen should not be used (ex. of unacceptable format: T0L-1K0).
		    </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.components.addresses.gb.GBAddressesGenerated$InEndPoint">
    <description>Input values of address component are used in case the address in not sufficiently identified.         	
			<ul>
				<li>•out_county,out_district,out_post_town require the address to be identified </li>
				<li>•out_locality,out_thfare_name,out_thfare_desc require the address to be identified </li>
				<li>•out_postcode,out_building_number,out_building_name require the address to be identified </li>
				<li>•out_sub_building,out_organization,out_udprn,out_dps require the address to be identified </li>
			</ul>
		</description>
    <properties>
			<property name="src_address_line1" type="string" required="true">Source value of address line 1 - the addressee&#39;s name</property>
			<property name="src_address_line2" type="string" required="true">Source value of address line 2 - flat, building or house number and street name</property>
			<property name="src_address_line3" type="string" required="true">Source value of address line 3 - name of the local area or village</property>
			<property name="src_address_line4" type="string" required="true">Source value of address line 4 - TOWN (in capital letters)</property>
			<property name="src_address_line5" type="string" required="true">Source value of address line 5 - name of the country in block capitals </property>
			<property name="src_postcode" type="string" required="true">Source value of postcode (in capital letters) </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.components.addresses.us.USAddressesGenerated$InEndPoint">
    <properties>
			<property name="inSrc_address_line1" type="string" required="false">
			Column name containing first line of address. Unit level information (unit number and type) and street level information (street name, street type, street direction, house number) is preferred.
			<ul>
				<li>For PO BOX addresses - input box number.</li>
				<li>For rural route (RR) addresses - input route level information (type, number) and box number.</li>
				<li>For general delivery (GD) addresses - some GD identifier (&quot;GD&quot;, &quot;GENERAL DELIVERY&quot;).</li>
			</ul>
			</property>
			<property name="inSrc_address_line2" type="string" required="false">
			Column name containing second line of address. City name is preferred.
			</property>
			<property name="inSrc_address_line3" type="string" required="false">
			Column name containing third line of address. State name or abbreviation is preferred.
			</property>
			<property name="inSrc_zip" type="string" required="false">
			Column name containing ZIP code, either ZIP5 or ZIP+4.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.override.IncrementalManualOverrideBuilder">
    <introduction>Manages a set of rules for manual overriding against a single existing unification rule within the repository.</introduction>
    <description>
			This step manages a set of rules for the purpose of manual overriding against the existing rules within the repository.
			This step differs from Manual Override Builder by operating
			on a single rule level and therefore facilitating add/change/delete operations of a single rule.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="typeColumn" type="string" required="true">
				String column that contains and eventually stores the rule type. See the <strong>manual override</strong> section.
			</property>
			<property name="parentRecordPkColumn" type="string" required="true">
				String column that contains and eventually stores the primary key of the parent record (not applicable to R-&gt;C rule).
			</property>
			<property name="childRecordPkColumn" type="string" required="true">
				String column that contains and eventually stores the primary key of the child record.
			</property>
			<property name="deleteColumn" type="string" required="false">
				Boolean column or expression that specifies whether a given rule should be deleted.
			</property>
			<property name="repository" type="com.ataccama.dqc.tasks.identify.repository.RepositoryProperties" required="true">
				Repository properties.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.server.http.conditions.InetAddressCondition">
    <introduction>Tests if the requestor&#39;s network address matches address and network mask specified in <strong>Address</strong> and <strong>Mask</strong> parameters.</introduction>
    <description>Tests if the requestor&#39;s network address matches address and network mask specified in <strong>Address</strong> and <strong>Mask</strong> parameters.</description>
    <properties>
			<property name="address" type="string" required="false">Fill in specific IP address</property>
			<property name="mask" type="string" required="false">Fill in specific net mask</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.web.IMappingTest" name="com.ataccama.dqc.web.mappingtests.InetAddressTest">
    <introduction>Tests if the requestor&#39;s network address matches address and network mask specified in <strong>Address</strong> and <strong>Mask</strong> parameters.</introduction>
    <description>Tests if the requestor&#39;s network address matches address and network mask specified in <strong>Address</strong> and <strong>Mask</strong> parameters.</description>
    <properties>
			<property name="address" type="string" required="false">Fill in specific IP address.</property>
			<property name="mask" type="string" required="false">Fill in specific net mask.</property>
		</properties>
  </class>
  <class name="com.ataccama.nme.dqc.steps.MdcIdentify$InputColumn">
    <properties>
            <property name="entityColumn" type="string" required="true">
                Column in MDM model.
            </property>
            <property name="expression" type="string" required="true">
                An expression whose result is used as input value.
                For a list of all available expressions and their definitions, refer to <strong>Expressions</strong>.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.InputElement">
    <description>Defines an element of input &quot;string&quot;</description>
    <properties>
  			<property name="component" type="string" required="false">
  				Either component id that will cause searching only in a dictionary for the component
  				or nothing for searching in dictionary of any compoennt.
  			</property>
  			<property name="expression" type="string" required="true">
  				Definition of the value. An expression returning string value.
  			</property>
  			<property name="name" type="string" required="true">
  				Name of the element. This name is later used in evaluation
  				to access unexplained text found in this element.
  			</property>
  		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.InputLayout">
    <description>
			Definition of the entity &quot;string&quot;. Each input is divided into one ore more
			elements that can map to either single component or any component.
		</description>
    <properties>	
	        <property name="elements" type="com.ataccama.dqc.tasks.addresses.dictionary.InputElement[]" required="true">
	        	Array of elements forming the input &quot;string&quot; to identify.
	        </property>
       	</properties>
  </class>
  <class name="com.ataccama.adt.config.EwfVariables$EwfInputVariable">
    <description>Input variable. Use input variables to pass a value to the workflow before the workflow is started. All input variables are considered to be of a data type STRING.</description>
    <properties>
			<property name="name" type="string" required="true">
			Variable name.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.usersteps.io.InputStep">
    <introduction>A generic input step</introduction>
    <description>
			This step can be used instead of other, more specialized, input steps, such as <strong>Text File Reader</strong>,
			to create a Plan file that is usable as either a component or an <strong>online service</strong>. An input step in a Plan file in a component step
			creates an endpoint named by the input step. Then data inserted into the endpoint are sent to the output endpoint of this input step.
			A similar situation is when a Plan file with an input step is used as an <strong>online service</strong>. In this case the input steps can be used as 
			receivers of data from the online service and the received data are sent to the output endpoint of this input step. The &quot;opposite&quot; step is <strong>Integration Output</strong>.
		</description>
    <properties>
		 	<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="false">
				These columns define the format of data being sent into this step either from a component step or from an online service.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				These columns, together with the columns property, define the record format of the output endpoint. The shadow
				columns are not visible outside of the Plan file where the input step is used.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.usersteps.io.OutputStep">
    <introduction>A generic output step</introduction>
    <description>
			This step can be used instead of the other, more specialized, output steps, such as <strong>Text File Writer</strong>,
			to create a Plan file that is usable as either a component or an <strong>online service</strong>. An output step in a Plan file in a component step
			creates an endpoint named by the output step. Then data sent into this step through the &#39;out&#39; endpoint are sent into the component step to the created endpoint. The
			format of the records is determined by the record format of the &#39;out&#39; endpoint.
			A similar situation is when a Plan file with an output step is used as an <strong>online service</strong>. In this case the output steps can be used as 
			transmitters of data to the online service and the data sent to the output step are transmitted to the online service. The &quot;opposite&quot; step is <strong>Integration Input</strong>.
		</description>
    <properties>
			<property name="requiredColumns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="false">
                Columns required to be defined in the input connection.
            </property>
	<property name="enforceFormat" type="boolean" required="false">
			When the <strong>Enforce Format</strong> is checked only columns listed in  <strong>Required Columns</strong> section will be provided to the output. If  the <strong> Enforce Format</strong> is not checked all columns are provided to the output. By default this option is not checked.
			</property>	
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.server.http.security.InterceptUrl">
    <description>Setting maps URL patterns to the access conditions.</description>
    <properties>
			<property name="access" type="string" required="true">Specifies the access conditions to the endpoint specified by pattern. Uses Spring Security expression syntax.</property>
			<property name="pattern" type="string" required="true">Specifies the location of the service to secure.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.InvalidDataDefinition">
    <description>
			Defines when the parsed data are to be considered invalid and what should be given to
			the related output binding in that case.
		</description>
    <properties>
			<property name="scoringFlags" type="string" required="false">
				Defines which flags indicate that the given input is invalid. To be processed by this
				definition, the processed data must be flagged with at least one of these flags.
			</property>

			<property name="outputType" type="com.ataccama.dqc.tasks.clean.InvalidOutputType" required="true">
				Specifies what data type should be written to the output when this data definition applies.
			</property>

			<property name="defaultValue" type="string" required="false">
				Specifies the value to be used when <code>CONSTANT</code> is selected as the output type.
				When not set the empty value is used.
			</property>
			
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.AbstractValidatePhoneNumberAlgorithm$InvalidDataDefinitions">
    <description>
			Defines invalid data definitions for the step&#39;s data outputs.
		</description>
    <properties>
	     	<property name="invalidDataDefinitionExt" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what will be written to <code>outExt</code> when an error occurs.	  
	     	</property>
	     	<property name="invalidDataDefinitionExtOrig" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what to write to the <code>outExtOrig</code> output when an error occurs. 	  
	     	</property>
	     	<property name="invalidDataDefinitionIdc" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what to write to the <code>outIdc</code> output when an error occurs.	  
	     	</property>
	     	<property name="invalidDataDefinitionIdcOrig" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what to write to <code>outIdcOrig</code> when an error occurs.	  
	     	</property>
	     	<property name="invalidDataDefinitionPhoneNumber" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what to write to the <code>outPhoneNumber</code> output when an error occurs. 	  
	     	</property>
	     	<property name="invalidDataDefinitionPhoneNumberOrig" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what to write to the <code>outPhoneNumberOrig</code> output when an error state occurs.	  
	     	</property>
	     	<property name="invalidDataDefinitionProv" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what to write to <code>outProv</code> when an error occurs.	  
	     	</property>
	     	<property name="invalidDataDefinitionProvOrig" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what to write to the <code>outProvOrig</code> output when an error occurs. 	  
	     	</property>
	     	<property name="invalidDataDefinitionRuleName" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	     		Defines what to write to the <code>outRuleName</code> output when an error occurs.	  
	     	</property>
	     </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.bank.account.ValidateBankAccountNumberCZ$InvalidDataDefinitions">
    <description>
			Defines the invalid data definitions for the step&#39;s data outputs.
		</description>
    <properties>
	        <property name="invalidDataDefinitionBankAccount" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	          Contains the definition of invalid input for <code>outBankAccount</code> and how to 
	          represent it in the output.
	        </property>
	        
	        <property name="invalidDataDefinitionBankId" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
	          Contains the definition of invalid input for <code>outBankId</code> output and how to 
	          represent it in the output.
	        </property>
	     </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ua.ValidateBirthNumberUA$InvalidDataDefinitions">
    <description>
            Defines invalid data definitions for the step&#39;s data outputs.
        </description>
    <properties>
            <property name="invalidDataDefinitionBirthDate" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
                Defines what will be written to <code>Birth Date Out</code> when an error occurs.     
            </property>
            <property name="invalidDataDefinitionBirthNumber" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
                Defines what to write to the <code>Birth Number Out</code> output when an error occurs.
            </property>
            <property name="invalidDataDefinitionGender" type="com.ataccama.dqc.tasks.clean.InvalidDataDefinition" required="true">
                Defines what to write to the <code>Gender Out</code> output when an error occurs.    
            </property>
         </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.InvalidOutputType">
    <description>
			Specifies what data type should be written to the output when this data definition applies.
		</description>
  </class>
  <class name="com.ataccama.epp.dqc.steps.IssueImporter">
    <introduction>Transfers issue data records to DQIT.</introduction>
    <description>
	  <!--This step separates issue data records from the main data flow and stores them in a .csv format file designated for importing to DQIT.
	  Each issue type has a separate storage file since each issue type differs in the fields it possesses (according to the metadata configuration).-->
	  This step processes the data flow containing the DQ issues and transfers the issues to the DQIT data storage.
	  This can be either an XML file storage or a database storage, depending on the DQIT configuration.
	  The data flow coming into the step should contain all the data columns defined in the selected Issue Type metadata and the necessary technical “issue_” columns.
	  For the list of all “issue_” columns for each Issue Type, see the description of the individual Issue Types in the <em>DQIT Administration Guide | Issue Types and Classes</em>.
	  <br/>
      <br/>
	  When issues are imported in the <code>Upsert</code> mode, the issues currently present  in DQIT (if there are any) are left intact, and all the issues in the load are added to the issue database.
	  If the <code>Full</code> mode is used, all the issues currently present in the DQIT and <em>not</em> present in the load are closed. Only the issues that are present in the load will be open. When
	  issues are imported in the <code>Close</code> mode, matched issues are closed.
	  </description>
    <properties>
          <property name="server" type="string" required="true">Name of the server that runs the DQIT web application.</property>
          <property name="assignee" type="string" required="false">DQIT user to whom the imported issues are assigned.</property>
          <property name="comment" type="string" required="false">Additional information describing import action.</property>
          <property name="id" type="string" required="false">Step name.</property>
          <property name="importMode" type="com.ataccama.epp.dqc.steps.DqitImportMode" required="true">Import mode: <code>Full</code>, <code>Upsert</code> or <code>Close</code>.</property>
          <property name="issueType" type="string" required="true">Name of the issue type, with the following naming convention: <code>[entity_name]_[name of the issue type]</code>.
          The name of the issue should be completely in lowercase.</property>
          <property name="connectionTimeout" type="integer" required="false">Connection timeout in milliseconds.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.epp.dqc.steps.IssueReader">
    <introduction>Transfers issue data records from DQIT.</introduction>
    <description>
	  This step reads the current issues from DQIT Web Application.
	  Issues can be specified by four optional filters: <code>Status</code>, <code>Entity</code>, <code>System</code> and <code>Assignee</code> fields.
	  </description>
    <properties>
          <property name="server" type="string" required="true">Name of the server that runs the DQIT web application.</property>
          <property name="assignee" type="string" required="false">DQIT user to whom the imported issues are assigned.</property>
          <property name="entity" type="string" required="false">Entity (named according to metadata configuration) to which the issue data belongs.</property>
          <property name="id" type="string" required="false">Step identification string.</property>
          <property name="issueColumns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="false">A user-specified set of columns to be used for further processing after the <code>Issue Reader</code> step</property>
          <property name="issueType" type="string" required="true">Name of the issue type, with the following naming convention: <code>[entity_name]_[name of the issue type]</code>.
          															The name of the issue should be completely in lowercase.</property>
          <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">Additional columns, which are not present in the input data
           but which can be specified by the user to be used in the steps following <code>Issue Reader</code>.</property>
          <property name="status" type="long" required="false">Value of the <code>issue_status</code> field, which stores the current workflow status of an issue</property>.
          <property name="system" type="string" required="false">System in which the issue data originates.</property>
          <property name="connectionTimeout" type="integer" required="false">Connection timeout in milliseconds.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.config.UserMetadata$Item">
    <description>
			Meta data item definition.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Item name.
			</property>
			<property name="value" type="string" required="false">
				Item value.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfForEachTask">
    <introduction>The task is used to implement a for-each cycle.</introduction>
    <description>The task is used to implement a for-each cycle. It sequentially runs child workflows for each input value (e.g., a file or DB row). 
			The task finishes with result OK, unless any of the child workflows does not start correctly or finishes with a wrong result. Break on error has no impact on the task result. When the iterator has no values, the task finishes with result OK.
</description>
    <properties>
			<property name="breakOnError" type="boolean" required="true">If an error occurs, the iteration is either terminated immediately (true) or continues (false).</property>
			<property name="iterable" type="com.ataccama.adt.task.iterators.ITaskIterator" required="true">Implementation and configuration of additional iterators. Possible implementations: File Iterator, Set Iterator, SQL Row Iterator.</property>
			<property name="iterationType" type="com.ataccama.adt.task.exec.EwfForEachTask$IterationType" required="true">SERIAL or PARALLEL run.</property>
			<property name="workflowId" type="string" required="true">Id of a workflow to run. Workflow Id specification depends on the workflow execution context:
			<ul>
				<li>In the server context, use the <code>&lt;sourceId&gt;:&lt;workflowName&gt;.ewf</code> notation, e.g., WF02:02_03b_Executor.ewf. The <code>sourceId</code> prefix is defined in Workflow Server Component.</li>
				<li>Outside the server (from IDE or via <code>runewf.[bat|sh]</code>), you can use two mutually exclusive notations:
					<ul>
						<li>
                <code>&lt;sourceId&gt;:&lt;workflowName&gt;.ewf</code>; in this case, the <code>&lt;sourceId&gt;:</code> prefix is ignored and the specified workflow from the current folder is run. This is useful when you want to develop and test workflows locally in the IDE and deploy them to server later on.</li>
						<li>
                <code>&lt;path&gt;/&lt;workflowName&gt;.ewf</code>, e.g., ../02_Run_Plans/02_03b_Executor.ewf. The <code>path</code> is optional and is relative to the current workflow.</li>
					</ul>
				</li>
			</ul>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfForEachTask$IterationType">
    <description>Iteration mode.</description>
  </class>
  <class name="com.ataccama.dqc.tasks.io.jdbc.read.JdbcReader">
    <introduction>Reads data from a JDBC (database) data source.</introduction>
    <description>
          <p align="justify">This step reads data records from the results of a specified query executed on a specified JDBC database table.</p>
			<strong>Usage notes</strong>
      <br/>
				<ul>
					<li>Placeholders can be inserted in any part of the SQL query and are replaced before the query executed. This allows you to define custom schema or table names, etc.</li>
					<li>A warning is shown if a placeholder is provided in the query but not defined in the table. Specifying two placeholders with the same name results in an error. </li>
				</ul>
		</description>
    <properties>
			
			
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="afterScript" type="string" required="false">SQL instructions representing the script to be executed in the database after reading is done.</property>
			<property name="beforeScript" type="string" required="false">SQL instructions representing the script to be executed in the database before reading.</property>
			<property name="columns" type="com.ataccama.dqc.tasks.io.jdbc.read.JdbcReaderColumn[]" required="true">Contains definitions of columns which will be constructed from the JDBC query result set.</property>
			<property name="dataSourceName" type="string" required="true">Name of the DataSource. DataSource groups together information regarding access to the database, such as: URL, driver name, username and password. See the <strong>Data Source description</strong> for more details.
			</property>
			<property name="queryFileEncoding" type="string" required="false">Encoding of the query file if such a file is used.</property>
			<property name="queryFileName" type="string" required="false">When defined, it represents the name of the file that contains the query to execute. When this attribute is filled in, the attribute <code>Query String</code> must not contain any value, otherwise a query conflict error is reported.</property>
			<property name="queryString" type="string" required="true">SQL query to execute on the data source to obtain input data records. Only selection operations are supported.</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">Contains a set of columns that are not present in the input data, but should be created in the output (so that they are then available for further use as any other &quot;real&quot; column read from a file).</property>
			<property name="placeholderBeginMark" type="string" required="false">The string marking the beginning of column placeholder.</property>
			<property name="placeholderEndMark" type="string" required="false">The string marking the end of column placeholder.</property>
		
		
		
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.jdbc.read.JdbcReaderColumn">
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="src" type="string" required="false">
				Name of the query result&#39;s data column to be used as data input. If not specified
				the value of the attribute <code>Name</code> is used.
				It is possible to use white space characters in initial, terminal positions here or as the column name. However, this is not recommended and a warning will be displayed.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
				Column data type.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.jdbc.write.JdbcWriter">
    <introduction>Writes data to a JDBC (database) data source.</introduction>
    <description>
			<p align="justify">
			The standard output for this step are data records written to a database table.
			Saving to the database is done utilizing the SQL INSERT command. All data is written in
			batches to speed up the process. The following databases have been tested with the step:
			Oracle, Sybase, MS SQL, DB2, Excel file (via ODBC), mySQL and postgreSQL.
			</p>
			<p align="justify">
				For better error management, the parameter <code>Error Handler</code> handles
				error situations when writing to the DB. If this property is defined then the
				step has one mandatory output, <code>err_out</code>. Otherwise it has no
				output.
			</p>
			<p align="justify">
			Important notes:
			</p>
			<ul>
				<li>
					 It is strongly recommended not to use the JDBC-ODBC driver, due to several problems:
					  <ul>
					  	<li>ODBC writes are always slower (sometimes dramatically)</li>
					  	<li>the driver implements only the JDBC 2.0 specification,
					  	which is missing some important functionality for complex exception handling (so
					  	you may experience problems when writing to the DB using the JDBC-ODBC driver
					  	under some circumstances, e.g., when a DB writing error occurs).</li>
					  	<li>the connection may not support Unicode encodings such as UTF-8</li>
						<li>in dependency on the data source it may be impossible to set <code>autocommit=off</code>,
						which, again, causes problems with exception handling</li>
					  </ul>
					  Therefore, it is recommended to use direct JDBC drivers for the specified database
					  system.
				</li>
				<li>
					  When the <code>Error Handler</code> property is defined, the step tries to handle
					  writing problems with the database. When it is not possible to handle them (for
					  example, when the driver used does not support all required functionality) it falls
					  back to processing as without <code>Error Handler</code> defined. This usually
					  ends up with the exception in case of writing problems, while data written to
					  the database depends on the error strategy used. Consult the
					  <code>Error Handler</code> property description for more detail on this.
				</li>
				<li>
					  In order to fully support exception handling, the driver is required to
					  implement JDBC 3.0 (or at least the savepoints specification section).
					  Only the JDBC-ODBC driver does not meet this requirement for all tested drivers.
				</li>
				<li>
					The ROLLBACK and ROLLBACK_AND_STOP strategies should be used only with
					<code>Commit Size</code> set	to 0 to ensure data integrity. In that case are all
					data are rolled back (since all data comes in a single commit) when an error occurs or
					all data are written to the database when no error has occurred.
				</li>
				<li>
					The <code>autocommit</code> property from previous versions was removed.
					The step now tests the connection on its own and sets
					<code>autocommit=on</code> only if it is not possible to use the
					<code>autocommit=off</code> option, which is much more suitable for exception
					handling. For now, the only case when <code>autocommit</code> is set to on is
					an ODBC connection to a simple file-based source such as an Excel file.
				</li>
				<li>
					If there are many invalid entries in the input and <code>Error Handler</code>
					is defined, writing may take significantly more time (although it is heavily dependent on the database used).
					When writing data without errors to the DB, there should not be a significant time difference between errorHandler-defined and
       				errorHandler-disabled configurations.
				</li>
			</ul>
		</description>
    <properties>
			<property name="afterScript" type="string" required="false">
				SQL instructions representing the script to be executed in the database after writing is done.
			</property>
			<property name="batchSize" type="integer" required="true">
			    Number of elements to be used in the batch. The minimum size for a batch is 0 (no batching).
				The preferred maximum batch size is currently 10000 rows. When the commit size is smaller
				than <code>Batch Size</code> then <code>Batch Size</code> is set to the value of
				<code>Commit Size</code>.
			</property>
			<property name="beforeScript" type="string" required="false">
				SQL instructions representing the script to be executed in the database before writing.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
				A list of columns to be written to the database. Note that column names should be defined
				in an &quot;unquoted&quot; form, even if they contain special characters or represents SQL reserved word.
				Contrary to the <code>Table Name</code> property, the column names are quoted automatically
				as needed.
			</property>
			<property name="commitSize" type="integer" required="true">
				Gives the number of elements after which the commit should be performed. The currently opened
				batch is executed and the whole current transaction is committed. The commit size is
				not limited. When set to 0, the whole writing process will be sent as single-commit
				transaction.
			</property>
			<property name="dataSourceName" type="string" required="true">
				Name of the DataSource. The DataSource groups together information regarding
				access to the database, such as: URL, driver name, username and password.
				See the <strong>Data Source description</strong> for more details.
			</property>
			<property name="errorHandler" type="com.ataccama.dqc.io.jdbc.writer.ErrorHandler" required="false">
			   Error handler which defines the behavior of the step in case of writing problems.
			   When this property is set the step has one mandatory output, <code>out_err</code>,
			   where the invalid rows are sent to. The format of this output is the same as that of the input with one
			   additional textual column named as specified by the property <code>errorFieldName</code>, where
			   the cause of problem as reported by the database are written.
			</property>
			<property name="tableName" type="string" required="true">
				Name of the table to write data to. This table must exist in the given database and must
				be writable for the given user.<br/>
				<strong>Note</strong> that it is necessary to enclose individual table name parts with quotes when:<br/>
				- given part contains special character(s) (according to the SQL specification)<br/>
				- given part matches SQL reserved word (according to the SQL specification)<br/>
				It&#39;s because table name can represent structured value following the catalog.schema.table
				pattern and therefore it&#39;s on the user to specify and quote individual parts when needed.<br/>
				<strong>Example:</strong> having catalog &#39;test:catalog&#39; with schema &#39;User&#39; and table &#39;table.1&#39;, the correct
				value is <code>&quot;test:catalog&quot;.&quot;User&quot;.&quot;table.1&quot;</code> (because both &#39;table.1&#39; and &#39;test:catalog&#39;
				contains special characters and &#39;User&#39; is an SQL reserved word).<br/>
				<strong>Warning:</strong> quoted parts should exactly represent DB object name since many DB&#39;s are case sensitive
				when dealing with quoted names.
			</property>
			<property name="quoteAllIdentifiers" type="boolean" required="false">
			    If selected, all column names are quoted.
				This means they are treated as case-sensitive if the database supports this option.  
				The typical use case is when a table is created with quoted column names.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				Specifies whether to write out all columns as defined in the input format. This
				attribute is exclusive to column definitions. If this value is set to on, then there
				must be no columns defined in the columns element, otherwise an error is reported.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.jms.filters.IJmsFilter">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.jms.JmsProviderComponentInstance$JmsFilterBean">
    <description>Filter definitions and their mapping to connections and input or output destinations. The following filters are available:
			<ul>
				<li>
          <strong>Jms Logging Filter</strong> - logs content of the request/response to the file</li>
				<li>
          <strong>Jms Response Time Logger</strong> - logs the time of the request processing to the logger</li>
			</ul>
		</description>
    <properties>
			<property name="filter" type="com.ataccama.dqc.jms.filters.IJmsFilter" required="false">Filter definition.</property>
			<property name="mappings" type="com.ataccama.dqc.jms.JmsProviderComponentInstance$FilterMappingBean[]" required="false">Limits the logging filter to specific connections and destinations. When no mapping (or mapping attribute) is present, the filter affects all connections and destinations.</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.jms.filters.IJmsFilter" name="com.ataccama.dqc.jms.filters.JmsLoggingFilter">
    <introduction>Logs content of the request/response to the file.</introduction>
    <description>Logs content of the request/response to the file.</description>
    <properties>
			<property name="appendLog" type="boolean" required="true">If true, then the content of the <strong>Log File</strong> is not removed on the server start. Otherwise, the content is removed.</property>
			<property name="logFile" type="string" required="false">File to log to.</property>
			<property name="logRequestContents" type="boolean" required="true">If true, logs request content.</property>
			<property name="logRequestHeaders" type="boolean" required="true">If true, logs request headers.</property>
			<property name="logResponseContents" type="boolean" required="true">If true, logs response content.</property>
			<property name="logResponseHeaders" type="boolean" required="true">If true, logs response headers.</property>
			<property name="maxRequestLogSize" type="integer" required="true">Maximum number of characters to be logged</property>
			<property name="maxResponseLogSize" type="integer" required="true">Maximum number of characters to be logged.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.jms.writer.JmsWorkerBase$JmsMessageModel"/>
  <class name="com.ataccama.dqc.jms.JmsProviderComponent">
    <introduction>Selects active connections from the JMS configuration pool and configures JMS loggers.</introduction>
    <description> Selects active connections from the JMS configuration pool and configures JMS loggers.</description>
    <properties>
			<property name="connectionPoolSize" type="integer" required="true">
				<p align="justify">Sets the number of threads that may concurrently process JMS requests received from all JMS connections defined.</p>
				<p align="justify">
					The level of parallelization may be decreased by the settings of the service that consumes messages from JMS queues/topics (e.g., minPoolSize/maxPoolSize settings in the <code>.online</code> files). If the <strong>Connection Pool Size</strong> is missing, the default value of 5 is used. The max size should be set reasonably with respect to the particular HW configuration and solution load. Keep in mind that a higher number might not yield higher throughput. Please do not use a number higher than 1000.
				</p>
			</property>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="filters" type="com.ataccama.dqc.jms.JmsProviderComponentInstance$JmsFilterBean[]" required="false">Filter definitions and their mapping to connections and input or output destinations. The following filters are available:
			<ul>
				<li>Jms Logging Filter - logs content of the request/response to the file</li>
				<li>Jms Response Time Logger - logs the time of the request processing to the logger</li>
			</ul>
      </property>
			<property name="jmsResources" type="string[]" required="false">Contains references to <code>jmsConnection</code> nodes
				defined in runtime configuration file. Only these connections are available to the Ataccama Server.</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.jms.filters.IJmsFilter" name="com.ataccama.dqc.jms.filters.JmsResponseTimeLogger">
    <introduction>Logs the time of the request processing to the logger.</introduction>
    <description>Logs the time of the request processing to the logger.</description>
    <properties>
			<property name="level" type="com.ataccama.dqc.commons.logging.appenders.Level" required="false">Severity level used for Jms Response Time Logger messages.</property>
			<property name="name" type="string" required="false">Name of the logger. The name is displayed in square brackets in the log.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.jms.writer.JmsWriter">
    <introduction>
			Sends the processed records as JMS messages.
		</introduction>
    <description>
			<p align="justify">Format of the message is configured by an expression template. Supports JMS message properties. Optional output passes processed records. <strong>Scorer</strong> may be configured to mark possible message transfer errors.</p>

			<p align="justify">It is necessary to copy proper JMS MQ implementation JAR to DQC classpath, e.g. <code>[DQC_HOME]\runtime\lib\</code>
      </p>
		</description>
    <properties>
			<property name="jmsResource" type="string" required="true">
			<p align="justify">Reference to JMS Server Resource in <strong>runtime configuration</strong>.</p>
			<p align="justify">JMS properties specific for Message Broker are specified there, e.g. Connection Factory class name,
			JNDIContextFactoryInitial, JNDIProviderURL.</p>
			</property>
			<property name="inputTemplate" type="string" required="true">
				Template defining structure of body of message.
			</property>
			<property name="textMessage" type="boolean" required="true">
				Determines whether the JMS message type is TextMessage or BytesMessage. By default it is enabled and TextMessage is used. Disable to use BytesMessage.
			</property>
			<property name="messageEncoding" type="string" required="true">
				Encoding used for the message.
			</property>
			<property name="messageProperties" type="com.ataccama.dqc.jms.writer.JmsWorkerBase$MessageProperty[]" required="false">
				Properties of the JMS message.
			</property>
			<property name="requestDestination" type="string" required="true">
				JMS destination which will receive messages.
			</property>
			<property name="requestDestinationType" type="com.ataccama.dqc.jms.writer.JmsWorkerBase$JmsMessageModel" required="true">
				Type of the destination. Possible values: <code>QUEUE</code> / <code>TOPIC</code>.
			</property>
			<property name="responseDestination" type="string" required="false">
				Value of &quot;ReplyTo&quot; JMS header. Defines destination for responses
				to this particular message. This information only tentative,
				the receiving counterparty may ignore it completely.
			</property>
			<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
				Standard DQC scorer.
			</property>
			<property name="templateBeginMark" type="string" required="true">
				Symbol marking the beginning of column placeholder.
			 </property>
			<property name="templateEndMark" type="string" required="true">
				Symbol marking the end of column placeholder.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
    <scoring>
			<scoringKey name="WLA_JMS_CONNECTION_ERROR">
				General JMS error.
			</scoringKey>
			<scoringKey name="WLA_BAD_MESSAGE_FORMAT">
				This error occurs when a JMS Writer attempts to use a data type not supported by a message.
			</scoringKey>
			<scoringKey name="WLA_INVALID_DESTINATION">
				 This error occurs when the destination is not understood by a provider or is no longer valid.
			</scoringKey>
			<scoringKey name="WLA_UNSUPPORTED_OPERATION">
				General internal error.
			</scoringKey>
			<scoringKey name="WLA_UNSUPPORTED_ENCODING">
				The Character Encoding is not supported.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.merge.Join">
    <introduction>Joins two separate data flows into a single data flow (vertical merge).</introduction>
    <description>
				This step joins two separate input data flows into a single output data flow based on corresponding
				input data flow keys.

				The data entry points (endpoints) are named respectively <code>in_left</code> and <code>in_right</code>.

				All data input flows (<code>in_left</code> and <code>in_right</code>) must contain columns with key values (primary keys),
				which are defined as column properties <code>leftKey</code> and <code>rightKey</code>.

				It is the keys that govern how the data records are paired up across the data input flows.
				All basic data types can be used as a key.

				The join operation can be defined as a standard SQL join operation with join types such as: <code>inner</code>, <code>outer</code>, <code>left</code>,
				and <code>right</code> join.

				The join type is specified by the property <code>joinType</code>, which must contain one of the supported join types.
				<br/>
      <br/>
				If the data input flow contains multiple records with the same key values, the data output flow
				will contain a Cartesian Product of data input records.
				<br/>
				Records having a <code>null</code> key value are not joined with any other (null keyed) records. Those records are processed as
				unpaired, depending on <code>joinType</code>.
				<br/>
      <br/>

				The content of the output data is the result of expressions operated on the conjuncted input data.
				In expressions, references to the particular columns must be made by dot notation (<code>in_left.*</code>, <code>in_right.*</code>).

				The step first groups input records by key values and computes the Cartesian Product for all records for each group.
				Then, the <code>expression</code> sub-properties defined in the <code>columnDefinition</code> properties are evaluated
				to determine the result records of the Cartesian Product.

				Results of these operations are stored in the column defined by the sub-property <code>name</code> of the property <code>columnDefinition</code>.

				In case of the join operations <code>left</code>, <code>right</code> or <code>outer</code>, for which a record from an input flow
				might be empty, input column values of such empty records are transformed to <code>null</code> values before expression evaluation.
				<br/>
      <br/>
				<strong>NOTE: </strong>
				<p align="justify">• Only data that is defined in the sub-properties <code>expressions</code> of the <code>columnDefinition</code> properties are written
				to the output. If the property <code>columnDefinitions</code> is empty or missing, then the output remains empty.
				(Though the previous versions of the step generated a default set of <code>columnDefinitions</code>, the current version requires explicit definition of all of the <code>columnDefinitions</code>.)</p>
				<p align="justify">• Not only string type is supported for values in <code>Left Key</code> and <code>Right Key</code>.  Alternatively you can use any data type based on the input column or apply an expression transformation.</p>
				
			</description>
    <properties>
				<property name="id" type="string" required="false">
			Step identification string.
			</property>
				<property name="leftKey" type="string" required="true">
				Column that contains key values of the left (first) input flow. The keys are used in conjunction. Alternatively you can use <code>expressions</code> in order to put condition on joining key values.
				</property>
				<property name="rightKey" type="string" required="true">
				Column that contains key values of the right (second) input flow. The keys are used in conjunction. Alternatively you can use <code>expressions</code> in order to put condition on joining key values.
				</property>
				<property name="columnDefinitions" type="com.ataccama.dqc.tasks.merge.ColumnDefinition[]" required="false">
				Set of <code>columnDefinition</code> properties which define operations executed on the conjuncted input data, also the output data.
				</property>
				<property name="joinType" type="com.ataccama.dqc.tasks.merge.JoinType" required="true">
				Specifies which type of conjunction to perform on the input data.
				</property>
				<property name="matchStrategy" type="com.ataccama.dqc.tasks.merge.MatchStrategy" required="true">
				Specifies technique used for records pairing.
				</property>
			</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.merge.RdJoin$JoinMode"/>
  <class name="com.ataccama.dqc.tasks.merge.JoinType">
    <description>
			The type of join operation used to join the data. The four join types available
			in the product correspond to the standard join types defined in SQL92.
		</description>
  </class>
  <class name="com.ataccama.adt.task.base.JschSessionParameter">
    <description>Set of parameters to customize a JSch session.</description>
    <properties>
			<property name="name" type="string" required="true">Parameter name.</property>
			<property name="value" type="string" required="true">Parameter value.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.call.JsonCall">
    <introduction>For each record calls specified online service, possibly
			sending a JSON
			message with the request, and parses the response JSON
			it receives.
		</introduction>
    <description>
			The step calls online service installed on the
			<code>Url</code>
			. For POST and PUT methods, the request body is built using
			<code>Input Template</code>
			. In both cases, nested DQC expressions (marked with begin and end
			strings specified) are evaluated
			for each record. The response is
			expected to be in JSON format and
			therefore the values can be
			extracted
			using JSON Reader approach. For details on JSON Reader refer
			to the
			<strong>documentation</strong>
			.
			Besides the reader&#39;s endpoints, the endpoint &quot;out&quot; is available to
			copy
			input stream of data, allowing scoring and additional processing.<br/>
      <br/>
			<strong>Support for Hadoop Kerberos-based Authorization</strong>
      <br/>
			<p align="justify">You can connect to server with Kerberos authorization using <code>jsonCall.kerberos.principal</code> and <code>jsonCall.kerberos.keytab</code> Java arguments.
					When arguments mentioned above are applied authorization of the server that Json Call Step links to will be ignored. Kerberos will be used.</p>
			<strong>Support for Hadoop Knox SSO Authorization</strong>
      <br/>
			<p align="justify">When you are using Json Call step in <strong>ONE IDE</strong> accessing cluster that is secured by <strong>Knox SSO</strong> authentication you need to define the following JVM argument in Java.<br/>
		<example>
          <pre>
-DjsonCall.knox.sso.url=https://&lt;knox_host&gt;:8443/gateway/knoxsso/api/v1/websso</pre>
			</example>
			</p>
			<strong>Support for Mutual TLS (mTLS) Authentication</strong>
      <br/>
			<p align="justify">To enable using mutual TLS authentication, where client certificates are verified in addition to server certificates, the following Java arguments need to be provided:</p>
			<ul>
				<li>
					<code>javax.net.ssl.keyStore</code>: Points to the keystore containing the client certificate and the corresponding private key. This can also be a <code>.p12</code> file.
				</li>
				<li>
					<code>javax.net.ssl.keyStorePassword</code>: The password for the keystore.
				</li>
			</ul>
      <br/>
      <br/>
			<strong>Troubleshooting Execution of JSON Call Step</strong>
      <br/>
			<p align="justify">When JSON Call step returns no response but the debug request files is created correctly, check SSL settings whether both Root and Sub CA certificates are added. You can add those using the Keytool in Command Line.<br/>
			Add the following lines to Run Configurations | Runtimes | VM Arguments to:</p>
			<ul>
				<li>
					Check whether this issue is related to certificates, add <code>[-Dcom.sun.net|http://dcom.sun.net/]{{.ssl.checkRevocation=false}}</code>
				</li>
        <br/>				
				<li>
					Debug SSL settings, add <code>[-Djavax.net|http://djavax.net/].debug=ssl,handshake,trustmanager{{}}[~accountid:nnnnn:accountid]</code>
				</li>				
			</ul>
      <br/>
    </description>
    <properties>
			<property name="url" type="string" required="false">
				The target URL
				of the service to be called. Is a DQC template - can use nested DQC
				expressions that will be
				evaluated for each record.
				If URL resource is specified, this URL will be appended to URL defined
				in URL resource.
			</property>
			<property name="urlResource" type="string" required="false">
				Name of the URL resource to be used.
			</property>
			<property name="method" type="com.ataccama.dqc.tasks.io.json.call.JsonCall$HTTPMethod" required="true">
				The HTTP method to be used.
			</property>
			<property name="inputTemplate" type="string" required="false">
				The JSON
				message that will be sent for POST, PUT, PATCH and DELETE methods (no message is
				sent for GET method). Is a DQC template - can use nested DQC
				expressions that will be
				evaluated for each record.
			</property>
			<property name="encoding" type="string" required="true">
				The encoding in
				which the JSON message will be sent.
			</property>
			<property name="headers" type="com.ataccama.dqc.tasks.io.json.call.JsonCall$Header[]" required="false">
				Additional HTTP headers that will be set for the request.
			</property>
			<property name="timeoutMs" type="long" required="true">
				If the call of the service takes longer time than the Timeout (ms) then the call is aborted.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				Data formats for formatting nested DQC expressions to strings. For
				details refer to the
				<strong>DataFormatParameters</strong>
				section.
			</property>
			<property name="urlBeginMark" type="string" required="true">
				The string that
				marks begin of nested DQC expression in URL template.
			</property>
			<property name="urlEndMark" type="string" required="true">
				The string that
				marks end of nested DQC expression in URL template.
			</property>
			<property name="templateBeginMark" type="string" required="true">
				The string that
				marks begin of nested DQC expression in input template.
			</property>
			<property name="templateEndMark" type="string" required="true">
				The string that
				marks end of nested DQC expression in input template.
			</property>
			<property name="responseDebugFile" type="string" required="false">
				The responses can be written into the file. If the file name contains a percent character
				then it is replaced by the number of the record for which the response was generated.
				If a file with the same name exists then it is rewritten.
			</property>
			<property name="requestDebugFile" type="string" required="false">
				The same as <code>Response Debug File</code> but for the request.
			</property>
			<property name="reader" type="com.ataccama.dqc.tasks.io.json.reader.JsonReader" required="true">
				The reader used for parsing the JSON responses. For details refer to
				the
				<strong>JSON Reader</strong>
				section.
			</property>
			<property name="delayBetweenRequestsMs" type="long" required="true">
				Sometimes when calling an outside service it is needed to make some pauses
				between requests in order not to get banned for DOS attack. The value is in milliseconds.
			</property>
			<property name="responseCodeColumn" type="integer" required="false">
				Column where the HTTP status code of the response should be stored.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
			<scoringKey name="WLA_TIMEOUT">
				Indicates timeout occurred while
				performing the call.
			</scoringKey>
			<scoringKey name="WLA_TARGET_UNREACHABLE">
				Indicates error in the communication with
				the target host.
			</scoringKey>
			<scoringKey name="WLA_RESPONSE_CODE">
				Indicates invalid (non-OK) response code.
			</scoringKey>
			<scoringKey name="WLA_INVALID_JSON">
				Indicates that the response message
				couldn&#39;t be parsed as JSON.
			</scoringKey>
		</scoring>
  </class>
  <class super="com.ataccama.ai.commons.steps.column.FeatureColumn" name="com.ataccama.ai.commons.steps.column.JsonFeatureColumn">
    <introduction>Feature is parsed from json.</introduction>
    <properties>
            <property name="expression" type="string" required="true">
                Column, that contains json with wanted feature.
            </property>
            <property name="property" type="string" required="true">
                Name of the json property, that contains the feature.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.JsonOutputProfilingAlgorithm">
    <introduction>Computes statistics and other data analysis measures.</introduction>
    <description>
				<p align="justify">
					This profiling step is used in statistical analysis of data.
					For each data column this step will compute
					statistics (values) such as minimum, maximum, standard and error values.
				</p>
				<p align="justify">
					The profiling step is capable of multiple analytical operations
					in a single pass over multiple columns of input data.<br/>
					All date types supported by [branding:product.name.abbreviation] can be specified as long as they correspond
					to the applied date operations.<br/>
        <br/>
					<table border="1">
						<th>
							<th/>
							<th>INTEGER, LONG</th>
							<th>DAY, DATETIME</th>
							<th>BOOLEAN</th>
							<th>STRING</th>
						</th>
						<tr>
							<td>Data Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Null Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Not Null Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Different Value Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Unique Value Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>
              <br/>
            </td>
							<td/>
							<td/>
							<td/>
							<td/>
						</tr>
						<tr>
							<td>Sum</td>
							<td>yes</td>
							<td>-</td>
							<td>yes</td>
							<td>-</td>
						</tr>
						<tr>
							<td>
								Variance
								<a href="http://en.wikipedia.org/wiki/Variance#Definition" target="_blank">
									Definition
								</a>.
								Result for DAY/DATETIME values are in squared days.
							</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
							<td>-</td>
						</tr>
						<tr>
							<td>
								Standard Deviation
								<a href="http://en.wikipedia.org/wiki/Standard_deviation#Definition_and_calculation" target="_blank">
									Definition
								</a>.
								Result for DAY/DATETIME values are in days.
							</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
							<td>-</td>
						</tr>
						<tr>
							<td>
              <br/>
            </td>
							<td/>
							<td/>
							<td/>
							<td/>
						</tr>
						<tr>
							<td>Average</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
						</tr>
						<tr>
							<td>Median</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Quantile</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>
              <br/>
            </td>
							<td/>
							<td/>
							<td/>
							<td/>
						</tr>
						<tr>
							<td>Maximum</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Minimum</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>
              <br/>
            </td>
							<td/>
							<td/>
							<td/>
							<td/>
						</tr>
						<tr>
							<td>First X Values</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Last X Values</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
					</table>
				</p>
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="inputs" type="com.ataccama.dqc.tasks.profiling.config.ProfilingInput[]" required="true">
			List of input sources on which the profiling is performed. Each element needs an 
			appropriate input endpoint.
			</property>
			<property name="fkAnalysis" type="com.ataccama.dqc.tasks.profiling.config.FkAnalysis[]" required="false">
			List of definitions of foreign key analyses.
			</property>
			<property name="defaultLocale" type="string" required="false">
			Locale represents a specific geographical, political, or cultural region, with respect
			to data parsing and comparison as performed by the step.<br/>
			Default value: <code>en_US</code>
			</property>
			<property name="outputFile" type="string" required="true">
			Filename of the result file where the profile results will be stored.
			</property>
			<property name="exportFile" type="string" required="false">
			XML or JSON file where the profile results will be exported.
			</property>
			<property name="outputLimit" type="integer" required="true">
			Specifies the maximum number of frequency records being stored into the output.
			The parameter is applied on both most frequent values
			and least frequent values.
			The amount of data is thus at most twice as this value.
			The value is applicable only to results of frequency and group size analysis
			and is applied to all profiled data separately.
			If the value is set to zero, number of stored records is unlimited.
			<br/>
			Default value: <code>1000</code>
			</property>
			<property name="dataSource" type="string" required="false">
			Data source name of database for storing drill-through data.
			Required when at least one <code>input</code> has specified <code>Drill-through</code>.
			</property>
			<property name="tableNamePrefix" type="string" required="false">
			Prefix for names of database tables to which drill-through data will be stored.
			Required when at least one <code>input</code> has specified <code>Drill-through</code>.
			</property>
			<property name="masks" type="com.ataccama.dqc.tasks.profiling.config.MaskCfg[]" required="false">
			List of mask definitions.
			</property>
			<property name="domains" type="com.ataccama.dqc.tasks.profiling.config.DomainAnalysisCfg" required="true">
			Specifies which and how domain analysis will be performed.
			</property>
			<property name="userMetadata" type="com.ataccama.dqc.tasks.common.config.UserMetadata" required="true">
			Additional metadata appended to result file.
			</property>
			<property name="threaded" type="boolean" required="true">
			Specifies whether the step will perform calculations in single thread (one after one)
			or in multiple-threads (parallel processing).
			</property>
			<property name="exportToEndpoint" type="boolean" required="true">
			If checked, the step exports its output in JSON format to an endpoint called
			<code>out</code>.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.parser.JsonParser">
    <introduction>Parses JSON strings from input stream and puts them into one or more output end points.</introduction>
    <description>
		This step is similar to the <strong>JSON Reader step</strong>.
		It can create several output streams from input stream containing JSON strings. Rows of one output stream can be
		logically children to rows from another stream of rows. For example let&#39;s assume input JSON contains set
		of clients and each client has several addresses. Such record can be read as a stream of clients
		and another stream of addresses, where each address can have an id taken from the client stream (for
		further identification of the corresponding client). Each stream can also use shadow columns and referencing
		values from other columns of the input stream for further identification of particular records.

		The input stream passes through to the default output &quot;out&quot;, with the possibility to specify a column <code>Parsing Error Column</code> that will
		be filled with explanation in case of an error parsing the associated JSON.
		</description>
    <properties>
			<property name="inputColumn" type="string" required="true">
				The input column containing JSON strings to be parsed.
			</property>
			<property name="parsingErrorColumn" type="string" required="false">
				Column for detecting JSON parsing errors. This column is available in the default output &quot;out&quot;.
			</property>
			<property name="dataStreams" type="com.ataccama.dqc.tasks.io.json.stream.RootJsonStreamConfig[]" required="true">
				Output end points defined on the root level.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				Data formats for parsing string JSON fields into DQC data types. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.reader.JsonReader">
    <introduction>Reads file in JSON format and puts its content into multiple streams of data.</introduction>
    <description>
		</description>
    <properties>
			<property name="fileName" type="string" required="true">
				The input file.
			</property>
			<property name="encoding" type="string" required="true">
				The encoding of the input file.
			</property>
			<property name="dataStreams" type="com.ataccama.dqc.tasks.io.json.stream.RootJsonStreamConfig[]" required="true">
				Output end points defined on the root level.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				Data formats for parsing string JSON fields into DQC data types. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.writer.JsonWriterAlgorithm">
    <introduction>Creates a JSON file from data stream(s), based on given templates and hierarchical structure of the streams. Output is an array of JSON objects.</introduction>
    <description>
			<p align="justify">This step creates output JSON file according to the templates. Without any advanced configuration,
			the template is simply written to the output file. For filling it dynamically with some data, we will
			need objects.</p>
			<p align="justify">An object is a stream of records, and the columns of the records are attributes
			of this object. When a new object is added, a new input of the same name is automatically created for reading
			these records. When we do have an object and we connect a data stream to its input, we can use it in the template.
			This is simply done by including an property surrounded by &quot;&lt;&quot; and &quot;&gt;&quot; with the same name as the object. That causes this property to be
			entirely replaced by the JSON representation of the object - actually, by array (one object = one record read from input) or single JSON object read from the input.</p>
			<p align="justify">The JSON representation of the object is done in very similar way - by its own JSON template. But here, we are inside the object,
			and we can use its attributes - columns of the original records - as text values. Attribute is
			referenced by its name in surrounded by &quot;%&quot; (e.g. &quot;%value%&quot;).</p>
			<p align="justify">It is also possible to reference subobject&#39;s properties. Syntax is the same as usual property with substream prefix (e.g. &quot;%stream.property%&quot;).</p>
			<p align="justify">Sometimes unquoted value of attribute is needed, adding extra equals sign at the beginning and end will discard quotes (e.g. &quot;%=value=%&quot; or &quot;%=stream.property=%&quot;).
			In that case formatting rules do not apply as valid JSON must be generated.</p>
			<p align="justify">JSON template of objects is a standalone JSON and that&#39;s why it is validated as a standard JSON structure.</p>
			<p align="justify">Any object can have subobjects - more complex attributes that are read from their own input streams and are joined with parent
			object exactly the same way as in inner join of tables. The attributes/columns for join are specified in the inner objects, in
			the parameter <code>Column Binding</code>. Inner objects are objects as well and can also have subobjects, etc.</p>
			<p align="justify">This step supports encodings supported by Java, including Unicode formats. Available encodings are listed in step configuration.</p>
		</description>
    <properties>
			<property name="fileName" type="string" required="true">
				Name of the output JSON file.
			</property>
			<property name="encoding" type="string" required="true">
				File data encoding. The possible encodings are all encodings supported by the
				target Java platform. Some commonly used encodings are: ISO-8859-1,
				ISO-8859-2, and UTF-8.
			</property>
			<property name="rootObject" type="com.ataccama.dqc.tasks.io.json.writer.JsonWriterObjectStreamCfg" required="true">
				Root object for the final JSON structure. Each record from input stream will create single root object in the final JSON file.
			</property>
			<property name="indenting" type="boolean" required="true">
				When this is set, the output JSON will be in human readable form, indented multi-line. Uncheck this for smaller size of the file.
			</property>
			<property name="includeNull" type="boolean" required="true">
				When this is set, the output JSON will include properties even with null values. When unchecked, properties with null values will be ignored in the output.
			</property>
			<property name="maximumRecordsInMemory" type="integer" required="true">
				For each inner object, all its records are stored in the memory until this limit is reached; after that, they are stored
				in an external file, which is slower.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				Contains data formatting information for the whole step, unless there is another such attribute specified at certain
				object stream, in which case the latter will be used for that object stream and all its substreams. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.writer.JsonWriterObjectStreamCfg">
    <description>
			Definition of a single object - one kind of records read from its own input.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Object name (also name of the associated input and name of the element that&#39;s being replaced by this object).
			</property>
			<property name="template" type="string" required="true">
			    JSON template for this object.
			</property>
			<property name="type" type="string" required="true">
			   	Type of the object (array or object). If object selected and more values are available, only first value will go to output.
			</property>
			<property name="subObjects" type="com.ataccama.dqc.tasks.io.json.writer.JsonWriterObjectSubStreamCfg[]" required="true">
				Subobjects of this object.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Contains data formatting information for this object stream and all its substreams. If specified, overrides any data format parameters
				inherited from parents. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.writer.JsonWriterObjectSubStreamCfg">
    <description>
			Definition of a single object - one kind of records read from its own input.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Object name (also name of the associated input and name of the element that&#39;s being replaced by this object).
			</property>
			<property name="template" type="string" required="true">
			    JSON template for this object.
			</property>
			<property name="type" type="string" required="true">
			   	Type of the object (array or object). If object selected and more values are available, only first value will go to output.
			</property>
			<property name="subObjects" type="com.ataccama.dqc.tasks.io.json.writer.JsonWriterObjectSubStreamCfg[]" required="true">
				Subobjects of this object.
			</property>
			<property name="columnBinding" type="string" required="true">
				Binding of this subobject to the parent object (basically &quot;join on&quot; clause). Syntax is &quot;parentColumn=childColumn&quot;.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Contains data formatting information for this object stream and all its substreams. If specified, overrides any data format parameters
				inherited from parents. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.streaming.io.reader.IKafkaInputFormat"/>
  <class name="com.ataccama.dqc.streaming.io.writer.IKafkaOutputFormat"/>
  <class name="com.ataccama.dqc.streaming.io.KafkaProperty">
    <description>
			List of properties for Kafka consumer/producer. Some of them are predefined with default values but these values can be overridden. Also new values can be added. Full list of Kafka consumer/producer properties is <a href="http://kafka.apache.org/documentation.html#configuration" target="_blank">here</a>.
		</description>
    <properties>
			<property name="key" type="string" required="true">Key of the Kafka	producer property.</property>
			<property name="value" type="string" required="true">Value of Kafka	producer property.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.streaming.io.KafkaPropertyEncrypted">
    <description>Kafka encrypted properties for consumer.  Such as (<code>ssl.key.password</code>, <code>ssl.keystore.password</code>, <code>ssl.truststore.password</code>, etc).</description>
    <properties>
			<property name="key" type="string" required="true">Key of the Kafka producer encrypted property.</property>
			<property name="value" type="string" required="true">Value of Kafka producer encrypted  property.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.streaming.KafkaProviderComponent">
    <introduction>Kafka provider component enables using Kafka as a source and target for online service components.</introduction>
    <description>Kafka provider component enables using Kafka as a source and target for online service components.</description>
    <properties>
            <property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
            <property name="kafkaResources" type="string[]" required="false">References to the defined Kafka server connections.</property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.streaming.io.reader.KafkaReader">
    <introduction>
			Consumes messages from the distributed messaging system	<a href="http://kafka.apache.org/" target="_blank">Kafka</a>.
		</introduction>
    <description>
			<p align="justify">
				Kafka Reader step consumes messages from the specified Kafka topics. Consumer is identified by a <code>Group Id</code>
				property. Distributed consuming is possible using the same <code>Group Id</code>.
			</p>
			<p align="justify">
				By default, Kafka Reader has enable.auto.commit property set to true and commits read messages over time. 
				After it has finished reading the messages, Kafka Reader step ensures that all the messages were committed.
				To guarantee &quot;At Least Once&quot; semantics it is possible to use DQC Transactional Model.
				In this case commit of the read messages will be done only after the whole processing has finished. 
				To enable DQC Transactional Model you will need to send the following Java property while starting plans containing Kafka Reader steps: -Dtransaction.coordinator=explicit
			</p>
		</description>
    <properties>
			<property name="server" type="string" required="true">
				The name of the	source server which runs Kafka.
			</property>
			<property name="topics" type="string" required="true">
				The name of the Kafka topics (source of the messages), separated by comma.
			</property>
			<property name="groupId" type="string" required="true">
				ID of the Kafka consumer group.
			</property>
			<property name="timeout" type="string" required="true">
				The time, in milliseconds, spent waiting for records of the topic. It should not be too small, for instance at least 100 ms.
				Must not be negative. If 0, returns immediately with any records that are available currently in the buffer, else returns empty.
			</property>
			<property name="pollOnce" type="string" required="true">
				This option causes reading records of the topics only within one poll request. It could be used if user does not want to wait for new messages.
				If there are no new records with regard of Group Id it waits for them until timeout.
				It is independent on timeout.
			</property>
			<property name="readFromBeginning" type="string" required="true">
				Read all available records of the topic. Before the read, seek to the first offset for all of the currently assigned partitions. Could be used for development and debugging purposes to guarantee consistent reads.
			</property>
			<property name="encoding" type="string" required="true">
				Encoding of characters in the topic. You can use any encoding supported by the target Java platform. Some commonly used encoding sets are ISO-8859-1, ISO-8859-2 and UTF-8.
			</property>
			<property name="inputFormat" type="com.ataccama.dqc.streaming.io.reader.IKafkaInputFormat" required="true">
				Input format of the consuming message.
			</property>
			<property name="properties" type="com.ataccama.dqc.streaming.io.KafkaProperty[]" required="false">
				Kafka properties for consumer. List of all possible properties is <a href="http://kafka.apache.org/documentation.html#consumerconfigs" target="_blank">here</a>.
			</property>
			<property name="propertiesEncrypted" type="com.ataccama.dqc.streaming.io.KafkaPropertyEncrypted[]" required="false">Kafka encrypted properties for consumer.  Such as (<code>ssl.key.password</code>, <code>ssl.keystore.password</code>, <code>ssl.truststore.password</code>, etc).
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.streaming.io.writer.KafkaWriter">
    <introduction>
			Publishes messages to the distributed messaging system
			<a href="http://kafka.apache.org/" target="_blank">Kafka</a>.
		</introduction>
    <description>
			<p align="justify">Kafka Writer step publishes messages to a specified topic in Kafka. Format of the message is described by the expression template.</p>
			<p align="justify">If the topic does not exist yet, a new one is created with 1 partition and replication factor 1. Alternatively, it is possible to create a topic with multiple partitions or multiple replicas using the &quot;Create topic&quot; button.</p>
			<p align="justify">
				User can define a key for routing a message to the partitions. This key (<code>Partition Key</code>) is an expression. Partition is decided based on the hash of the	compiled key.
			</p>
		</description>
    <properties>
			<property name="server" type="string" required="true">
				The name of the source server which runs Kafka.
			</property>
			<property name="topic" type="string" required="true">
				The name of the Kafka topic where the message should be published.
			</property>
			<property name="partitionKey" type="string" required="false">
				Expression for key which is used for partitioning.
			</property>
			<property name="encoding" type="string" required="true">
				Encoding of characters sent to the topic. You can use any encoding supported by the target Java platform. Some commonly used encodings are ISO-8859-1, ISO-8859-2 and UTF-8.
			</property>
			<property name="outputFormat" type="com.ataccama.dqc.streaming.io.writer.IKafkaOutputFormat" required="true">
				Output format specification of produced messages.
			</property>
			<property name="properties" type="com.ataccama.dqc.streaming.io.KafkaProperty[]" required="false">
				Kafka properties for connection. List of all possible properties is <a href="http://kafka.apache.org/documentation.html#newproducerconfigs" target="_blank">here</a>.
			</property>
			<property name="propertiesEncrypted" type="com.ataccama.dqc.streaming.io.KafkaPropertyEncrypted[]" required="false">Kafka encrypted properties for consumer.  Such as (<code>ssl.key.password</code>, <code>ssl.keystore.password</code>, <code>ssl.truststore.password</code>, etc).</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.components.Key">
    <description>List of components that define the composite key.</description>
    <properties>
			<property name="components" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">List of components that define the composite key.</property>
			<property name="expression" type="string" required="false">
Expression calculating the key component value. Non-string values are converted into string. Column specification in the expressions is done by dot notation.
			</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.rjoin.RefJoin$KeyColumnMapping">
    <description>
			Defines mapping between input column(s) and column used in search key(s) defined in reference source.
		</description>
    <properties>
			<property name="column" type="string" required="true">
				Column from reference source used in search key.
			</property>
			<property name="expression" type="string" required="true">
				Input value assigned to reference data column. 
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.components.KeyComponent">
    <properties>
			<property name="expression" type="string" required="true">
				Expression calculating one key component value. Non-string values are converted into string.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.common.group.AbstractGroupingStrategy" name="com.ataccama.dqc.tasks.common.group.KeyGroupingStrategy">
    <properties>
			<property name="groupBy" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
				List of key components.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.mdu.MduKeyRule">
    <description>
      	Definition of a set of Components and set of Matching Rules.<br/>
      	A record is matched to another record only when they share the same values in all the columns defined as a Key Component and when at least one Matching Rule condition is satisfied.
      	The Key Rules are processed sequentially (if no parallelism used); even if a record is matched to another record due to satisfying a certain Key Rule, all other Key Rules will be checked anyway.
      </description>
    <properties>
          <property name="components" type="com.ataccama.dqc.tasks.common.components.UnionKeyComponent[]" required="true">List of Key Components.</property>
          <property name="matchingRules" type="com.ataccama.mdu.MduMatchRule[]" required="false">List of Matching Rules.</property>
          <property name="noEmptyComponent" type="boolean" required="true">Specifies that all components have to be valid (non-null) to conform a valid key. If false (default) and at least one component is non-null, the key is valid and will be used. </property>
          <property name="noKeyCond" type="string" required="false">Condition specifying whether this key is assumed to be unusable and is therefore not used as a matching key in candidate group collection. </property>
          <property name="name" type="string" required="false">Name used as output matching rule name when no matching rules are specified (using whole key groups). </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.web.security.KeycloakSecurity">
    <introduction>Authentication is managed by Keycloak. This is the only recommended implementation.</introduction>
    <description>Authentication is managed by Keycloak. This is the only recommended implementation.</description>
    <properties>
			<property name="deploymentContexts" type="com.ataccama.server.http.security.keycloak.IdentityProvider[]" required="false">Authentication is managed by Keycloak. This is the only recommended implementation.</property>
			<property name="interceptUrls" type="com.ataccama.server.http.security.InterceptUrl[]" required="false">Setting maps URL patterns to the access conditions.</property>
			<property name="loginUrl" type="string" required="false">URL of your login page.</property>
		</properties>
  </class>
  <class name="com.ataccama.server.http.security.keycloak.KeycloakSecurity">
    <introduction>Authentication is managed by Keycloak. This is the only recommended implementation.</introduction>
    <description>Authentication is managed by Keycloak. This is the only recommended implementation.</description>
    <properties>
			<property name="identityProviders" type="com.ataccama.server.http.security.keycloak.IdentityProvider[]" required="false">Authentication is managed by Keycloak. This is the only recommended implementation.</property>
			<property name="interceptUrls" type="com.ataccama.server.http.security.InterceptUrl[]" required="false">Setting maps URL patterns to the access conditions.</property>
			<property name="loginUrl" type="string" required="false">URL of your login page.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.file.operations.EwfListFilesOperation">
    <introduction>Saves listing of a source folder to task variable.</introduction>
    <description>Saves listing of a source folder to task variable <code>list</code>. The values are separated by specified separator string. There is also extended listing supported
		which contains additional information for each item separated by extra separator. In that case values are in order full name, type (&#39;D&#39; for directory, &#39;F&#39; for file), last modified time
		(in format <code>yyyy-MM-dd HH:mm:ss</code>) and size in bytes. So for example <code>C:\data\test.txt|F|2023-10-08 12:30:50|45120;C:\data\images|D|2023-05-11 05:00:11|0</code>
		</description>
    <properties>
			<property name="sourceFolder" type="string" required="true">Path to the source folder. The task fails when the source does not exist.</property>
			<property name="mask" type="string" required="true">File name mask used to select files and/or folders to list.</property>
			<property name="listFiles" type="boolean">Include files in listing.</property>
			<property name="listFolders" type="boolean">Include folders in listing.</property>
			<property name="recursiveFlag" type="boolean">List also contents of any sub-directories. All sub-directories will be scanned regardless of mask or condition.</property>
			<property name="itemSeparator" type="string" required="true">String separating found items in resulting variable value.</property>
			<property name="extendedListing" type="boolean">Generate extended listing with full name, type (&#39;D&#39; for directory, &#39;F&#39; for file), last modified time (in format <code>yyyy-MM-dd HH:mm:ss</code>) and size in bytes.
			For example <code>C:\data\test.txt|F|2023-10-08 12:30:50|45120;C:\data\images|D|2023-05-11 05:00:11|0</code>
      </property>
			<property name="infoSeparator" type="string" required="true">String separating extended information items for each file in result.</property>
			<property name="continueOnError" type="boolean">When specific file or folder information cannot be used, report to log and continue, do not fail the task.</property>
			<property name="condition" type="string">Expression evaluated for each candidate entry to check if it should be included in output or not. Supports following variables:
				<ul>
					<li>
            <code>name</code> (<code>string</code>) - filename of the item</li>
					<li>
            <code>fullName</code> (<code>string</code>) - full name of the item, contains complete path</li>
					<li>
            <code>isDirectory</code> (<code>boolean</code>) - true if item is directory, false otherwise (when it is file)</li>
					<li>
            <code>size</code> (<code>long</code>) - item size in bytes</li>
					<li>
            <code>timestamp</code> (<code>date/time</code>) - item last modified time</li>
				</ul>
				Note that not all filesystems return all the properties so some of them can be empty (<code>null</code>).
			</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.adt.task.iterators.order.IOrder" name="com.ataccama.adt.task.iterators.order.LastModifiedOrder">
    <introduction> </introduction>
    <description> </description>
    <properties>
			<property name="reverse" type="boolean" required="true"> </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.communication.auth.server.ILdapAttribute">
    <properties/>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.IPasswordBasedIdentityProvider" name="com.ataccama.dqc.communication.auth.server.LdapIdentityProvider">
    <introduction>Retrieves identity information from the LDAP source.</introduction>
    <description>Retrieves identity information from the LDAP source.</description>
    <properties>
			<property name="attributes" type="com.ataccama.dqc.communication.auth.server.ILdapAttribute[]" required="false">Attribute resolvers are used to read and assign the attribute value to the parameter. This attribute value is later accessible from the running plan using getParameterValue() function.</property>
			<property name="authPass" type="string" required="false">Password for the user specified in <strong>Auth User</strong> parameter.</property>
			<property name="authType" type="string" required="false">Value specifying the security level to use. The value is one of the following strings: &quot;none&quot;, &quot;simple&quot;, &quot;strong&quot;.</property>
			<property name="authUser" type="string" required="false">Name of the user identity used for initial access to the LDAP source when looking for the user node corresponding to the user who is authenticating.</property>
			<property name="basePath" type="string" required="false">All search queries in the LDAP source will be done in the subtree defined by this path.</property>
			<property name="dnAttribute" type="string" required="false">Sets the name of the attribute that stores the user&#39;s distinguished name. Defaults to &#39;distinguishedName&#39; as it is used by <code>ActiveDirectory</code>.</property>
			<property name="ldapContextFactoryClass" type="string" required="false">Factory class name that should be used to create LDAP Context. If left unspecified, the component will try to use factory specified in the <code>LdapIdentityProvider.contextFactory</code> system property or it will use the default <code>com.sun.jndi.ldap.LdapCtxFactory</code>.</property>
			<property name="roleResolvers" type="com.ataccama.dqc.communication.auth.server.ILdapRoleResolver[]" required="false">Group resolvers are used to retrieve names of the authenticated user groups. For each group there will be created a role with the same name as the group. Possible implementations: Group By Member Resolver, Member Attribute Resolver, Reverse Member Attribute Resolver, Umc Role Resolver.</property>
			<property name="urls" type="string[]" required="false">Subelements that define URL locations of the LDAP source which will be queried in order to resolve users identity.</property>
			<property name="userQuery" type="string" required="false">Defines the search query which finds the user node in the LDAP source. In the query you can use ${login} which will be replaced by the users login name from the HTTP authentication header.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.communication.auth.server.ILdapRoleResolver">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.commons.logging.appenders.Level">
    <description>Levels of logging messages.</description>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.supervised.regression.LinearRegressionTrainerConfig" name="com.ataccama.dqc.tasks.ai.supervised.regression.definition.LinearRegressionOlsTrainerConfig">
    <introduction>Model using Ordinary Least Squares Multiple Linear Regression method.</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.supervised.regression.LinearRegressionTrainerConfig">
    <introduction>Type of regression model.</introduction>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.supervised.regression.LinearRegressionTrainerConfig" name="com.ataccama.dqc.tasks.ai.supervised.regression.definition.LinearRegressionXgboostTrainerConfig">
    <introduction>Model using XGBoost to do the actual regression. Usually better results compared to Ordinary Least Squares model, especially when training
            using small
            datasets (~1000 instances and less).
        </introduction>
    <properties>
            <property name="learningRate" type="float" required="true">
                Step size shrinkage used in update to prevents overfitting. Learning rate shrinks the feature weights to make the boosting process more
                conservative. Default value = 0.1. Valid values &gt;0 and smaller or equal to 1.
            </property>
            <property name="numberOfRounds" type="integer" required="true">
                Number of boosting iterations. Valid values &gt;0. Default value = 1000.
            </property>
            <property name="earlyStopping" type="integer" required="true">
                If non-zero, training would be stopped after a specified number of consecutive increases evaluation metric.
                If for example = 10, if training error does not improve in 10 consecutive rounds, training is stopped.
                Default value = 10;
            </property>
        </properties>
  </class>
  <class name="com.ataccama.adt.internal.core.model.EwfLinkElement">
    <introduction>Link</introduction>
    <description>Link</description>
    <properties>
			<property name="condition" type="string" required="false">
			Condition of a link. The target task of the link will be run only if the condition on the link is satisfied.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.text.ListOfValue">
    <description>
					Reference to the lookup by its symbol and file name.

					When performing lookup operation, matching value pairs are obtained, comprised of the dictionary key
					and the lookup key.
		</description>
    <properties>
			<property name="fileName" type="string" required="true">
			Lookup file name (relative or full path on disk, .lkp file).
			</property>
			<property name="symbol" type="string" required="false">
			Lookup label/symbol used to replace all tokens contained within the lokup.
			</property>
			<property name="frequency" type="integer" required="false">
			Column containing number of words found in lookup from current record.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.config.ListenerBean">
    <description>Defines listener threads that receive requests on the specified TCP ports and specifies if the listener should communicate via SSL or not. It is possible to define several listeners, each of them accepting requests on a different TCP/IP port.</description>
    <properties>
			<!-- 2019/8/07 StepanV https://support.ataccama.com/jira/browse/AS-134-->
			<property name="backlog" type="integer" required="true">Max length of the OS-managed receiver queue of the server socket. If not defined, the default value <strong>50</strong> is used. The expert setting, relevant only for very specific cases. Changing the value not recommended unless consulted with Ataccama support.</property>
			<property name="maxWaitingRequests" type="integer" required="false">Maximum number of requests waiting in the queue for an available thread. In case of too many requests that cannot fit into the queue, the code 503 is returned. If set to <code>0</code>, the requests wait indefinitely. If not defined, the default value <code>10</code> is used.</property>
			<property name="keyPassword" type="string" required="false">Contains the password that is used for keyManager in case SSL is enabled. If left empty it will have the same value as KeyStorePassword. Can be encrypted.</property>
			<property name="servletOnly" type="boolean" required="true">If true, then the listener can be used only for new service handlers (e.g., NME REST services) and cannot be used for online services, Admin Center, etc.</property>
			<!-- 2019/8/07 StepanV https://support.ataccama.com/jira/browse/AS-134-->
			<property name="keyManagerAlgorithm" type="string" required="false">Key Manager Algorithm. Used in case the SSL is enabled.</property>
			<property name="keyStoreFile" type="string" required="false">Location of a file that contains the server certificate in case the SSL is enabled.</property>
			<property name="keyStorePassword" type="string" required="false">Password used to read the <strong>Key Store File</strong> in case the SSL is enabled. Can be encrypted.</property>
			<property name="keyStoreType" type="string" required="false">Keystore type. Used in case the SSL is enabled.</property>
			<!-- 2021/01/21 StepanV https://support.ataccama.com/jira/browse/ONE-18785-->
			<property name="trustStoreFile" type="string" required="false">Location of the file that contains the certificates from certification authorities (CA) if SSL is enabled (optional). </property>
			<property name="trustStorePassword" type="string" required="false">Contains the password that is used to read the trustStoreFile in case the SSL is enabled (optional). Can be encrypted.</property>
			<property name="clientAuth" type="string" required="false">If set to <code>true</code>, mutual authentication (mTLS) between the server and the client is enabled. In that case, the connection is only accepted if the client&#39;s SSL certificate or one of the intermediate certificate authorities can be validated against the server&#39;s truststore.</property>
			<!-- 2021/01/21 StepanV https://support.ataccama.com/jira/browse/ONE-18785-->
			<property name="name" type="string" required="true">Unique name that is used by other components to identify the listener where the components should register their service handlers.</property>
			<property name="persistentConnectionTimeout" type="integer" required="true">Maximum amount of time (ms) the server waits for receiving the first byte when persistent HTTP connection is used. Persistent connections are default in HTTP 1.1. The default behavor is overriden by a value of the connection HTTP header (Keep-Alive or Close). After the timeout expires, the connection is closed.</property>
			<property name="port" type="integer" required="true">TCP/IP port on which the listener accepts new requests.</property>
			<property name="publicUrl" type="string" required="false">URL on which the listener is accessible. Should be set when listener is behind reverse proxy. In that case, the host, port and protocol may differ from the listener configuration. You may set just port in which case the host will be guessed from the request and the protocol will be the same as in listener configuration.</property>
			<property name="readTimeout" type="integer" required="true">Maximum amount of time (ms) the server waits for receiving the first byte after the connection is created. If the timeout expires and no data are available, the connection is closed.</property>
			<property name="ssl" type="boolean" required="true">Defines whether the listener communicates using SSL (HTTPS) protocol or unsecured HTTP.</property>
			<property name="threadPoolTimeout" type="integer" required="true">Maximum amount of time (ms) the server waits for free thread that will handle the connection request. After the timeout expires, the server sends error code 503: server busy.
			</property>
			<property name="threads" type="integer" required="true">Number of threads that are used to process incoming requests.</property>
			<!-- 2019/8/07 StepanV https://support.ataccama.com/jira/browse/AS-134-->
			<property name="waitingRequestsWarningThreshold" type="integer" required="true">Allowed number of waiting requests. Default is <strong>1</strong>, which means that more than one waiting requests issues a warning.</property>
			<property name="healthStateRecoveryTimeout" type="integer" required="true">Set how long until server reports that it is not in good condition after last incident. Default is <strong>300000</strong> milliseconds.</property>
			<property name="healthstateRefreshRate" type="integer" required="true">Set the time period during which server tries to detect if there is a problem somewhere. Default is <strong>60000</strong> milliseconds.</property>
			<property name="contexts" type="string" required="true">Behavior for individual context paths (security, filter chains, custom error pages).</property>
			<property name="connectionFactory" type="string" required="true">Used in connection with High Availability Component for NME in a situation when the server needs to be executed in High Availability mode (i.e., there are two server instances and when one fails, the other will serve the requests). </property>
			<property name="handlerSecurity" type="string" required="true">Deprecated and should be ignored. It stays in the component configuration for compatibility reasons and will be removed soon. Use <strong>securityFilter</strong> to configure security instead.</property>
			<!-- 2019/8/07 StepanV https://support.ataccama.com/jira/browse/AS-134-->
			<property name="requestHeaderSize" type="integer" required="false">Maximum size of all request headers. 0 stands for unlimited, default is 8K.</property>
			<property name="responseHeaderSize" type="integer" required="false">Maximum size of all response headers. Unlike for request headers, 0 is really 0, not unlimited. Default is 8K.</property>
		</properties>
  </class>
  <class name="com.ataccama.server.http.ListenerContext">
    <description>For each listener, you can define one or several contexts that contain specific settings.</description>
    <properties>
			<property name="filterChains" type="com.ataccama.server.http.FilterChain[]" required="false">Specify which filters (defined in servletFilters) should be used when accessing a location defined by <strong>path</strong> and the <strong>conditions</strong> that trigger the filters.</property>
			<property name="htmlErrorPages" type="boolean" required="true">If true, generates a user-friendly HTML error page that shows up in case a HTTP error code occurs (e.g., 404 - not found, 500 - internal server error). If false, the user is provided with the default HTML error page.</property>
			<property name="path" type="string" required="true">Specifies the mapping location of the listener context.</property>
			<property name="securityFilter" type="com.ataccama.server.http.security.ISecurityFilter" required="true">Specifies security settings for the context.</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.experimental.asyncwriter.service.IAsyncWriterTarget" name="com.ataccama.dqc.tasks.experimental.asyncwriter.service.LoggerTarget">
    <introduction>Writes records to a log. Intended mainly for debugging.</introduction>
    <description>Writes records to a log. Intended mainly for debugging.</description>
    <properties/>
  </class>
  <class name="com.ataccama.dqc.web.logging.LoggingComponent">
    <introduction>Enables customization of the logging settings in the server context.</introduction>
    <description>
			<p align="justify">
				 Enables customization of the logging settings in the server context. In addition, it lets you update the logging configuration from the Admin Center without the need to restart the server. 
			</p>
			<p align="justify">
			Logging component is used to inject the logging configuration to the server. The logging configuration is processed with the following priority:
				<ul>
					<li>
            <strong>Config File</strong> defined in the Logging Component.</li>
					<li>Logging configuration specified in the Runtime Configuration.</li>
					<li>Default logging setup.</li>
				</ul>
			</p>
		</description>
    <properties>
			<property name="configFile" type="string" required="false">
        <p align="justify">Relative (to the server configuration file) or absolute path to the logging configuration file.</p>
			<p align="justify">
				If no logging configuration file is supplied, the default configuration is used: log records with the severity level INFO and higher are written to the console (standard output). 
			</p>
		</property>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
		</properties>
  </class>
  <class super="com.ataccama.server.http.ServletFilter" name="com.ataccama.dqc.web.filters.LoggingFilter">
    <introduction>Enables logging of incoming requests and responses. In the filter mapping part you can select URL patterns which you want to log. It is also possible to have multiple loggers at once, so different URLs may log requests to different files.</introduction>
    <description>Enables logging of incoming requests and responses. incoming requests and responses. In the filter mapping part you can select URL patterns which you want to log. It is also possible to have multiple loggers at once, so different URLs may log requests to different files.</description>
    <properties>
			<property name="appendLog" type="boolean" required="true">If true, then the content of the <strong>Log File</strong> is not removed on the server start. Otherwise, the content is removed.</property>
			<property name="logFile" type="string" required="true">
			<p align="justify">
				File to log to. The file can contain date format parts in the <code>${pattern}</code> form, where <code>pattern</code> follows the Java SimpleDateFormat class formatting. For example, defining the log file as <code>request__${yyyyMMdd}.log</code> creates a new log file every day.
			</p>
			<p align="justify">
				If <strong>Log File</strong> contains date format part, that part is evaluated for every request and thus enables log rotation.
			</p>
			</property>
			<property name="maskedHeaders" type="string[]" required="false">Selected headers will be masked with <strong>Masking String</strong> within log file.</property>
			<property name="maskingString" type="string" required="false">Pattern of a string that will be used for replacing selected values within log file. By default set to <code>*****</code>.</property>
			<property name="maxRequestLogSize" type="long" required="true">Max size (bytes) of request logged. If the size of the request exceeds the limit, then only the part up to the <strong>Max Request Log Size</strong> is logged.</property>
			<property name="maxResponseLogSize" type="long" required="true">Max size (bytes) of response logged. If the size of the response exceeds the limit, then only the part up to the <strong>Max Response Log Size</strong> is logged.</property>
			<property name="name" type="string" required="true">Name of the logger. This name will be displayed in <strong>Login Setup</strong> section, in <strong>Create new logging rule</strong> dialog menu stored under <strong>HttpDispatcher</strong>.</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.supervised.classification.LogisticRegressionTrainerConfig" name="com.ataccama.dqc.tasks.ai.supervised.classification.definition.LogisticRegressionLiblinearTrainerConfig">
    <introduction>Model using A Library for Large Linear Classification.</introduction>
    <properties>
            <property name="costOfConstraintsViolation" type="float" required="true">
                Penalty parameter. Cost of constrains violation parameter. Default value = 1. Valid values &gt;=1. Usually between 1 and 1000;
            </property>
            <property name="epsilon" type="float" required="true">
                Tolerance of termination criteria. Default value = 0.1. Valid values &gt;0.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.supervised.classification.LogisticRegressionTrainerConfig">
    <introduction>Type of classification model.</introduction>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.supervised.classification.LogisticRegressionTrainerConfig" name="com.ataccama.dqc.tasks.ai.supervised.classification.definition.LogisticRegressionXgboostTrainerConfig">
    <introduction>Model using XGBoost. Usually better results compared to liblinear model, especially when training using small
            datasets (1000 instances and less).
        </introduction>
    <properties>
            <property name="learningRate" type="float" required="true">
                Step size shrinkage used in update to prevents overfitting. Learning rate shrinks the feature weights to make the boosting process more
                conservative. Default value = 0.1. Valid values &gt;0 and smaller or
                equal to 1.
            </property>
            <property name="numberOfRounds" type="integer" required="true">
                Number of boosting iterations. Valid values &gt;0. Default value = 1000.
            </property>
            <property name="earlyStopping" type="integer" required="true">
                If non-zero, training would be stopped after a specified number of consecutive increases evaluation metric.
                If for example = 10, if training error does not improve in 10 consecutive rounds, training is stopped.
                Default value = 10;
            </property>
        </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.addresses.dictionary.evaluation.IProposalEvaluatorDefinition" name="com.ataccama.dqc.tasks.addresses.dictionary.evaluation.LongestToShortestEvaluatorDefinition">
    <introduction>
    		Simple evaluating method that orders the proposal&#39;s components according to their length.
    	</introduction>
    <description>
    		The method orders the proposal&#39;s component values according to their length
    		and then searches these values in the input text reducing the input text
    		each turn.
    	</description>
    <properties>
          <property name="unknownTextCleaner" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="false">
    			Definition of constructing matching value for particular columns
    			of unexpl source (for each input element there is one column).
    			However the overall column existing in the pseudo-input as an addition to the input elements
    			contains concatenated orginal value with a pipe character (<code>|</code>) as a separator.<br/>
    			Default value: none - no cleaning is performed and the value is left as is.    			
    		</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.LookupAlgorithm">
    <introduction>Searches for input values in a table dictionary file and writes corresponding values from the dictionary file to the output.</introduction>
    <description>
			Expressions in <code>Match Condition</code>, <code>Select Best Match</code> and <code>Columns</code>
			elements can use values from current input record, record found in lookup file
			and some information about search result.<br/>
			Column values of found record are accessible via dot-source <code>lookup</code>.
			<br/>Another source named <code>query</code> contains following information about search result:
			<table border="1">
				<tr>
					<td>query.matchingKey</td>
					<td>The searched key from input, transformed by appropriate matching
					value generator</td>
				</tr>
				<tr>
					<td>query.lookupKey</td>
					<td>The real key found in lookup file. The value may be different
					from searched key</td>
				</tr>
				<tr>
					<td>query.difference (integer)</td>
					<td>Number of diffrences between searched and found keys. Always zero
					in case of non-aproximative search</td>
				</tr>
				<tr>
					<td>query.relativeDifference (float)</td>
					<td>Number of differences related to lenght of real key.</td>
				</tr>
				<tr>
					<td>query.records (integer)</td>
					<td>Number of records related to corresponding non-unique lookup key. For unique key it is 1.</td>
				</tr>
			</table>
		</description>
    <properties>
			<property name="foreignKeyColumn" type="string" required="true">
				Search key value expression.
			</property>
			<property name="tableFileName" type="string" required="true">
				Generic table dictionary file name (see <strong>specification</strong>).
			</property>
			<property name="matchCondition" type="string" required="false">
				Boolean expression. Only table records satisfying this condition will be matched.<br/>
				The expression uses three record formats (dot-sources) for current record, record <code>lookup</code> from file
				and special <code>query</code> source, see detailed description.
				For example, the expression <code>levenshtein(src_first_name, lookup.fname) &lt;= 2</code> can be used.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnAssign[]" required="false">
				List of column assignments for populating record with data from table.
				The expressions in each element uses three record formats as in <code>Match Condition</code>.
			</property>
			<property name="maxDifference" type="integer" required="true">
				Maximal number of differences in approximative string search.
				Each difference means one of the following:
				<ul>
					<li>changing one character at any position within the string</li>
					<li>omitting one character in the searched key</li>
					<li>inserting one character into the searched key</li>
				</ul>
				When set to <code>0</code>, approximative searching is disabled. In case of non-string
				key types or in case the table doesn&#39;t contain a string index,
				the approximative search is not available and this property must be set to <code>0</code>.
				<br/>Default value: <code>0</code>.
			</property>
			<property name="prefix" type="boolean" required="true">
				Specifies that keys from table having prefix equal to searched key will be found, too.
				Prefixed searching is allowed only for table with string approximative index.
				It can be combined with approximative search, e.g. prefix search with
				maxDifference 1 will found for input &quot;MARY&quot; both &quot;MARYLAND&quot; and &quot;MARRIED&quot;.
				<br/>Default value: false. 
			</property>
			<property name="selectBestMatch" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Specifies priority conditions used for selecting the best of more matching records.<br/>
				The expressions in each element uses three record formats as in <code>Match Condition</code>,
				so for example the expression <code>levenshtein(src_first_name, lookup.fname)</code> can be used to select the best
				matching record.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
  			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="LKP_NULL_ID">
				Foreign key is null. No search was performed.
			</scoringKey>
			<scoringKey name="LKP_NOT_FOUND">
				No matching record found in table dictionary file.
			</scoringKey>
			<scoringKey name="LKP_FOUND">
				One or more records matched the search criterion.
			</scoringKey>
			<scoringKey name="LKP_FOUND_DUPL">
				More than one record matched the search criterion.
			</scoringKey>
			<scoringKey name="LKP_APPROX_USED">
				Matching record has been found using approximative search.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.builders.LookupBuilder">
    <introduction>Creates a generic dictionary file.</introduction>
    <description>
		This step creates a table from specified input columns and a primary key.
		The key can be of any supported data type and need not be unique.
		The created table can contain index structures for finding records by their key,
		but it is possible to have no index at all. String lookup index enables approximative
		searching for keys of the type string. Hash lookup index can be used for faster exact searching for keys
		of any type. When both indexes are present exact searches are done using Hash Lookup and approximative
		searches are done using String Lookup. The only drawback of having both indexes is slightly increased size of
		the output file. If neither index is present the file can still be used in certain steps and can be read with
		Lookup Reader. More information about dictionary files and steps which
		use them can be found <strong>here</strong>.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="key" type="string" required="true">
			Primary key definition.
			</property>
			<property name="additionalColumns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
			Column list used to construct the table rows.
			</property>
			<property name="fileName" type="string" required="true">
			Dictionary filename.
			</property>
			<property name="approximativeIndex" type="boolean" required="true">
			Specifies that index enabling approximative string searching will be included in the output file.
			Requires key of type string.
			<br/>If not specified, hash index will be created. The hash index is applicable to any key type.
			<br/>Default = false.
			</property>
			<property name="bidirectApproximativeIndex" type="boolean" required="true">
				The approximative index will be enhanced by adding secondary tree for searching
				in backward direction. This should improve performance of approximative searching.
			</property>
			<property name="bestDistanceIndex" type="boolean" required="true">
			Applicable for string key only.
			Specifies that real key values will be stored into file
			and these values will be used to improve possibly ambiguous search result.
			Searching is limited by selecting only rows which are &quot;nearest to searched key&quot; -
			the distance between searched real key and real key found is minimal.
			The distance is counted as case insensitive <code>editDistance</code>
			relative to (divided by) length of found key.
			<br/>Default = false.
			</property>
			<property name="compressed" type="boolean" required="true">
			Specifies storage compressed row data. In case of wide data
			can save disk and memory space. Unsuitable for small data.
			<br/>Default = false.
			</property>
			<property name="matchingValue" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="true">
			Specifies how matching key values are generated.
			</property>
			<property name="duplicities" type="com.ataccama.dqc.tasks.common.data.table.DuplicityHandleType" required="true">
			Specifies handling of duplicate keys and whether the index created in the file can be non-unique.
			</property>
			<property name="userMetadata" type="com.ataccama.dqc.tasks.common.config.UserMetadata" required="true">
			User specific meta data which will be stored in the file.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.components.LookupComponent">
    <introduction>
			Defines component that verifies matched text against reference data.
		</introduction>
    <description>
			Lookup components represent user components the can be used in patterns in place
			of texts that repeat in input addresses. Such texts can be considered as different expression
			of the same and grouped into lookup files and thus reduce number of patterns.  
			We assume that the number of items in each lookup file will be small thus the lookup
			is read into memory and the file is not accessed during parsing. Each item is tokenized
			and then matching value is created.
			The parser matches the input text so that it takes as much tokens as possible,
			constructs matching value for each tokens found and tries to find in the internal representation
			of the lookup.
			Note that order tokenize first-then match is enforced by address parser that knows nothing about
			any matching value configurations.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of the component.
			</property>
			<property name="filename" type="string" required="true">
				Name of the file holding reference data. The expected type is string. Only key column is used.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.lookup.read.LookupReader">
    <introduction>Reads data from a generic lookup file.</introduction>
    <description/>
    <properties>
			<property name="fileName" type="string" required="true">
				Specify the name of the file with the data to read.
			</property>
			<property name="keyColumnName" type="string" required="true">
				Specify the column name to store the output of the values from the &quot;Table key&quot; column.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnRef[]" required="false">
				Contains a list of columns that should be read from lookup file.
				Those definitions must comply with column definitions in the file.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.rjoin.StaticRefSourceConfig" name="com.ataccama.dqc.rjoin.LookupRefSource">
    <description>
			Reference data is stored in special lookup file.
		</description>
    <properties>
			<property name="fileName" type="string" required="true">
				Reference file name.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.loqate.LoqateAlgorithm">
    <introduction>
			This step encapsulates the <a href="https://www.loqate.com/" target="_blank">Loqate©</a>
			address identification server.
            <br/>
            <br/>
            <strong>Note:</strong> ONE Desktop needs Loqate© libraries for this step. Install them or contact Ataccama support
            to help you with adding them to your ONE Desktop client.
		</introduction>
    <description>
		</description>
    <properties>
			<property name="dataFolder" type="string" required="true">
				The folder contains configuration locate.ini file, Loqate license file and reference data files (data packs).
                The step expects data files with .lfs format (extracted from the original .lfz archive).
			</property>
			<property name="inputElements" type="com.ataccama.dqc.loqate.AddressInputElement[]" required="true">
				List of input address elements source.
			</property>
			<property name="outputElements" type="com.ataccama.dqc.loqate.AddressOutputElement[]" required="false">
				List of output address elements mapping.
			</property>
			<property name="serverOptions" type="com.ataccama.dqc.loqate.OptionElement[]" required="false">
				List of additional server options (advanced use).
			</property>
			<property name="defaultCountry" type="string" required="false">
				Default country, used when country identification is not found in input elements.
			</property>
			<property name="geocoding" type="boolean" required="true">
				Use Geo location process.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
    <scoring>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.loqate.CassLoqateAlgorithm">
    <introduction>
			This step encapsulates the <a href="https://www.loqate.com/" target="_blank">Loqate©</a>
			address identification server which is capable to use certified processing (CASS).
            <br/>
            <br/>
            <strong>Note:</strong> ONE Desktop needs Loqate© libraries for this step. Install them or contact Ataccama support
            to help you with adding them to your ONE Desktop client.
        </introduction>
    <description>
		</description>
    <properties>
			<property name="dataFolder" type="string" required="true">
				The folder contains configuration locate.ini file, Loqate license file and reference data files (data packs).
                The step expects data files with .lfs format (extracted from the original .lfz archive).
			</property>
			<property name="inputElements" type="com.ataccama.dqc.loqate.AddressInputElement[]" required="true">
				List of input address elements source.
			</property>
			<property name="outputElements" type="com.ataccama.dqc.loqate.AddressOutputElement[]" required="false">
				List of output address elements mapping.
			</property>
			<property name="serverOptions" type="com.ataccama.dqc.loqate.OptionElement[]" required="false">
				List of additional server options (advanced use).
			</property>
			<property name="defaultCountry" type="string" required="false">
				Default country, used when country identification is not found in input elements.
			</property>
			<property name="geocoding" type="boolean" required="true">
				Use Geo location process.
			</property>
			<property name="maxResults" type="integer" required="false">
				Maximal number of output proposals. When &gt; 1 or not specified, uses <code>Search</code> process of Loqate server.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
		</scoring>
  </class>
  <class name="com.ataccama.nme.dqc.steps.MdcIdentify">
    <introduction>Identifies input records by matching rules against MDM using direct native interface similar to the native service Identify.</introduction>
    <description>
            <p align="justify">
                This step should be used in online service to create compound services with complex logic not achievable using just native MDM services.
            </p>
            <p align="justify">
                For every input record, step asks MDM to execute identification process. This process takes input data, cleanses them and matches them by matching rules with data in MDM.
                If input record is matched, its would-be master_id and other matching information is added to output. Moreover values of its would-be master record are added to output.
            </p>
            <p align="justify">
                Step reads data directly via internal Java interface (not via HTTP call) and works only if NmeServerComponent is in the same JVM.
            </p>
            <p align="justify">
                If there are multiple steps in one plan, they share the same transaction when accessing data, providing consistent data.
                For example in a plan with MDM Read and MDM Identify steps, record is first processed by MDM Read, data is changed, record is processed by MDM Identify
                - MDM Identify will see the same data as MDM Read because the change happened in another isolated transaction.
                This applies for both MDM Read and MDM Identify step - both of them share the same transaction.
                The level of consistency depends on used persistence and underlying database.
                For read-only transactions, VldbPersistence does not track read operations, potentially allowing obsolete record versions to be retained by LTC, even if needed by the transaction.
                For read-write transactions, VldbPersistence keeps old record versions and ensures repeatable read using MVCC.
                To ensure consistency, you need to change the underlying database isolation level from READ COMMITTED (default for most databases) to REPEATABLE READ.
            </p>
        </description>
    <bindings>
        </bindings>
    <properties>
            <property name="modelConfigFile" type="string" required="true">
                MDM model configuration file, usually in folder Files/etc and named nme-model.gen.xml.
            </property>
            <property name="masterView" type="string" required="false">
                Entity master view.
            </property>
            <property name="entity" type="string" required="true">
                Entity name.
            </property>
            <property name="origin" type="string" required="true">
                An expression whose result is value of origin. Origin determines source system and is sometimes used in identification process (depends on MDM configuration).
            </property>
            <property name="inputColumns" type="com.ataccama.nme.dqc.steps.MdcIdentify$InputColumn[]" required="true">
                Input values.
            </property>
            <property name="outputMatchInfo" type="boolean" required="false">
                If true (default), matching information columns are added to output, e.g. master_id, match_rule_name.
            </property>
            <property name="outputColumns" type="com.ataccama.nme.dqc.steps.MdcStepBase$OutputColumn[]" required="false">
                List of columns to be added to output.
            </property>
            <property name="bypassIdentity" type="boolean" required="false">
                If set to true, the step overrides the identity provided by the plan and uses its own identity which has all roles.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.nme.dqc.steps.MdcRead">
    <introduction>Reads data from MDM using direct native interface similar to native service List.</introduction>
    <description>
            <p align="justify">
                This step should be used in an online service to create compound services with complex logic not achievable using just native MDM services.
            </p>
            <p align="justify">
                For every input record, the step asks MDM to search for records of configured entity that satisfies the search criteria.
                If multiple records are found the input record will be multiplied. Use Record Descriptor column to work with multiplied groups.
            </p>
            <p align="justify">The number of returned records is limited by the shared <strong>NME Runtime Property</strong>. The <code>nme.services.range.maxCount</code> which is used also for NME Native Services. The default value is <strong>100</strong>.
            </p>
            <p align="justify">
                Step reads data directly via internal Java interface (not via HTTP call) and works only if NmeServerComponent is in the same JVM.
            </p>
            <p align="justify">
                If there are multiple steps in one plan, they share the same transaction when accessing data, providing consistent data.
                For example in a plan with MDM Read and MDM Identify steps, record is first processed by MDM Read, data is changed, record is processed by MDM Identify
                - MDM Identify will see the same data as MDM Read because the change happened in another isolated transaction.
                This applies for both MDM Read and MDM Identify step - both of them share the same transaction.
                The level of consistency depends on used persistence and underlying database.
                For read-only transactions, VldbPersistence does not track read operations, potentially allowing obsolete record versions to be retained by LTC, even if needed by the transaction.
                For read-write transactions, VldbPersistence keeps old record versions and ensures repeatable read using MVCC.
                To ensure consistency, you need to change the underlying database isolation level from READ COMMITTED (default for most databases) to REPEATABLE READ.
            </p>
        </description>
    <bindings>
        </bindings>
    <properties>
            <property name="modelConfigFile" type="string" required="true">
                MDM model configuration file, usually in folder Files/etc and named nme-model.gen.xml.
            </property>
            <property name="layer" type="string" required="true">
                Entity layer - INSTANCE or MASTER.
            </property>
            <property name="masterView" type="string" required="false">
                Entity master view, required if MASTER layer is chosen.
            </property>
            <property name="entity" type="string" required="true">
                Entity name.
            </property>
            <property name="recordDescriptorColumn" type="string" required="false">
                Name of the column of type string to store the identification of record in group. The identifier
                has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
            </property>
            <property name="search" type="com.ataccama.nme.dqc.steps.MdcRead$SearchExpression[]" required="false">
                Search conditions.
            </property>
            <property name="outputColumns" type="com.ataccama.nme.dqc.steps.MdcStepBase$OutputColumn[]" required="false">
                List of columns to be added to output.
            </property>
            <property name="bypassIdentity" type="boolean" required="false">
                If set to true, the step overrides the identity provided by the plan and uses its own identity which has all roles.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.nme.dqc.steps.remote.MdcRemoteRead">
    <introduction>MDM Remote Read step reads data from MDM remotely using gRPC framework.</introduction>
    <description>This step is still in <strong>PoC</strong> phase of development. As such it should not be a part of any customer demos.
            <br/>
            <p align="justify">
                <strong>Note</strong>
            </p>
            <p align="justify">
                <ul>
                    <li>You need to add plugin in MDM in order to allow gRPC Server.</li>
                    <li>Currently there is no security or any authorization in place.</li>
                    <li>You need to fill manually column <strong>Name</strong> and data <strong>Type</strong> (Values) properly according to what is stated in MDM.
                    </li>
                </ul>
            </p>
        </description>
    <properties>
            <property name="id" type="string" required="false">Step identification string.</property>
            <property name="url" type="string" required="true">Connection details for connecting to MDM gRPC Server. (<strong>File Explorer</strong> &gt; <strong>Servers</strong>)
            </property>
            <property name="entityType" type="string" required="true">Entity Type. Entity layer - <strong>INSTANCE</strong> or <strong>MASTER</strong>.
            </property>
            <property name="masterLayerName" type="string" required="false">Master Layer Name, e. g., <code>&lt;masterLayer name=&quot;masters&quot;&gt;</code>.
            </property>
            <property name="entityName" type="string" required="true">Entity Name. Specific table that should be read from MDM.</property>
            <property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="true">Specific columns that should be read from MDM.</property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">Contains a set of columns that are not present in the input data, but should be created in the output (so that they are then
                available for further use as any other &quot;real&quot; column read from a file).
            </property>
        </properties>
    <scoring/>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfMkdirOperation">
    <introduction>Creates a folder.</introduction>
    <description>Creates a folder.</description>
    <properties>
			<property name="recursiveFlag" type="boolean" required="true">Permission to make parent directories as needed.</property>
			<property name="targetFile" type="string" required="true">Path to the destination folder. The task fails when the target is a multi-level directory structure from which some of the parent folders do not exist and <strong>Recursive Flag</strong> is false.
			</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.columns.MMMChildEntity">
    <description>Records for subtypes of the entity that you define in <strong>Entity Type</strong>.</description>
    <properties>
			<property name="name" type="string" required="true">Entity subtype name from the ONE Web Application (tableCatalogItem, businessTerm etc.).</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.columns.MMMColumnDef">
    <description>The following section defines columns that will be constructed from records retrieved from the <strong>ONE Web Application</strong>.</description>
    <properties>
			<property name="name" type="string" required="true">Assigned column name.</property>
			<property name="src" type="string" required="true">Source column.</property>
			<property name="type" type="com.ataccama.dqc.tasks.io.mmm.columns.MMMColumnType" required="true">Data type of created column.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.columns.MMMColumnExprDef">
    <description>This element defines a new column that this step writes to the <strong>ONE Web Application</strong>. The value is provided by the expression or, when an expression is not specified, by the column value from the source format. The data type of the new column is determined from the expression/source column type.If the data type is indeterminable (a null literal expression), the string type is used. </description>
    <properties>
			<property name="expression" type="string" required="true">If set, it specifies the expression to execute in order to get the value that will be written to the column. If no expression is defined,the value corresponding to the value of the input column with the same name as the <code>Name</code> attribute will be written.</property>
			<property name="name" type="string" required="true">Specifies the name of the destination column to be written. When the <code>Expression</code> property is not set, it also specifies the name of the source column.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.columns.MMMColumnType">
    <description>Available types of values to be stored in records.</description>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.columns.MMMEmbeddedEntityColumnDef">
    <description> </description>
    <properties>
			<!--XXX-->
			<property name="name" type="string" required="true">Name of the entity column.</property>
			<!--XXX-->
			<property name="src" type="string" required="true">Source of the entity column.</property>
			<!--XXX-->
			<property name="type" type="com.ataccama.dqc.tasks.io.mmm.columns.MMMColumnType" required="true">Data type of the entity column.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.reader.MMMEmbeddedOutputStreamConfig">
    <description> </description>
    <properties>
			<!--XXX-->
			<property name="attribute" type="string" required="true">Name of property this stream reads from its parent entity instance.</property>
			<!--XXX-->
			<property name="childStreams" type="com.ataccama.dqc.tasks.io.mmm.reader.MMMEmbeddedOutputStreamConfig[]" required="false">Select which embedded properties of the selected Entity type you want to read. For every selected embedded property, a separate output endpoint will be created.For instance you can read attributes embedded in catalog items, etc.</property>
			<!--XXX-->
			<property name="columns" type="com.ataccama.dqc.tasks.io.mmm.columns.MMMEmbeddedEntityColumnDef[]" required="true">Definitions of columns that will be retrieved from the ONE Web Application based on properties of selected Entity type.</property>
			<!--XXX-->
			<property name="entityColumnName" type="string" required="false">Entities have subtypes. Define a column to store the concrete subtype (i.e. businessTerm is a subtype of term).</property>
			<!--XXX-->
			<property name="idColumnName" type="string" required="false">ID of the entity instance.</property>
			<!--XXX-->
			<property name="name" type="string" required="true">Name of this data stream.</property>
			<!--XXX-->
			<property name="parentIdColumnName" type="string" required="false">ID of the entity instance that is parent to the retrieved entity. For example, if you are reading an attribute, parent entity ID would be the ID of the catalogItem instance this attribute belongs to.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.reader.MMMReaderRootStreamConfig">
    <description> </description>
    <properties>
			<!--XXX-->
			<property name="attribute" type="string" required="true">Name of property this stream reads from its parent entity instance.</property>
			<!--XXX-->
			<property name="childStreams" type="com.ataccama.dqc.tasks.io.mmm.reader.MMMEmbeddedOutputStreamConfig[]" required="false">Select which embedded properties of selected Entity type you want to read. For every selected embedded property, a separate output endpoint will be created.For instance you can read attributes embedded in catalog items, etc.</property>
			<!--XXX-->
			<property name="columns" type="com.ataccama.dqc.tasks.io.mmm.columns.MMMEmbeddedEntityColumnDef[]" required="true">Definitions of columns that will be retrieved from the ONE Web Application based on properties of selected Entity type.</property>
			<!--XXX-->
			<property name="entityColumnName" type="string" required="false">Entities have subtypes. Define a column to store the concrete subtype (i.e. businessTerm is a subtype of term).</property>
			<!--XXX-->
			<property name="idColumnName" type="string" required="false">ID of the entity instance.</property>
			<!--XXX-->
			<property name="name" type="string" required="true">Name of this data stream.</property>
			<!--XXX-->
			<property name="parentIdColumnName" type="string" required="false">ID of the entity instance that is parent to the retrieved entity. For example, if you are reading an attribute, parent entity ID would be the ID of the catalogItem instance this attribute belongs to.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfMoveFileOperation">
    <introduction>Moves source file/folder to the destination folder.</introduction>
    <description>Moves source file/folder to the destination folder. The move operation automatically preserves target files timestamps.</description>
    <properties>
			<property name="overwriteFlag" type="boolean" required="true">Permission to overwrite files in the destination folder. The task fails when <strong>Overwrite Flag</strong> is false and some of the <strong>Target File</strong> files/folders already exist.</property>
			<property name="keepDirTreeFlag" type="boolean" required="true">Permission to copy the source file system hierarchy. Applicable only in case the <strong>Source File</strong> contains wildcards on multiple path levels (e.g., <code>/dir*/*.csv</code>), otherwise the <strong>Keep Dir Tree Flag</strong> is ignored.
			<p align="justify">If true (false), the source file hierarchy is preserved starting from the highest (lowest) level of the <strong>Source File</strong> path containing a wildcard.</p>
			<p align="justify">For example, if you move files from the <code>in</code> to the <code>out</code> folder with the <strong>Source File</strong> value <code>in/dir*/*.csv</code>, the target file hierarchy will have the following structure based on the <strong>Keep Dir Tree Flag</strong> value:</p>
				<ul>
					<li>
            <code>out/dir&lt;value&gt;/&lt;file_name&gt;.csv</code> if the flag is true</li>
					<li>
            <code>out/&lt;file_name&gt;.csv</code> if the flag is false</li>
				</ul>
			</property>
			<property name="sourceFile" type="string" required="true">Path to the source mask on files/folders. Task fails when no file/directory is found to mask.
			<p align="justify">Supports wildcards.</p>
      </property>
			<property name="targetFile" type="string" required="true">Path to the destination folder or file:
				<ul>
					<li>Folder – after moving, the file observes the name; folder must exist, otherwise the task fails.</li>
					<li>File – parent folder of target file must exist, otherwise the task fails.</li>
				</ul>
			<p align="justify">Note: Make sure to appropriately set the <strong>Keep Dir Tree Flag</strong> and <strong>Overwrite Flag</strong>. If both flags are false and multiple files with the same name match the <strong>Source File</strong> mask, the task attempts to move all matched files to the same destination folder and fails.</p>
			</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.sendmail.SendmailAlgorithm$MailTemplate">
    <introduction>
			Defines template of mail body, subject and target address.
		</introduction>
    <description>
			Many of string parameters in this element are <em>templates</em>. Templates may
			contain placeholders for inserting column value obtained from input record. The
			placeholder is coded as <code>{name}</code>, where <em>name</em> is column
			name. Curly brace itself must be escaped by backslash.
			For example: template <code>{first_name} {last_name}, \{{age}\}</code> can result
			in text <code>John Smith, {34}</code>.
		</description>
    <properties>
			<property name="condition" type="string" required="false">
				Boolean expression specifying when the e-mail have to be sent using the template.
			</property>
			<property name="to" type="string" required="true">
				Target e-mail address. Can be a list separated by comma.
				The value can be template.
			</property>
			<property name="subject" type="string" required="true">
				The template of e-mail subject.
			</property>
			<property name="body" type="string" required="true">
				The template of e-mail body.
			</property>
			<property name="contentType" type="com.ataccama.dqc.tasks.experimental.sendmail.TextSubtype" required="true">
				Specifies body content type.
			</property>
			<property name="from" type="string" required="false">
				The template for specific e-mail source address placed to <code>from:</code> header.
				<br/>
				If not specified, default value will be used.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfSendMailTask$MailType">
    <description>Format of the email (plain text or HTML).</description>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.override.ManualOverrideBuilder">
    <introduction>Manages a set of rules for manual overriding against the existing unification rules within the repository.</introduction>
    <description>
			This step manages a set of rules for manual overriding against the existing rules within the repository.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="typeColumn" type="string" required="true">
				String column or expression that contains a rule type. See the <strong>manual override</strong> section.
			</property>
			<property name="parentRecordPkColumn" type="string" required="true">
				String column or expression that contains the primary key of the parent record (not applicable to R-&gt;C rule).
			</property>
			<property name="childRecordPkColumn" type="string" required="true">
				String column or expression that contains the primary key of the child record.
			</property>
			<property name="repository" type="com.ataccama.dqc.tasks.identify.repository.RepositoryProperties" required="true">
				Repository properties.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.reconcile.MappedReconcileAlgorithm">
    <introduction>Calculates aggregated accounting records based on mapping to account numbers</introduction>
    <description>
    		The algorithm calculates aggregated accounting records based on mapping from a composite key
    		to an account numbers for both account balance values and accrued amount values.
    		A new accounting record is created only if the value is not null or zero.
			Negative values are stored in debit column,
			whereas positive values are stored in the credit column.
			Account number of each new record is defined by <code>Account Balance</code> or
			<code>Accrued Amount</code> property of the rule respectively.<br/>
			The algorithm sends all records to its <code>out</code> endpoint and
    		produces a new record for each distinct account number with aggregated debit
    		and a new record for each distinct account number with aggregated credit  
    		to <code>outAccountingRecords</code>
    		endpoint. The records at this endpoint have the following format:<br/>
    		<ul>
    			<li>
          <code>account</code> : String (account number)</li>
    			<li>
          <code>debit</code> : Float</li>
    			<li>
          <code>credit</code> : Float</li>
    		</ul>
    		So the records at <code>outAccountingRecords</code> endpoint are aggregated
    		in the same way as in <strong>Reconcile</strong> algorithm.<br/>
    		Note, that account records with the same account numbers (and relevant debit or credit value) are aggregated together
    		without distinction of the origin of values (i.e. values from <code>Account Balance</code> and <code>Accrued Amount</code>
    		can be aggregated together).<br/>
    		See also steps <strong>Reconcile</strong> 
    		and <strong>Compute General Ledger</strong>. 
    	</description>
    <properties>
			<property name="productType" type="string" required="true">
				Defines column whose value is to be matched to <code>Product Type</code> subkey value
				from a mapping rule.
			</property>
			<property name="assetClass" type="string" required="true">
				Defines column whose value is to be matched to <code>Asset Class</code> subkey value
				from a mapping rule.
			</property>
			<property name="groupAccountType" type="string" required="true">
				Defines column whose value is to be matched to <code>Group Account Type</code> subkey value
				from a mapping rule.
			</property>
			<property name="currency" type="string" required="true">
				Defines column whose value is to be matched to <code>Currency</code> subkey value
				from a mapping rule.
			</property>
			<property name="accruedAmount" type="string" required="true">
				Defines column whose value is to be stored in debit or credit column in accounting record.
				For this value, an account number from <code>Accrued Amount</code> property of the appropriate
				rule is stored as <code>account</code> column in accounting record.
				The type of the column must be <code>float</code>.
			</property>
			<property name="accountBalance" type="string" required="true">
				Defines column whose value is to be stored in debit or credit column in accounting record.
				For this value, an account number from <code>Account Balance</code> property of the appropriate
				rule is stored as <code>account</code> column in accounting record.
				The type of the column must be <code>float</code>.
			</property>
			<property name="rules" type="com.ataccama.dqc.tasks.experimental.reconcile.MappingRule[]" required="true">
				Mapping rules.
			</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    	</properties>
  </class>
  <class name="com.ataccama.adt.task.base.KeyValueMapping$Mapper">
    <description>Set of user defined parameters.</description>
    <properties>
			<property name="parameters" type="com.ataccama.adt.task.base.KeyValueMapping$Parameter[]" required="false">Set of user defined parameters.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.adt.task.base.Mapping">
    <description>Set of mappings describing mapping of the columns of the result set to the variables. Individual result rows are mapped to the defined mappings in the order they are defined.
			<br/>Mapping properties must be defined exclusively: either <strong>Output Parameters</strong> or <strong>Result Set</strong> can be defined.
		</description>
    <properties>
			<property name="outputParameters" type="com.ataccama.adt.task.base.Mapping$ParameterMapping[]" required="false">Defines a set of the output parameters to be read from the query. Applicable when calling stored procedures.</property>
			<property name="resultSet" type="com.ataccama.adt.task.base.Mapping$ResultSetMapping[]" required="false">Defines a set of the output parameters to be read from the query&#39;s result set. Applicable when running SQL queries. </property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.reconcile.MappingRule">
    <introduction>Defines mapping from input record to account number and value.</introduction>
    <description>
			The rule is defined by a composite key and account numbers for 
			account balance and accrued amount values. The rule is applied on
			input records that match the key (null values of the subkey both in the rule and
			in the record are treated as the same). In that case account balance
			and accrued amount values from the input record (bound by <code>Account Balance</code>
			and <code>Accrued Amount</code>) are stored in accounting records in 
			debit or creadit columns respectively - each value into its own record.
		</description>
    <properties>
			<property name="productType" type="string" required="true">
				Defines value of product type subkey.
			</property>
	      	<property name="assetClass" type="string" required="true">
	      		Defines value of asset class subkey.
	      	</property>
	      	<property name="currency" type="string" required="true">
	      		Defines value of currency subkey.
	      	</property>
	      	<property name="groupAccountType" type="string" required="true">
	      		Defines value of group account type subkey.
	      	</property>
	      	<property name="accruedAmount" type="string" required="true">
	      		Account number to be stored when accrued amount value is stored.
	      	</property>
	      	<property name="accountBalance" type="string" required="true">
	      		Account number to be stored when account balance value is stored.
	      	</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.IMappingTest">
    <properties/>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.MaskAnalysis">
    <introduction>This type of analysis can be useful when, for example, looking at a column of names, where one or two words are common, but single letters and numbers are not. Finding unexpected patterns in the data can provide information about the overall level of data quality.</introduction>
    <properties>
			<property name="distinctValuesLimit" type="integer" required="true">Specifies the limit when input data are considered to be an enumeration data type. If the data will pass over this limit input data are no longer considered to be enumeration data type.</property>
			<property name="maskName" type="string" required="true">Mask Name</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.MaskCfg">
    <properties>
			<property name="name" type="string" required="true">
			Name of the mask definition. It can be used in <code>maskName</code> parameter of
			<strong>frequencyAnalysis</strong> in case of string data.
			</property>
			<property name="characterGroups" type="com.ataccama.dqc.tasks.common.text.CharacterGroup[]" required="true">
			Rules for creating patterns from string values.
			</property>
			<property name="copyOther" type="boolean" required="true">
				Specifies that characters not belonging to any character group are copied
				into mask as are.
				<br/>Default = true.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.global.domain.transformation.SourceTransformation" name="com.ataccama.one.profiling.linear.simple.params.global.domain.transformation.MaskTransformation">
    <introduction>Mask transformation coverts data to mask before expression evaluation.</introduction>
    <properties>
			<property name="maskName" type="string" required="false">Mask Name</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.mdu.MatchFunction">
    <description>
      	Allows advanced users to define their own comparators, which then can be used in the <strong>Match Test Function</strong> <br/>
      	The variables x and y can be used in the expression as the representatives of the actual columns defined in the tests; with x for the original record&#39;s columns and y for the new coming record&#39;s.<br/>
      <br/>

		Example: <br/>
		A Match Function named &quot;Jaccard&quot; is defined by the expression jaccardCoefficient(x,y).<br/>
		It can later be used in a Matching rule&#39;s Mdu Match Test - e.g. for a test having &quot;Jaccard&quot; as Function and &quot;Company_name&quot; as Column, the x and y in the &quot;Jaccard&quot; function represent (in this case) the values of &quot;Company_name&quot; columns in both of the compared records.
      </description>
    <properties>
          <property name="argumentType" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Return data type of the expression.</property>
          <property name="expression" type="string" required="true">Expression usually evaluating the distance between two records.</property>
          <property name="name" type="string" required="true">Match Function name to be referenced in Match Test Function as a comparator.</property>
          <property name="normalized" type="boolean" required="true">Result of this (numeric) function is normalized to values from &lt;0;1&gt;</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.rjoin.RefJoin$MatchKey">
    <description>
			Specifies reference key used in search.
		</description>
    <properties>
			<property name="keyName" type="string" required="true">
				The name of key defined by reference source. The key names are specified by builder.
			</property>
			<property name="selectLimit" type="string" required="false">
				Integer expression. Maximal allowed records fetched by this key. There could be better to not use the key when it belongs too much records
				(low selectivity).
				<br/>When empty or &lt; 0 - always use this key (default).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.merge.MatchStrategy">
    <description>
			Defines technique of records pairing. Two basic method is supported - merging and hash table.<br/>
			The hash table is <strong>very</strong> profitable for cases where one input contains limited and relative small
			number of records in contrast of second one.
			However hash table cannot be used for OUTER join type and using
			LEFT resp. RIGHT join type must conform to using HASH_RIGHT resp. HASH_LEFT strategy. 
			
		</description>
  </class>
  <class name="com.ataccama.mdu.MdUnify">
    <introduction>The use case of Matching is commonly called Data matching or Record linkage - finding groups of records which belong to one logical entity using a certain set of matching rules.</introduction>
    <description>
		The step supports the MDM use case, where records which are once grouped together, won&#39;t be split again or merged
		with another group of records, unless a user manually chooses to or unless input data are flagged for rematching.<br/>
		Step uses MDM repository as its storage of records, server with running MDM instance is required for
		incremental matching.
		</description>
    <properties>
          <property name="id" type="string" required="false">
			Step identification string.
			</property>
          <property name="keeperSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">Default criterion for selecting of &quot;id keeper record&quot; for partitions which haven&#39;t specified its own</property>
          <property name="matchFunctions" type="com.ataccama.mdu.MatchFunction[]" required="false">List of Match Functions.</property>
          <property name="matchingMeasures" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingMeasure[]" required="false">List of Matching Measures.</property>
          <property name="partitions" type="com.ataccama.mdu.MduPartition[]" required="true">List of Partitions.</property>
          <property name="standaloneBindings" type="com.ataccama.mdu.MduStandaloneBindings" required="false">Additional bindings used in standalone mode</property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.MatchingValues$MatchingColumn">
    <properties>
			<property name="expression" type="string" required="true">
				Expression evaluating the value which is converted into a matching value
				according to the specification of <code>Generator</code>.
			</property>
			<property name="name" type="string" required="true">
				Name of destination column for the resulting matching value.
			</property>
			<property name="generator" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="true">
				Matching value generator definition.
			</property>
			<property name="trash" type="string" required="false">
				Name of column to which removed characters will be written.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="MV_CHANGED">A scoring flag indicating that the input value has been changed due to the transformation.</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.matcher.config.MatchingMeasure">
    <description>
			Defines named expression usually returning some kind of distance between two records.
			This value can be then used in conditional expression of
			<strong>Matching Rule</strong>
			as column of the same name in source <code>measures</code>.
			<p align="justify">
				Example:<br/>
				The measure of name <code>mm_name</code>, defined by expression <code>editDistance(pivot.name, candidate.name)</code>
				<br/>is used in some rule&#39;s expression <code>measures.mm_name &lt; 3 and pivot.city == candidate.city</code>,
				<br/>and in other rule&#39;s expression <code>measures.mm_name &lt; 2 and editDistance(pivot.city, candidate.city) &lt; 2</code>.<br/>
        <br/>
				The use of matching measures is identical in Matching and Unification step. <br/>
			</p>
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of measure, determines name of appropriate pseudo-column in <code>measures</code> dot-source.
			</property>
			<property name="expression" type="string" required="true">
				Expression usually calculating the distance between two records
				(in unification context named <code>pivot</code> resp. <code>candidate</code>).
				<br/>Note: The expression can use previously defined measure as column of <code>measures</code> record, too.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule">
    <description>
			Rule for evaluating the similarity of two records.
		</description>
    <properties>
			<property name="name" type="string" required="false">
				Name of rule. If the ruleNameColumn binding is used the name of the used rule is stored there.
			</property>
			<property name="expression" type="string" required="false">
				Boolean expression that must be satisfied in addition to evaluating the list of tests.
				<br/>Compared records are referred by two dot-sources, whose names
				depend on context where the matching rules are used. See description of related property in parent element.
				<br/>Moreover, results of <strong>Matching Measure</strong>,
				referred via dot-source <code>measures</code> can be used.
			</property>
			<property name="maximumAllowed" type="double" required="true">
				<p align="justify">
				Threshold for weighted sum of all tests. If this threshold is exceeded (is greater than this value), records are declared not similar (and the test fails).
				</p>
				Default value: <code>0</code> (no tolerance)
			</property>
			<property name="tests" type="com.ataccama.dqc.tasks.identify.matcher.config.Test[]" required="false">
				List of tests used for comparison of a couple of records. If this element is empty the test result is always true.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig">
    <properties>
			<property name="supportedCharacters" type="string" required="false">
				Definition of supported characters.
				Characters not contained in this set are removed or substituted.
				See <strong>character set definition syntax</strong>.
				<br/>Default value: none (All characters are supported by default).
			</property>
			<property name="substituteWith" type="string" required="false">
				String which substitutes unsupported characters.
				<br/>Defaut value: none (No substitution is performed by default).
			</property>
			<property name="doRemoveDia" type="boolean" required="true">
				Remove word diacritics (accents).
				<br/>Default value: false.
			</property>
			<property name="doRemoveRepeatedChars" type="boolean" required="true">
				Remove repeated characters.
				<br/>Default value: false.
			</property>
			<property name="doSqueezeWS" type="boolean" required="true">
				Repeated white space characters are replaced with a single space character.
				<br/>Default value: false.
			</property>
			<property name="doUpperCase" type="boolean" required="true">
				Convert all words to upper case.
				<br/>Default value: false.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.MatchingValues">
    <introduction>Creates matching values from defined inputs and transformations.</introduction>
    <description>
			The step creates matching values of specified expressions and stores them in output columns.
		</description>
    <properties>
		  <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
          <property name="id" type="string" required="false">
			Step identification string.
			</property>
		  <property name="columns" type="com.ataccama.dqc.tasks.clean.MatchingValues$MatchingColumn[]" required="false">
			Set of matching value source expressions and destination columns.
		  </property>
		</properties>
  </class>
  <class name="com.ataccama.mdu.MduMatchRule">
    <description>
      	Definition of a Matching Rule, where user specifies a set of Matching Tests, which need to be complied with for the records to be matched using the Matching Rule.
      	It is also possible to define conditions using <code>expression</code> and <code>when</code> properties, under which tests won&#39;t be evaluated at all.<br/>
      	All tests have to be fulfilled to fulfill the rule.
      	Results of tests are numeric in general (zero for fulfilled boolean test) and theirs average value is assumed as Match Quality, which influences the result of the match.
      	Newly inserted record will be matched to a record with the best (lowest) Match Quality.
      </description>
    <properties>
          <property name="expression" type="string" required="false">An expression that needs to be fulfilled for the input records to be matched together.
          Both expression and all Matching Tests must be complied with. Input columns are accessible via <code>pivot</code> and <code>candidate</code> dot sources.</property>
          <property name="name" type="string" required="false">Rule Name to be stored for the matched records in the <code>Rule Name Column</code>.</property>
          <property name="confidence" type="integer" required="false">Rule Confidence to be stored for the matched records.</property>
          <property name="tests" type="com.ataccama.mdu.MduMatchTest[]" required="false">List of Matching Tests.</property>
          <property name="when" type="string" required="false">An expression that must be fulfilled for the record to be compared to another one using this rule. Values from record to be compared can be used only.</property>
        </properties>
  </class>
  <class name="com.ataccama.mdu.MduMatchTest">
    <description>
      		Definition of a Match Test, a condition defined by a distance metric and a limit. If the distance of column
      		values between compared records is lower than the limit or conditional metric evaluates to true, the
      		Match Test is fulfilled. If <code>limit</code> or <code>relative</code> is specified, numeric distance is normalized
      		to value from &lt;0;1&gt;
      	</description>
    <properties>
          <property name="column" type="string" required="true">Column containing value to be compared.</property>
          <property name="function" type="string" required="true">Function used to evaluate the distance between records. Choose from predefined functions (<code>equality</code> means &quot;equals to;&quot; for other functions, see <strong>Expressions</strong>) and functions defined in <strong>Match Function</strong>.</property>
          <property name="limit" type="double" required="false">Maximum value returned by the function for the test to be fulfilled.</property>
          <property name="relative" type="boolean" required="true">Whether the returned value of the function should be divided by the longer
          of the compared values.</property>
          <property name="allowEmptyValue" type="boolean" required="true">False: if any of the tested values is null, the test fails. True: null values are evaluated, and the result depends on the used function (i.e. for equality null is equal to null, for string comparison functions null is like empty string...).<br/>Default value: False.</property>
        </properties>
  </class>
  <class name="com.ataccama.mdu.MduStandaloneBindings">
    <properties>
			<property name="idColumn" type="string" required="false">Column containing a unique primary key of records.</property>
			<property name="masterIdColumn" type="string" required="true">String/integer/long column for storing the matching group id.</property>
			<property name="rematchFlag" type="string" required="false">Boolean column containing a flag designating input record&#39;s group for rematching.</property>
			<property name="isolateFlag" type="string" required="false">Boolean column containing a flag designating records that must not be joined with any other.</property>
			<property name="masterIdFrom" type="long" required="false">The minimal master id assigned to new groups.<br/>Default value: 1</property>
			<property name="ruleNameColumn" type="string" required="false">Column for storing the name of the matching rule used in matching group collecting.</property>
			<property name="matchIdColumn" type="string" required="false">Id of the record to which a newly coming record was matched.</property>
			<property name="matchQualityColumn" type="string" required="false">The match quality is applicable for numeric matching results. When use simple boolean expression or tests functions, the positive match is interpreted as match quality 0 (highest).</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.transformation.imputing.definition.ImputingFeatureTransformation" name="com.ataccama.dqc.tasks.ai.transformation.imputing.definition.MeanImputingTransformation">
    <introduction>Replaces null values with mean value.</introduction>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.ILdapRoleResolver" name="com.ataccama.dqc.communication.auth.server.MemberAttributeResolver">
    <introduction>Name of the group (role) is retrieved from the attribute of the authenticated user&#39;s node.</introduction>
    <description>Name of the group (role) is retrieved from the attribute of the authenticated user&#39;s node. The name of the attribute is defined in the <strong>Attribute</strong> attribute. If the value is a valid distinguished name, the group name will be the value from the most specific key-value pair of the distinguished name.</description>
    <properties>
			<property name="attribute" type="string" required="false">Attribute name.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.console.MenuCategory">
    <description>Specifies custom menu categories. Each custom category adds a section to the Admin Center navigation panel. Items within the section are defined in the <strong>Custom Menu Items</strong>.</description>
    <properties>
			<property name="key" type="string" required="true">Category identification key. Used as a foreign key in the <strong>Custom Menu Items</strong> element to sort items into categories.</property>
			<property name="label" type="string" required="true">Category label displayed in the Admin Center navigation panel.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.console.MenuItem">
    <description>Specifies custom menu items (pointing to external servers and/or document folders) in the Admin Center.</description>
    <properties>
			<property name="categoryKey" type="string" required="true">Identifies a category under which the item is displayed. Use a <strong>Key</strong> defined in the <strong>Custom Menu Categories</strong> element or a pre-defined key. 
			<p align="justify">Pre-defined category keys use <code>wc.menu.group.&lt;category_id&gt;</code> notation to add an item under an existing Admin Center section. Possible <code>category_id</code> values: <code>info</code>, <code>resources</code>, <code>server</code>, <code>workflows</code>.</p>
      </property>
			<property name="label" type="string" required="false">Item label displayed in the Admin Center navigation panel.</property>
			<property name="labelKey" type="string" required="false">Pre-defined key used to retrieve a corresponding item label (displayed in the Web Console navigation panel) from the internal <code>WebMessages.properties</code> file. This is an expert setting.</property>
			<property name="url" type="string" required="true">Item URL. URL is either absolute or relative to the &lt;host&gt;:&lt;port&gt;/console/. The absolute URL must include a protocol.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.jms.writer.JmsWorkerBase$MessageProperty">
    <properties>
    		<property name="key" type="string" required="false">Key of the message property.</property>
    		<property name="value" type="string" required="false">Value of the message property that is defined based on the entered expression.</property>
    	</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.dqi.Metric">
    <description>
	It actually contains the score column (<code>Score Column</code>), four expressions 
	(<code>*Expression</code>) and some descriptive fields. The four expressions
	can link to each other (using <code>CII</code> source) but the expression must
	not create a loop. And of course each expression can contain fields from the 
	row format using <code>in</code> source.
	</description>
    <properties>
			<property name="businessTerm" type="string" required="true">
                Business term. 
			</property>
			<property name="id" type="string" required="true">
                Id. 
			</property>
			<property name="dataElement" type="string" required="true">
                Data element.  It must be unique across all metrics.
			</property>
			<property name="scoreColumn" type="string" required="true">
                The score for the given metric is written into this column
                using the <code>defaultCIIScore</code> expression.
                The column must be of the integer type.
			</property>
			<property name="populatedExpression" type="string" required="true">
                Expression returning boolean. Its name in the <code>CII</code>
                source is <code>populated</code>.
                Eg. <code>[in].a == 1 and CII.valid</code>.
			</property>
			<property name="populatedRule" type="string" required="false">
                Populated rule. 
			</property>
			<property name="populatedColumn" type="string" required="false">
                The result of the expression can be written to this column.
			</property>
			<property name="validContentExpression" type="string" required="true">
                Expression returning boolean. Its name in the <code>CII</code>
                source is <code>valid</code>.
                Eg. <code>[in].a == 1 and CII.populated</code>.
			</property>
			<property name="validContentRule" type="string" required="false">
                Valid content rule. 
			</property>
			<property name="validContentColumn" type="string" required="false">
                The result of the expression can be written to this column.
			</property>
			<property name="completeExpression" type="string" required="true">
                Expression returning boolean. Its name in the <code>CII</code>
                source is <code>complete</code>.
                Eg. <code>[in].a == 1 and CII.populated</code>.
			</property>
			<property name="completeRule" type="string" required="false">
                Complete rule. 
			</property>
			<property name="completeColumn" type="string" required="false">
                The result of the expression can be written to this column.
			</property>
			<property name="currentExpression" type="string" required="true">
                Expression returning boolean. Its name in the <code>CII</code>
                source is <code>current</code>.
                Eg. <code>[in].a == 1 and CII.complete</code>.
			</property>
			<property name="currentRule" type="string" required="false">
                Current rule. 
			</property>
			<property name="currentColumn" type="string" required="false">
                The result of the expression can be written to this column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.timeseries.MetricBinding">
    <properties>
            <property name="meanBinding" type="string" required="false">
                Column for outputting mean value of errors between true and predicted values.
            </property>
            <property name="varianceBinding" type="string" required="false">
                Column for outputting variance value of errors between true and predicted values.
            </property>
        </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.transformation.normalization.definition.NormalizationFeatureTransformation" name="com.ataccama.dqc.tasks.ai.transformation.normalization.definition.MinMaxScalingTransformation">
    <introduction>Scales value based on min and max values.</introduction>
    <description>
            Formula for computing the result:
            x = (x - min) / (max - min)
        </description>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.timeseries.settings.ModelSettings">
    <properties>
            <property name="active" type="boolean" required="true">
                If this model should be used in the grid search.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addressdoctor.MultiplicativeAddressDoctorAlgorithm">
    <introduction>
			This step encapsulates the <a href="http://www.addressdoctor.com/" target="_blank">Address Doctor©</a>
			software library under <code>Fast Completion</code> processing mode. Address Doctor© is third-party verification software
			that analyzes, corrects and standardizes addresses.
		</introduction>
    <description> 
			<p align="justify">This step, which represents the <code>Fast Completion</code> processing mode, 
		allows to obtain up to 100 results per line of input in case the address is not specified correctly. 
		The maximum number of suggestions can be set up by changing the <code>MaxResultCount</code> parameter to &quot;100&quot; 
		(the default &quot;20&quot;) in SetConfig.xml.
			</p>
			<p align="justify">If you want the step to create a detailed log of actions performed during the plan run, click on
			the dropdown triangle next to the <strong>Run</strong> button and select <strong>Run Configurations</strong>. In the 
			<em>Run Configurations</em> dialogue go to the <strong>Runtimes</strong> tab and in the 
			<strong>VM Arguments</strong> field write <code>-DaddressDoctor.debugLog=debug.xml</code>. This specification will
			save <code>debug.xml</code> into the folder with the plan. Alternatively, you can specify an arbitrary
			full path.
			</p>
		</description>
    <properties>
			<property name="etalonFolder" type="string" required="true">
				The folder containing configuration file(s) SetConfig.xml and optionally Parameters.xml.
			</property>
			<property name="parametersFile" type="string" required="false">
				The path to specific parameters configuration file.
			</property>
			<property name="inputElements" type="com.ataccama.dqc.tasks.addressdoctor.AddressInputElement[]" required="false">
				List of input address elements source.
			</property>
			<property name="outputElements" type="com.ataccama.dqc.tasks.addressdoctor.AddressOutputElement[]" required="false">
				List of output address elements mapping.
			</property>
			<property name="resultParameters" type="com.ataccama.dqc.tasks.addressdoctor.AddressResultParameter[]" required="false">
				List of parsing result output mapping.
			</property>
			<property name="processStatus" type="string" required="false">
				Name of column to store parsing process status.
			</property>
			<property name="recordDescriptorColumn" type="string" required="true">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
            <property name="elementScorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
                Element which stores scoring settings for address elements.
            </property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
			<scoringKey name="POSTAL_CODE_NULL">Set when postal code is empty (input status = 0)</scoringKey>
			<scoringKey name="POSTAL_CODE_INVALID">Set when postal code is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="POSTAL_CODE_CORRECTED">Set when postal code is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="LOCALITY_NULL">Set when locality is empty (input status = 0)</scoringKey>
			<scoringKey name="LOCALITY_INVALID">Set when locality is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="LOCALITY_CORRECTED">Set when locality is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="PROVINCE_NULL">Set when province is empty (input status = 0)</scoringKey>
			<scoringKey name="PROVINCE_INVALID">Set when province is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="PROVINCE_CORRECTED">Set when province is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="STREET_NULL">Set when street is empty (input status = 0)</scoringKey>
			<scoringKey name="STREET_INVALID">Set when street is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="STREET_CORRECTED">Set when street is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="NUMBER_NULL">Set when number is empty (input status = 0)</scoringKey>
			<scoringKey name="NUMBER_INVALID">Set when number is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="NUMBER_CORRECTED">Set when number is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="DELIVERY_SERVICE_NULL">Set when delivery service is empty (input status = 0)</scoringKey>
			<scoringKey name="DELIVERY_SERVICE_INVALID">Set when delivery service is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="DELIVERY_SERVICE_CORRECTED">Set when delivery service is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="BUILDING_NULL">Set when building is empty (input status = 0)</scoringKey>
			<scoringKey name="BUILDING_INVALID">Set when building is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="BUILDING_CORRECTED">Set when building is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="SUB_BUILDING_NULL">Set when subbuilding is empty (input status = 0)</scoringKey>
			<scoringKey name="SUB_BUILDING_INVALID">Set when subbuilding is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="SUB_BUILDING_CORRECTED">Set when subbuilding is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>
			<scoringKey name="COUNTRY_NULL">Set when country is empty (input status = 0)</scoringKey>
			<scoringKey name="COUNTRY_INVALID">Set when country is invalid/eliminated (result status = 3,5,6,9)</scoringKey>
			<scoringKey name="COUNTRY_CORRECTED">Set when country is wrong/corrected (input status = 3,4,5 or result status = 7,8,C,D)</scoringKey>

			<scoringKey name="ADDR_INVALID">Set when AD process status is V1, C1, C2, I1, I2, I3 or I4</scoringKey>
			<scoringKey name="ADDR_CORRECTED">Set when AD process status is V3, C3 or C4</scoringKey>
			<scoringKey name="ADDR_VERIFIED">Set when AD process status is V2 or V4</scoringKey>
			<scoringKey name="ADDR_NO_COUNTRY_FOUND">Set when AD process status is N1 or appropriate country etalon is not present</scoringKey>
			<scoringKey name="ADDR_NO_REFERENCE_DATA">Set when AD process status is N2</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.MultiplicativeGuessNameSurnameAlgorithm">
    <introduction>Parses and validates names and returns all possible matches.</introduction>
    <description>
			The step identifies a first name and a last name from specified data input
			in the same way the 
			<strong>Guess Name Surname</strong>
			does but in addition returns all matches (see <code>Bests Only</code> property) of
			input text to defined patterns in first matched pattern group.
			This identification and parsing is dependent on dictionaries that contain 
			a list of known first names and last names (see the properties).
			<br/>
			The step returns all matches as separate records (i.e. not only the best match but for each
			matched pattern returns evaluated result). Each group of records can
			be assigned an identifier of the form <code>&lt;group_id&gt;:&lt;record_count&gt;</code>.
			<br/>
			<br/>
			To illustrate its functionality let&#39;s assume:
			<ul>
			<li>
				two patterns:
				<ul>
					<li>A: {FIRST_NAME!} {LAST_NAME!}</li>
					<li>B: {LAST_NAME!} {FIRST_NAME!}</li>
				</ul>
			</li>
        <li>
			dictionaries with names &#39;Vítek&#39; and &#39;Vitek&#39; respectively (first and last name) 
			</li>
        <li>
			input row with text: &#39;Vítek Vitek&#39;.
			</li>
			</ul>
			When property <code>bestsOnly</code> is set to false, the step returns two records:
			<table border="1">
				<th>
          <th>input</th>
          <th>first name</th>
          <th>last name</th>
          <th>pattern</th>
        </th>
				<tr>
          <td>Vítek Vitek</td>
          <td>Vítek</td>
          <td>Vitek</td>
          <td>A</td>
        </tr>
				<tr>
          <td>Vítek Vitek</td>
          <td>Vitek</td>
          <td>Vítek</td>
          <td>B</td>
        </tr>
			</table>
			where names are swapped respectively (see diacritics).
			<br/>
			<br/>
			When the property is set to true, only a single record is returned:
			<table border="1">
				<th>
          <th>input</th>
          <th>first name</th>
          <th>last name</th>
          <th>pattern</th>
        </th>
				<tr>
          <td>Vítek Vitek</td>
          <td>Vítek</td>
          <td>Vitek</td>
          <td>A</td>
        </tr>
			</table>
			since the omitted record would have worse quality due to changes in diacritics.
			<br/>
			<br/>
			For a detailed description and other properties see <strong>Guess Name Surname</strong>.
		</description>
    <properties>
			<property name="in" type="string" required="true">
				Column that contains both input first name and last name.
			</property>
			<property name="firstName" type="string" required="true">
				Column that stores the final output first name (corresponding to the dictionary value).
			</property>
			<property name="lastName" type="string" required="true">
				Column that stores the final output last name (corresponding to the dictionary value).
			</property>
			<property name="firstNameOrig" type="string" required="false">
				Column that stores the original (input) first name.
			</property>
			<property name="lastNameOrig" type="string" required="false">
				Column that stores the original (input) last name.
			</property>
			<property name="patternName" type="string" required="false">
				Column that stores the name of the applied parsing pattern.
			</property>
			<property name="hintName" type="string" required="false">
				Column that stores the name of the applied parsing pattern hint.
			</property>
			<property name="trash" type="string" required="false">
				Column that stores the trash information. Trash information is the part
				of the input text which was not recognized
				as a known component or, when the <code>Full Trash Scope</code> flag is true,
				text parsed by component not having its own output column <code>Store Parsed Into</code>.
				The binding is not mandatory, thus the property <code>Full Trash Scope</code>
				is effective only when this binding is set.
			</property>		
			<property name="components" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.Component[]" required="false">
				List of user defined components.
			</property>
			<property name="fullTrashScope" type="boolean" required="true">
				Specifies whether text parsed by <code>Components</code> which don&#39;t define the <code>Store Parsed Into</code> parameter is
				stored in the column defined by the binding <code>Trash</code>. Text not parsed by any component is stored in any case.
				This parameter has an effect only if the binding <code>Trash</code> is defined.
				<br/>
				Default value: <code>False</code>.
			</property>
			<property name="firstNameLookupFileName" type="string" required="true">
				Dictionary file that contains known first names. This dictionary
				contains <strong>single-word</strong> first names.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="hints" type="com.ataccama.dqc.tasks.clean.config.Hint[]" required="false">
				Contains a list of definitions of parsing hints. A parsing hint defines how to parse input data when more than
				one parsing pattern is found which can be applied to the input string. It assists the step in picking
				the preferred parsing pattern in case of such ambiguity. In particular, hints are defined using property <code>hint</code>.
			</property>
			<property name="lastNameLookupFileName" type="string" required="true">
				Dictionary file that contains known last names. This dictionary	contains <strong>single-word</strong> last names.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="multiFirstNameLookupFileName" type="string" required="false">
				Dictionary file that contains known first names. This dictionary
				contains <strong>multi-word</strong> first names (multi-word components work with this dictionary).
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="multiLastNameLookupFileName" type="string" required="false">
				Dictionary file that contains known last names. This dictionary
				contains <strong>multi-word</strong> last names (multi-word components work with this dictionary).
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="patternGroups" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.PatternGroup[]" required="true">
				Tag associating the group of patterns <code>patternGroup</code>.
			</property>
			<property name="preserveIfDiffers" type="com.ataccama.dqc.tasks.clean.AbstractGuessNameSurnameAlgorithm$PreserveDifferentType" required="true">
				Defines whether the original value of the input firstname, lastname or both 
				should be retained if the final standardized value 
				(the selected dictionary value which conforms most closely
				with the original value) differs from the original value.
				The word &#39;differs&#39; here means that the values are different
				when compared for equality ignoring case but are the same when
				transformed by matching value generator defined by appropriate
				dictionary.<br/>
				Possible values: <code>PRESERVE_FIRSTNAME</code>, <code>PRESERVE_LASTNAME</code>,
				<code>PRESERVE_BOTH</code> and <code>PRESERVE_NONE</code>
        <br/>
				Default value: <code>PRESERVE_NONE</code>.
			</property>
			<property name="wordDefinition" type="string" required="true">
			  Default value: {WORD}
			</property>
			<property name="interlacedWordDefinition" type="string" required="true">
			  Default value: {INTERLACED_WORD}
			</property>
			<property name="multiWordDefinition" type="string" required="true">
			  Default value: {MULTIWORD:wordSeparators=&quot;-&#39;`&quot;&quot;~&quot;}
			</property>
			<property name="multiWordSeparators" type="string" required="true">
				Definition of possible word separators to be used by MULTI_FIRST_NAME and MULTI_LAST_NAME
				components when parsing and verifying. Empty value causes the text be split into separate characters.
                Default value: space. 
            </property>
			<property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Tokenizer Definition.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
			<property name="bestsOnly" type="boolean" required="true">
				Indicates that only best matches will be put into the output. Best matches
				means those matches that are evaluated to be of the best quality
				(when compared input names with names from dictionaries etc).
				Default value: false.
			</property>
			<property name="proposalSelectionStrategy" type="com.ataccama.dqc.tasks.clean.AbstractGuessNameSurnameAlgorithm$ProposalSelectionStrategy" required="true">
				Defines strategy to select from matched patterns.<br/>
				Possible values are:
				<ul>
					<li>DISTANCE_BASED selects only those patterns whose distance calculated over all matched names is the losest.</li>
					<li>FIRST_MATCH selects only the first matched pattern regardless of others.</li>
				</ul>
				Default value: <code>DISTANCE_BASED</code>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
            <scoringKey name="NM_NO_PATTERN">
                A scoring flag indicating that input &quot;in&quot; contains a NULL value or that no appropriate names were found in the dictionary.
            </scoringKey>
            <scoringKey name="NM_PART_PATTERN">
                A scoring flag indicating that only appropriate part of the pattern was found for a particular part of the input string.
                (i.e., the input string conforms to one of the defined parsing patterns but only part of the string was verified using dictionaries).
            </scoringKey>
            <scoringKey name="NM_MORE_PATTERNS">
                A scoring flag indicating that more than one pattern that conforms to the input string was found.
            </scoringKey>
            <scoringKey name="NM_DIFFERENT">
                A scoring flag indicating that a pattern was found but its components do not conform precisely to the appropriate
                parts of the input string.
            </scoringKey>
            <scoringKey name="NM_HINT">
                A scoring flag indicating that final pattern was applied according to the hint definition. The name of the hint applied
                is available in the binding <code>Hint Name</code>.
            </scoringKey>
            <scoringKey name="NM_TRASH">
                A scoring flag indicating that some text wasn&#39;t parsed or was parsed by a component having no
                special output if <code>Full Trash Scope</code> is specified. This flag is set even if the binding <code>trash</code>
                is not defined.
            </scoringKey>
            <scoringKey name="NM_NULL">
                A scoring flag indicating an empty input.
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.MultiplicativeLookupAlgorithm">
    <introduction>Searches an input value in a dictionary file and writes corresponding values from the dictionary file.</introduction>
    <description>
			The step returns all matches as separate records (i.e. not only the one best but more
			matched record). Each group of records can
			be assigned an identifier of the form &lt;group id&gt;:&lt;record count&gt;.
			<br/>
			This step is &quot;multiple record output&quot; variant of basic <strong>Lookup</strong>.
		</description>
    <properties>
			<property name="foreignKeyColumn" type="string" required="true">
				Search key value expression.
			</property>
			<property name="tableFileName" type="string" required="true">
				Generic table dictionary file name (see <strong>specification</strong>).
			</property>
			<property name="matchCondition" type="string" required="false">
				Boolean expression. Only table records satisfying this condition will be matched.<br/>
				The expression uses three record formats (dot-sources) for current record, record <code>lookup</code> from file
				and special <code>query</code> source, see detailed description.
				For example, the expression <code>levenshtein(src_first_name, lookup.fname) &lt;= 2</code> can be used.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnAssign[]" required="false">
				List of column assignments for populating record with data from table.
				The expressions in each element uses three record formats as in <code>Match Condition</code>.
			</property>
			<property name="maxDifference" type="integer" required="true">
				Maximal number of differences in approximative string search.
				Each difference means one of the following:
				<ul>
					<li>changing one character at any position within the string</li>
					<li>omitting one character in the searched key</li>
					<li>inserting one character into the searched key</li>
				</ul>
				When set to <code>0</code>, approximative searching is disabled. In case of non-string
				key types or in case the table doesn&#39;t contain a string index,
				the approximative search is not available and this property must be set to <code>0</code>.
				<br/>Default value: <code>0</code>.
			</property>
			<property name="selectBestMatch" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Specifies priority conditions used for selecting the best of more matching records.<br/>
				The expressions in each element uses three record formats as in <code>Match Condition</code>,
				so for example the expression <code>levenshtein(src_first_name, lookup.fname)</code> can be used to select the best
				matching record.
			</property>
			<property name="bestsOnly" type="boolean" required="true">
				Indicates that only best matches will be put into the output.
				<br/>Default value: false.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
			<scoringKey name="LKP_NULL_ID">
				Foreign key is null. No search has performed.
			</scoringKey>
			<scoringKey name="LKP_NOT_FOUND">
				No matching record has found in table file.
			</scoringKey>
			<scoringKey name="LKP_FOUND">
				One or more records matched the search criterion.
			</scoringKey>
			<scoringKey name="LKP_FOUND_DUPL">
				More than one record has matched search criterion.
			</scoringKey>
			<scoringKey name="LKP_APPROX_USED">
				The record has been found by approximative search of foreign key.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.loqate.MultiplicativeLoqateAlgorithm">
    <introduction>
			This step encapsulates the <a href="https://www.loqate.com/" target="_blank">Loqate©</a>
			address identification server.
		</introduction>
    <description>
		</description>
    <properties>
			<property name="dataFolder" type="string" required="true">
				The folder contains configuration locate.ini file, Loqate license file and reference data files (data packs).
                The step expects data files with .lfs format (extracted from the original .lfz archive).
			</property>
			<property name="inputElements" type="com.ataccama.dqc.loqate.AddressInputElement[]" required="true">
				List of input address elements source.
			</property>
			<property name="outputElements" type="com.ataccama.dqc.loqate.AddressOutputElement[]" required="false">
				List of output address elements mapping.
			</property>
			<property name="serverOptions" type="com.ataccama.dqc.loqate.OptionElement[]" required="false">
				List of additional server options (advanced use).
			</property>
			<property name="defaultCountry" type="string" required="false">
				Default country, used when country identification is not found in input elements.
			</property>
			<property name="geocoding" type="boolean" required="true">
				Use Geo location process.
			</property>
			<property name="maxResults" type="integer" required="false">
				Maximal number of output proposals. When &gt; 1 or not specified, uses <code>Search</code> process of Loqate server.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.classification.MultiplicativeNaiveBayesClassifier">
    <introduction>Performs classification of given columns based on Bayes Theorem</introduction>
    <description>
            <p align="justify">Algorithm classifies input string based on trained model. More about algorithm
                <code>http://en.wikipedia.org/wiki/Naive_Bayes_classifier</code>
                .</p>
            <p align="justify">Step outputs classification for all classes. To obtain for the best match class only, use the
                <strong>NaiveBayesClassifier</strong>
                step.</p>
            <p align="justify">Step requires model generated by
                <strong>NaiveBayesTrainer</strong>
                step. Model is composed of lookup and index files.</p>
        </description>
    <properties>
            <property name="accuracy" type="string" required="true">Output accuracy of classification.</property>
            <property name="classification" type="string" required="true">Output class name.</property>
            <property name="folder" type="string" required="true">Folder where model files are saved.</property>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="inputDocumentTokenizer" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">Tokenizer of the input document.</property>
            <property name="recordDescriptorColumn" type="string" required="false">Record descriptor column.</property>
            <property name="columns" type="com.ataccama.dqc.tasks.classification.columns.TesterColumn[]" required="false">
				List of columns used for creating classification.
			</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.parse.MultiplicativePatternParserAlgorithm">
    <introduction>
			Parses and validates any string against a dictionary file
			and returns all possible matches.
		</introduction>
    <description>
			This step performs parsing of the input string data based on defined parsing rules
			in the same way the <strong>Pattern Parser</strong> does
			but in addition returns all matches of input text to defined patterns in first matching pattern group.
			<br/>
			The step returns all matches as separate records (i.e. not only the best match but for each
			matched pattern returns evaluated result). Each group of records can
			be assigned an identifier of the form <code>&lt;group_id&gt;:&lt;record_count&gt;</code>.
			<br/>
			For a detailed description and other properties see 
			<strong>Pattern Parser</strong>.
		</description>
    <properties>
			<property name="in" type="string" required="true">
				Column that contains the text be processed.
			</property>
			<property name="patternName" type="string" required="false">
				Column that contains the name of the pattern which was used to parse the input string.
			</property>
			<property name="trash" type="string" required="false">
				Column that stores the trash information. Trash information is the part
				of the input text which was not recognized
				as a known component or, when the <code>Full Trash Scope</code> flag is true,
				text parsed by a component not having its own output column <code>Store Parsed Into</code>.
				The binding is not mandatory, thus the property <code>Full Trash Scope</code>
				is effective only when this binding is set.
			</property>		
			<property name="fullTrashScope" type="boolean" required="true">
				Specifies whether text parsed by components which don&#39;t use the <code>Store Parsed Into</code> parameter is
				stored into the column defined by the binding <code>Trash</code>. Text not parsed by any component is stored in any case.
				This parameter has effect only if the binding <code>Trash</code> is defined.
				<br/>
				Default value: <code>false</code>.
			</property>
			<property name="parserConfig" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.ParserConfig" required="true">
				Configuration of the parser.
			</property>
			<property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Configuration of the tokenizer.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
            <scoringKey name="PP_NULL">
                A scoring flag indicating that input data is missing.
            </scoringKey>
            <scoringKey name="PP_NO_PATTERN">
                A scoring flag indicating that no parsing pattern corresponding to the input value was found.
            </scoringKey>
            <scoringKey name="PP_MORE_PATTERNS">
                A scoring flag indicating that more than one parsing pattern matched the input string.
            </scoringKey>
            <scoringKey name="PP_TRASH">
                A scoring flag indicating that some text wasn&#39;t parsed or was parsed by a component having no
                special output in the case that <code>Full Trash Scope</code> is specified. This flag is set even if the binding <code>Trash</code>
                is not defined.
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.MultiplicativeRegexMatchingAlgorithm">
    <introduction>Parses and extracts values in the input string using defined patterns of regular expressions and returns all possible matches.</introduction>
    <description>
			The step analyzes input string in the same way as 
			<strong>Regex Matching</strong> 
			does but in addition returns all matches of the input string to defined regular expressions.
			Eexpressions that are defined as partial can match input text more than once and in such
			cases all matches can be return as well (see property <code>multiplicative</code>
			at <strong>Reg Expression</strong>).
			<br/>
			The step returns all matches as separate records (i.e. not only the best match but for each
			matched pattern returns evaluated result). Each group of records can
			be assigned an identifier of the form <code>&lt;group_id&gt;:&lt;record_count&gt;</code>.
			<br/>
			<br/>
			To illustrate its functionality let&#39;s assume:
			<ul>
			<li>
				three expressions:
				<ul>
					<li>A: zip [0-9]{5}, defined as partial matching and multiplicative</li>
					<li>B: zip [0-9]{5}, defined as partial matching but not multiplicative</li>
					<li>C: city [a-z]+, defined as partial matching and not multiplicative</li>
				</ul>
			</li>
        <li>
			each expression storing to zip, or city columns respectively
			</li>
        <li>
			input row with text: &#39;zip 18600, zip 46001, city Praha&#39;
			</li>
			</ul>
			The step returns four records:
			<table border="1">
				<th>
          <th>input</th>
          <th>zip</th>
          <th>city</th>
          <th>expression</th>
        </th>
				<tr>
          <td>zip 18600, zip 46001, city Praha</td>
          <td>18600</td>
          <td>null</td>
          <td>A</td>
        </tr>
				<tr>
          <td>zip 18600, zip 46001, city Praha</td>
          <td>46001</td>
          <td>null</td>
          <td>A</td>
        </tr>
				<tr>
          <td>zip 18600, zip 46001, city Praha</td>
          <td>18600</td>
          <td>null</td>
          <td>B</td>
        </tr>
				<tr>
          <td>zip 18600, zip 46001, city Praha</td>
          <td>null</td>
          <td>Praha</td>
          <td>C</td>
        </tr>
			</table>
			The expression A is returned twice, since the expression is defined both as multiplicative and partial
			and it matches both, 18600 and 46001 substrings so each of them is returned as
			a separate record. Expression B matches both 18600 and 46001 as well but this
			expression is not defined as multiplicative so only the first match is returned. 
			<br/>
			Null values in the records above are caused by single-column configuration of the expressions in this example. 
			Hence only one assignment is performed when the particular expression matches the input.
			<br/>
			For a detailed description and other properties see 
			<strong>Regex Matching</strong>.
		</description>
    <properties>
			<property name="expression" type="string" required="true">
				Expression applied to the input to get the input string, which will be matched with
				regular expressions.
			</property>
			<property name="regexNameColumn" type="string" required="false">
				Name of the column where the name of the regular expression which has
				been matched to the input string will be stored. Column type must be string.
			</property>
			<property name="appendRegexNameColumn" type="boolean" required="true">
			If set to true then the name of the regular expression is appended to the
			value in the <code>Regex Name Column</code> otherwise the value in the <code>Regex Name Column</code>
			is rewritten.
	        </property>
			<property name="appendRegexNameColumnSeparator" type="string" required="false">
			If the <code>Append Regex Name</code> is set to true and then this property
			is used to separate the old value in the <code>Regex Name Column</code> and the
			name of the regular expression.
	        </property>
			<property name="regExpressions" type="com.ataccama.dqc.tasks.clean.RegExpression[]" required="false">
				Contains definitions of regular expressions.
			</property>
			<property name="noMatchColumns" type="com.ataccama.dqc.tasks.common.column.ColumnAssign[]" required="false">
				Contains a list of expression and a target column, which should be assigned when no match is found.
				There are two cases when this element is used.
				<ul>
					<li>If the input is NULL, then the column specified in these elements will be
					filled with the NULL value (regardless of the expression).</li>
					<li>The input is not NULL, but it did not match to any of the regular expressions.
					In this case values of expressions defined in this element will be sent to the output.</li>
				</ul>
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
            <scoringKey name="STN_MATCHED">
                Inidcates that a match was found with the input data (including restrictions imposed
                by <code>ignoreCase</code> and <code>partialMatch</code>) and appropriate data was
                sent to the output.
            </scoringKey>
            <scoringKey name="STN_NULL">
                Indicates that the input value was empty.
            </scoringKey>
            <scoringKey name="STN_NOT_MATCHED">
                Indicates that no match was found. The values from the <code>No Match Columns</code>
                element are sent to the output.
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.MultiplicativeValidatePhoneNumberAlgorithm">
    <introduction>Parses and validates phone numbers and returns all possible matches.</introduction>
    <description>
			This step verifies the validity of a phone number in the same way as the 
			<strong>Validate Phone Number</strong>
			does but in addition it returns all matches of input text to defined patterns in first matched pattern group. 
			The matches returned never cross pattern group boundary (i.e. the same matches the parser 
			returns to the simple variant step are returned from this step).
			<br/>
			The step returns all matches as separate records (i.e. not only the best match but for each
			matched pattern returns evaluated result). Each group of records can
			be assigned an identifier of the form <code>&lt;group_id&gt;:&lt;record_count&gt;</code>.
			<br/>
			For a detailed description and other properties see 
			<strong>Validate Phone Number</strong>. 
		</description>
    <properties>
			<property name="components" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.Component[]" required="false">
				Definition of user components.
			</property>
			<property name="fullTrashScope" type="boolean" required="true">
				Specifies whether text parsed by components which don&#39;t the define <code>Store Parsed Into</code> parameter is
				stored into the column defined by the binding <code>Trash</code>. Text not parsed by any component is stored in any case.
				This parameter has effect only if the binding <code>Trash</code> is defined.
				<br/>
				Default value: <code>False</code>.
			</property>
			<property name="extSeparator" type="string" required="false">
				A single character (only) used as a delimiter between
				two extension numbers in the <code>Out Ext</code> output binding.
				Default value: <code>,</code> (comma).
			</property>
			<property name="idcLookupFileName" type="string" required="true">
				Dictionary file with known IDCs.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="idcPrefix" type="string" required="false">
				A string used for conversion of an international area code into a uniform output format.
				Allowed values are &quot;+&quot; or &quot;00&quot;.<br/>
				Default value is an empty string.
			</property>
			<property name="in" type="string" required="true">
				Column that contains the input phone number.
			</property>
	     	<property name="invalidDataDefinitions" type="com.ataccama.dqc.tasks.clean.AbstractValidatePhoneNumberAlgorithm$InvalidDataDefinitions" required="true">
	     		Collector tag for invalid data definitions
	     	</property>	     				
			<property name="numberPartLength" type="integer" required="true">
				Length of a part of the phone number into which the number is split in the output format.<br/>
				Default value: 3.
			</property>
			<property name="numberSeparator" type="string" required="false">
				Separator used for phone number parsing in the output format.
			</property>
			<property name="outExt" type="string" required="false">
				Column that stores is identified extension-line.
			</property>
			<property name="outExtOrig" type="string" required="false">
				Column that stores is original extension-line.
			</property>
			<property name="outIdc" type="string" required="false">
				Column that stores is identified international area code.
			</property>
			<property name="outIdcOrig" type="string" required="false">
				Column that stores is original international area code.
			</property>
			<property name="outPhoneNumber" type="string" required="false">
				Column that stores is final standardized (output) phone number.
			</property>
			<property name="outPhoneNumberOrig" type="string" required="false">
				Column that stores is original phone number.
			</property>
			<property name="outProv" type="string" required="false">
				Column that stores is identified phone provider number.
			</property>
			<property name="outProvOrig" type="string" required="false">
				Column that stores is original phone provider number.
			</property>
			<property name="outRuleName" type="string" required="false">
				Column that stores is used parsing rule that best describes the input structure.
			</property>
			<property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Definition of the tokenizer.
			</property>
			<property name="patternGroups" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.PatternGroup[]" required="true">
				This section associates individual <code>PatternGroup</code> tags representing one specified group of patterns.
			</property>
			<property name="prefix" type="string" required="false">
				String attached to the beginning of the phone number in the output.<br/>
				Default value is an empty string.
			</property>
			<property name="provLookupFileName" type="string" required="true">
				Dictionary file with known phone providers.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="trash" type="string" required="false">
				Column that stores trash information. Trash information is the part
				of the input text which was not recognized
				as a known component or, when the <code>Full Trash Scope</code> flag is true,
				text parsed by the component not having its own output column <code>Store Parsed Into</code>.
				The binding is not required, thus the property <code>Full Trash Scope</code>
				is effective only when this binding is set.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
            <scoringKey name="PN_NO_PATTERN">
                A scoring flag indicating that no parsing pattern (parsing rule) conforming to the input value was found.
            </scoringKey>
            <scoringKey name="PN_PART_PATTERN">
                A scoring flag indicating that only part of a parsing pattern matched the input phone number.
                The flag is being set in situations when IDC or PROV are parsed
                but not verified against their dictionaries.
            </scoringKey>
            <scoringKey name="PN_MORE_PATTERNS">
                A scoring flag indicating that more than one parsing pattern matched the input phone number.
            </scoringKey>
            <scoringKey name="PN_IDC">
                A scoring flag indicating that part of the input number considered to be an IDC number does not correspond
                to any of known IDCs in the used dictionary.
            </scoringKey>
            <scoringKey name="PN_PROV">
                A scoring flag indicating that part of the input number considered to be an provider number does not correspond
                to any of known providers in the used dictionary.
            </scoringKey>
            <scoringKey name="PN_NULL">
                A scoring flag indicating that no phone number in the input is provided.
            </scoringKey>
            <scoringKey name="PN_TRASH">
                A scoring flag indicating that some text wasn&#39;t parsed or was parsed by a component having no
                special output in the case that <code>Full Trash Scope</code> is specified. This flag is set even if the binding <code>Trash</code>
                is not defined.
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.Multiplicator">
    <introduction>Duplicates the data flow into several output flows.</introduction>
    <description>
			This step duplicates input data and sends them into several output flows.
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfNotExistFileOperation">
    <introduction>Verifies the absence of a source file/folder.</introduction>
    <description>Verifies the absence of a source file/folder.</description>
    <properties>
			<property name="sourceFile" type="string" required="true">Path to the source file or directory. The task fails when the source exists.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.classification.NaiveBayesClassifier">
    <introduction>Performs classification of given columns based on Bayes Theorem</introduction>
    <description>
            <p align="justify">Algorithm classifies input string based on trained model. More about algorithm
                <code>http://en.wikipedia.org/wiki/Naive_Bayes_classifier</code>
                .</p>
            <p align="justify">Step outputs only the best match class. To obtain classification for all classes, use the
                <strong>MultiplicativeNaiveBayesClassifier</strong>
                step.</p>
            <p align="justify">Step requires model generated by
                <strong>NaiveBayesTrainer</strong>
                step. Model is composed of lookup and index files.</p>
        </description>
    <properties>
            <property name="accuracy" type="string" required="true">Output accuracy of classification.</property>
            <property name="classification" type="string" required="true">Output class name.</property>
            <property name="folder" type="string" required="true">Folder where model files are saved.</property>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="inputDocumentTokenizer" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">Tokenizer of the input document.</property>
        	<property name="columns" type="com.ataccama.dqc.tasks.classification.columns.TesterColumn[]" required="false">
				List of columns used for creating classification.
			</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.classification.NaiveBayesTrainer">
    <introduction>Trainer for
            <strong>NaiveBayesClassifier</strong>
            models</introduction>
    <description>
            <p align="justify">Step creates lookup and index files for
                <strong>NaiveBayesClassifier</strong>
                and
                <strong>MultiplicativeNaiveBayesClassifier</strong>
                steps. Model is composed of lookup files and indexes, depending on the column type. File names are based on <code>Folder</code> and name of the column.</p>
            <p align="justify">Calculated probabilities are stored as logarithms of probability values except the new version of document, where other transformations are made.</p>
        </description>
    <properties>
            <property name="classifications" type="string" required="true">Input classification(s) column.</property>
            <property name="classificationsDelimiter" type="string" required="false">Classifications delimiter character(s).</property>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="folder" type="string" required="true">Folder for saving model files.</property>
            <property name="inputDocumentTokenizer" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">Tokenizer of the input document.</property>
            <property name="matchingValue" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="true">Matching value used for creating lookup files.</property>
        	<property name="columns" type="com.ataccama.dqc.tasks.classification.columns.TrainerColumn[]" required="false">
				List of columns used for creating model.
			</property>
        </properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.timeseries.settings.ModelSettings" name="com.ataccama.dqc.tasks.ai.timeseries.settings.NaiveModelSettings">
    <introduction>
            Simple naive model that uses the latest value of time series as a prediction.
        </introduction>
    <description>
            prediction: F(t+m) = x(t)
        </description>
    <properties>
            <property name="active" type="boolean" required="true">
                If this model should be used in the grid search.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.nlp.NameFinder">
    <introduction>Finds proper names in input sentences.</introduction>
    <description>
            <p align="justify">Step creates a new record for each proper name found in the input string. It can also
                identify category of the proper name (e.g. person, company).
            </p>
            <p align="justify">For optimal performance, one input record should be one sentence. Prepare large documents
                with
                <strong>SentenceTokenizer</strong>
                .</p>
            <p align="justify">OpenNLP model files are necessary for this step. Model files can be trained with the
                <strong>NameFinderTrainer</strong>
                and
                <strong>WordTokenizerTrainer</strong>
                steps.</p>
        </description>
    <properties>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="namesModelFile" type="string" required="true">OpenNLP TokenNameFinderModel file.</property>
            <property name="wordsModelFile" type="string" required="true">OpenNLP TokenizerModel file.</property>
            <property name="nameTagColumn" type="string" required="true">Column containing proper name category (e.g. person, company).</property>
            <property name="inputColumn" type="string" required="true">Column containing input sentences.</property>
            <property name="outputColumn" type="string" required="true">Column for output names.</property>
            <property name="recordDescriptorColumn" type="string" required="false">Record descriptor column.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.nlp.NameFinderTrainer">
    <introduction>Trains model for
            <strong>Name Finder</strong>
            step.</introduction>
    <description>
            <p align="justify">Step creates the model for
                <strong>NameFinder</strong>
                .</p>
            <p align="justify">The sentence must be tokenized and contain spans (the START:entityType END:entityType tag pairs) which mark the entities.</p>
            <p align="justify">Training input can contain several entity types. The trained model will be able to detect these types. Although it is recommended to use only single entity type models, since the multi-entity-type support is still experimental.</p>
            <p align="justify">The following sample shows the correct input format:</p>
            <example>
                <pre>&lt;START:person&gt; Pierre Vinken &lt;END&gt; , 61 years old , will join the board as a nonexecutive
director Nov. 29 . Mr . &lt;START:person&gt; Vinken &lt;END&gt; is chairman of Elsevier N.V. , the Dutch
publishing group .</pre>
            </example>
            <p align="justify">More information about training can be found at OpenNLP website (
                <code>http://opennlp.apache.org</code>
                ).</p>
        </description>
    <properties>
            <property name="cutoff" type="integer" required="true">The minimal number of times a feature must be seen, otherwise it is ignored.</property>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="inputValues" type="string" required="true">Training input column.</property>
            <property name="iterations" type="integer" required="true">Number of training iterations.</property>
            <property name="modelFile" type="string" required="true">Output model file.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.global.flow.NestedFlowParams">
    <properties>
			<property name="computeForRoot" type="boolean" required="true">Expression is evaluated for all cases. If the condition is true and also if the condition is false.</property>
			<property name="expression" type="string" required="false">Expression condition (<code>Boolean</code>).</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.security.NoSecurity">
    <introduction>Works as <strong>None</strong>. Ignores authentication headers; no authentication is needed for incoming requests. The difference from <strong>None</strong>: in case a user was provided (in http header), the server is able to ask the users role in a plan (for example, when you want to access a webpage, it asks if user has a role).</introduction>
    <description>Works as <strong>None</strong>. Ignores authentication headers; no authentication is needed for incoming requests. The difference from <strong>None</strong>: in case a user was provided (in http header), the server is able to ask the users role in a plan (for example, when you want to access a webpage, it asks if user has a role).</description>
    <properties/>
  </class>
  <class name="com.ataccama.server.http.security.def.NoSecurity">
    <introduction>Security setting can be set for a listener. Select this option if you do not wish to secure the server.</introduction>
    <description>Security setting can be set for a listener. Select this option if you do not wish to secure the server.</description>
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.normalization.definition.NormalizationFeatureTransformation">
    <introduction>Type of normalization.</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.normalization.NormalizerConfig">
    <introduction>Preforms normalization based on trained model.</introduction>
    <description>
            <p align="justify">
                Uses previously created model to normalize input data.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.transformation.normalization.columns.NormalizerFeatureConfig[]" required="true">
                Configuration of features used to preform normalization of the data based on the model file loaded.
            </property>
            <property name="modelFile" type="string" required="true">
                Name of file with trained model that will be used for normalization.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.normalization.columns.NormalizerFeatureConfig">
    <introduction>Configuration of features used to preform the normalization transformation.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be present in model file.
            </property>
            <property name="sourceColumn" type="string" required="true">
                Data input column for normalization transformation.
            </property>
            <property name="resultColumn" type="string" required="true">
                Output column, where the result of normalization transformation will be outputted to. Can be equal to source column.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.normalization.columns.NormalizerFeatureTrainerConfig">
    <introduction>Configuration of features used for normalization.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be used in classification step.
            </property>
            <property name="sourceColumn" type="string" required="true">
                Data input column for training the normalization model.
            </property>
            <property name="resultColumn" type="string" required="false">
                When filled, the trained model will do normalization on the source column and output it into result column.
            </property>
            <property name="normalizer" type="com.ataccama.dqc.tasks.ai.transformation.normalization.definition.NormalizationFeatureTransformation" required="true">
                Type of normalization.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.normalization.NormalizerTrainerConfig">
    <introduction>Trains normalization model.</introduction>
    <description>
            <p align="justify">
                Trains normalization model based on selected normalization type and input data.
                If result column is filled, use trained model to normalize training data and output the normalization to output column.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.transformation.normalization.columns.NormalizerFeatureTrainerConfig[]" required="true">
                Configuration of features used to train the model and perform normalization on training input data.
            </property>
            <property name="outputModelFile" type="string" required="true">
                Name of the model output file.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.global.domain.NumberParams">
    <description>Global Domain Number Parameters</description>
    <properties>
			<property name="invalidExamplesCount" type="integer" required="true">Number of distinct invalid results.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.NumberStatistics">
    <introduction>List of supported number statistics.<br/>
			<ul>
					<li>Max</li>
					<li>Mean</li>
					<li>Min</li>
					<li>Standard Deviation</li>
					<li>Sum</li>
					<li>Variance</li>
				</ul>
		</introduction>
    <properties>
			<property name="max" type="boolean" required="true">Maximum value in column.</property>
			<property name="mean" type="boolean" required="true">Median value in anomalous column.</property>
			<property name="min" type="boolean" required="true">Minimum value in column.</property>
			<property name="standardDeviation" type="boolean" required="true">Dispersion (variation) of values from the mean.</property>
			<property name="sum" type="boolean" required="true">Sum of all values.</property>
			<property name="variance" type="boolean" required="true">Measures how far a set of (random) numbers are spread out from their average value.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorSequenceId">
    <description>
			Column value is number from growing sequence.
		</description>
    <properties>
			<property name="from" type="long" required="true">
				Sequence start - first number generated.
			</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.domain.NumericDomainAnalysis">
    <description>
			String values are tested whether contains numbers in some format.   
		</description>
    <properties>
			<property name="threshold" type="integer" required="true">
				Specifies minimal rate (in percent) of values containing number to be
				column assumed in numeric domain.
				<br/>Default = 80%.
			</property>
			<property name="active" type="boolean" required="true">
				Specifies whether the analysis will be performed.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.reader.MMMReader">
    <introduction>This step allows the user to read data (entities) from the <strong>ONE Web Application</strong>.<br/>Keep in mind that this step consumes all incoming columns. If any of these columns need to be included in the output, you need to copy them using <strong>Shadow Columns</strong>, where the expression for each new shadow column points to the corresponding input column.</introduction>
    <description> 
			<strong>Implementation Examples:</strong>
					<ul>
						<li>You are using an external Business Intelligence tool (Tableau, Cognos, etc.) to display DQ Rules results on your data. DQ Evaluation project (rules with results) serves as a source of data for that Business Intelligence tool. In order to produce customized reports, you need to enrich each rule with its additional attributes (description, owner, custom attributes, etc.) that will be displayed in the report.</li>
						<li>You would like to create a DQC plan and you would like to drag and drop into your plan a rule that you would like to search based on its name and input attributes.</li>
						<li>You would like to create a DQC plans with data transformation, using the data sources from the ONE 2.0 Metadata Server.</li>
						<li>For your data catalog, you would like to create HTML documentation combining information about the physical object and profiling results.</li>
			</ul>
		</description>
    <properties>
			<property name="childEntities" type="com.ataccama.dqc.tasks.io.mmm.columns.MMMChildEntity[]" required="false">When you select a subtype, its properties will be available in <Strong>Columns</Strong>. Subtypes also function in embedded entity streams.</property>
			<property name="columns" type="com.ataccama.dqc.tasks.io.mmm.columns.MMMColumnDef[]" required="true">Definitions of columns that will be retrieved from the ONE Web Application based on properties of selected <Strong>Entity Type</Strong>.</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">Data format parameters are parameters used for data formatting when an internal/external data format conversion is required. This task typically occurs when <strong>ONE IDE</strong> needs to load data from an external file or needs to store data to an external file. Data format parameters then describe how to convert data to the desired form based on the reading and writing file data formats. Processing steps supporting DataFormatParameters (DFP) can define DFP at the top level of a step as well as on the &quot;local&quot; level of each column. If there are noDFP defined on the local level, the global DFP are used. If global data format parameters are not defined, the default values are assumed. When a column defines its own DFP,this DFP must contain all attributes needed for successful parsing (those attributes must be assigned valid values). The only exception to this rule is Thousands Separator.In contrast with the rest of DFP attributes that must always have some value, Thousands Separator may remain empty (meaning that no thousands separator is used). </property>
			<!--XXX-->
			<property name="embeddedEntityStreams" type="com.ataccama.dqc.tasks.io.mmm.reader.MMMReaderRootStreamConfig[]" required="false">Allows you to create separate reader that will be reading selected attributes of catalog items. There will be a separate output endpoint for those attributes.
			For instance you can read connection attributes stored under data source catalog items, etc.</property>
			<property name="entityColumnName" type="string" required="false">Entities have subtypes. Define a column to store the concrete subtype (i.e. businessTerm is a subtype of term).</property>
			<property name="entityType" type="string" required="true">Entity type that will be retrieved from the <strong>ONE Web Application</strong> (catalog item, term, job, configuration, etc.).</property>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="idColumnName" type="string" required="false">ID of the entity instance.</property>
			<property name="inputTemplate" type="string" required="false">Template defining structure of body of message. Enter a desired query using AQL, e.g.: <code>$id = &quot;0e40b980-d671-4021-876f-a5dbb3d2052c&quot;</code>
        <br/>
For more information see, <a href="https://support.ataccama.com/home/docs/aip/latest/user-guides/one-web-application-user-guide/one-basics/searching-in-one-web-application#SearchinginONEWebApplication-SearchingUsingAQL" target="_blank">Searching in ONE Web Application</a>.</property>
			<property name="parentIdColumnName" type="string" required="false">ID of the entity instance that is parent to the retrieved entity. For example, if you are reading an attribute, parent entity ID would be the ID of the catalogItem instance this attribute belongs to.</property>
			<property name="serverName" type="string" required="true">Connection details for connecting the  <strong>ONE Web Application</strong>.  (<strong>File Explorer</strong> &gt; <strong>Servers</strong>)</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result of <strong>Default Expression</strong>.</property>
			<property name="templateBeginMark" type="string" required="false">Symbol marking the beginning of column placeholder.</property>
			<property name="templateEndMark" type="string" required="false">Symbol marking the end of column placeholder.</property>
			<property name="workflowState" type="string" required="true">State of the entity instance that <strong>ONE Metadata Reader</strong> step will read.<br/>
			<ul>
			<li>
            <code>draft</code>: the latest version available.</li>
			<li>
            <code>published</code>: the latest approved version available.</li>
			</ul>
			</property>
	</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.writer.MMMReferenceArrayWriter">
    <introduction>This step allows the user to modify array of references property in the <strong>ONE Web Application</strong>.</introduction>
    <properties>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="serverName" type="string" required="true">Connection details for connecting the <strong>ONE Web Application</strong>.  (<strong>File Explorer</strong> &gt; <strong>Servers</strong>)</property>
			<property name="entityType" type="string" required="true">Entity type that you will write into on the <strong>ONE Web Application</strong> (catalog item, term, job, configuration, etc.).</property>
			<property name="workflowState" type="string" required="true">State of the entity instance that the step will write to.<br/>
				<ul>
					<li>
            <code>draft</code>: the latest version available.</li>
					<li>
            <code>published</code>: the latest approved version available.</li>
				</ul>
			</property>
			<property name="idColumnName" type="string" required="true">Column with ID of modified entity.</property>
			<property name="property" type="string" required="true">Name of property (array of references) to which to write.</property>
			<property name="operation" type="com.ataccama.dqc.tasks.io.mmm.writer.MMMReferenceArrayWriter$OperationType" required="true">Operation to perform on the property.</property>
			<property name="targetIdColumnName" type="string" required="true">Name of the column containing the ID of entity to add or remove from the property.</property>
			<property name="writeStatusColumnName" type="string" required="false">Name of the column where you want to add information whether a record was written successfully.</property>
			<property name="failureDescriptionColumnName" type="string" required="false">Name of the column where you want to add details of possible failures when writing.</property>
			<property name="workflowStateColumnName" type="string" required="false">Specify a column of a Imported Entities File to store the information, in which workflow state was the entity written into <strong>ONE Web Application</strong> (important when an error occurs during the import)</property>
			<property name="errorHandling" type="string" required="false">Set the desired error handling strategy.</property>
			<property name="logFileName" type="string" required="false">Name of the log file. CSV and comma separated text files are supported.</property>
			<property name="logIntoFile" type="boolean" required="false">Enable to log records into a file instead of a database.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.writer.MMMWriter">
    <introduction>This step allows the user to write data to the <strong>ONE Web Application</strong>.</introduction>
    <description>
			<strong>Implementation Examples:</strong>
			<ul>
				<li>
          <strong>One time migration:</strong> The <strong>ONE Web Application</strong> will be used for management of metadata import.</li>
				<li>
          <strong>Integration:</strong> External tool is used for management of metadata entities. The <strong>ONE Web Application</strong> will be just a consumer. It will provide:
				<ul>
				<li>Scheduling.</li>
				<li>Version controlling.</li>
				<li>Potential changes in MMD.</li>
				<li>Mapping of some attributes.</li>
				</ul>
				</li>
				<li>
          <strong>Creating elements as a result of some data processing:</strong>
				When the processing detects a lot of similar data issues (or something interesting in the profiling), it automatically creates a rule that should prevent those problems in a future (a template, that has to be finished manually). This behavior would the user configure as a plan (the <strong>ONE Metadata Writer</strong> step in the data processing plan or in a component triggered after the data processing)</li>
				</ul>
			</description>
    <properties>
			<property name="childEntities" type="com.ataccama.dqc.tasks.io.mmm.columns.MMMChildEntity[]" required="false">Select entity subtypes you want to include. If you select a subtype, its properties will be available in <strong>Columns</strong> to write in.</property>
			<property name="columns" type="com.ataccama.dqc.tasks.io.mmm.columns.MMMColumnExprDef[]" required="false">Definitions of columns that will be written into the ONE Web Application based on properties of selected <strong>Entity Type</strong>.</property>
			<property name="createdGidColumnName" type="string" required="false">Output column. In case Output Endpoint is connected to other step it can provide information under which ID this node has been written to <strong>ONE Web Application</strong>.</property>
			<property name="entityColumnName" type="string" required="false">Entities have subtypes (i.e. businessTerm is subtype of term). Specify a column with the concrete subtype filled to write instances of these subtypes. Leave empty when the selected entity has no subtypes.</property>
			<property name="entityType" type="string" required="true">Entity type that you will write into on the <strong>ONE Web Application</strong> (catalog item, term, job, configuration, etc.).</property>
			<property name="errorHandling" type="string" required="false">Set the desired error handling strategy.</property>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="idColumnName" type="string" required="false">When updating or deleting existing entity instances, specify a column with ID of these instances. Leave empty when creating new entities.</property>
			<property name="logFileName" type="string" required="false">Name of the log file. CSV and comma separated text files are supported.</property>
			<property name="logIntoFile" type="boolean" required="false">Enable to log records into a file instead of a database.</property>
			<property name="writeStatusColumnName" type="string" required="false">Name of the column where you want to add information whether a record was written successfully.</property>
			<property name="failureDescriptionColumnName" type="string" required="false">Name of the column where you want to add details of possible failures when writing.</property>
			<property name="parentIdColumnName" type="string" required="false">Specify a column with ID of the parent entity instance, in which the created entity instance should be written into (i.e. Id of the concrete catalogItem when writing it&#39;s attributes). Leave empty when the parent type is <strong>metadata</strong>.</property>
			<property name="parentProperty" type="string" required="true">Property name of the entity, in which will the created/updated entity be embedded.</property>
			<property name="parentType" type="string" required="false">Type of the parent entity (metadata, metadataRule, metadataTermInstance, metadataRuleInstance, etc.).</property>
			<property name="logFile" type="string" required="false">Name of the file with list of imported entities together with assigned IDs.</property>
			<property name="workflowStateColumnName" type="string" required="false">Specify a column of a Imported Entities File to store the information, in which workflow state was the entity written into <strong>ONE Web Application</strong> (important when an error occurs during the import)</property>
			<property name="serverName" type="string" required="true">Connection details for connecting the <strong>ONE Web Application</strong>.  (<strong>File Explorer</strong> &gt; <strong>Servers</strong>)</property>
			<property name="workflowState" type="string" required="true">State of the entity instance that <strong>ONE Metadata Writer</strong> step will write to.<br/>
			<ul>
			<li>
            <code>draft</code>: the latest version available.</li>
			<li>
            <code>published</code>: the latest approved version available.</li>
			<li>
            <code>deleted</code>: deleted node.</li>
			</ul>
			</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.encoding.EncoderConfig">
    <introduction>Preforms One Hot Encoding based on trained model.</introduction>
    <description>
            <p align="justify">
                Uses previously created model to encode input data.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.transformation.encoding.columns.EncoderFeatureConfig[]" required="true">
                Configuration of features used to preform encoding of the data based on the model file loaded.
            </property>
            <property name="modelFile" type="string" required="true">
                Name of file with trained model that will be used for encoding.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.encoding.EncoderTrainerConfig">
    <introduction>Trains One Hot Encoding model.</introduction>
    <description>
            <p align="justify">
                Trains One Hot Encoding model based on selected normalization type and input data.
                If result column is filled, use trained model to encode training data and output the encoder to output column.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.transformation.encoding.columns.EncoderFeatureTrainerConfig[]" required="true">
                Configuration of features used to train the model and perform encoding on training input data.
            </property>
            <property name="outputModelFile" type="string" required="true">
                Name of the model output file.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.transformation.FeatureTransformation" name="com.ataccama.dqc.tasks.ai.transformation.encoding.definition.OneHotEncodingTransformation">
    <introduction>Performs binarization of a categorical values. Encodes value to a list of booleans.</introduction>
    <description>
            Every distinct value in the column creates its own column with value as a label of the column.
            True value appears in the corresponding column (the value equals the label of the column). False value is in all other columns.
        </description>
  </class>
  <class name="com.ataccama.dqc.online.OnlineServicesComponent">
    <introduction>Initializes and deploys all services which should be available for online requests.</introduction>
    <description>
			<p align="justify">Initializes and deploys all services which should be available for online requests.</p>
			<p align="justify">
				The Online Services Component requires the <strong>Http Dispatcher</strong> component to be started.
			</p>
			<p align="justify">
				To change the configuration files without the need to stop or restart the online server, add paths to the folders containing the files to the <strong>Versioned Folders</strong> section of the <strong>Versioned File System Component</strong>. 
			</p>
			<p align="justify">
				Note: it is <strong>not recommended</strong> for the service to produce any outputs or to modify any files inside the versioned folders (including log files). The changes to the files in versioned folders will be lost if the server stops or the configuration changes and the service restarts. Versioned folders are useful for changes that are done outside the running server.
			</p>
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="listeners" type="string" required="false">Comma-separated list of names of HTTP listeners to which all service handlers should be registered. If the attribute is missing, all services will be deployed on all listeners.</property>
			<property name="serviceLookupFolders" type="string[]" required="true">Relative (to the server configuration file) or absolute path to the file system folder(s) which contain all necessary configuration files, i.e. the <code>*.online</code> files that contain definition of online services. All <code>*.online</code> files from the configuration folder are processed and the defined services started.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfFileOperationTask">
    <introduction>Provides 10 file operations: Copy, Delete, Exists, Not_exists, List, Mkdir, Move, Info, Unzip, Zip.</introduction>
    <description>Provides 10 potential file operations: Copy, Delete, Exists, Not_exists, List, Mkdir, Move, Info, Unzip, Zip, which are defined in the <strong>Operation</strong> parameter. Some parameters support the following wildcards <code>?</code> and <code>*</code> at any path level:
		<ul>
				<li>
          <code>?</code>: 1 character, except file separators &#39;/&#39; and &#39;\&#39;</li>
				<li>
          <code>*</code>: 0…N characters, except file separators &#39;/&#39; and &#39;\&#39;</li>
			</ul>
			<p align="justify">The task can use remote resources (accessible with <code>resource://&lt;resourceName&gt;/&lt;path&gt;/&lt;inputFile&gt;</code> syntax):</p>
			<ul>
			<li>Amazon S3 server</li>
			<li>HDFS (if your product package contains Big Data Engine)</li>
			</ul>
			Note: The task evaluates both /data/tmp and /data/tmp/ paths as a tmp folder, so to operate folder&#39;s content without the folder itself, using /data/tmp/?* mask is recommended.
			<br/>All operations naturally respect permissions on the filesystem (i.e. in case of insufficient permissions on the specified source/target, the task fails).
		</description>
    <properties>
			<property name="operation" type="com.ataccama.adt.file.operations.IEwfFileOperationTask" required="true">Defines a file operation. Possible implementations: Copy, Delete, Exists, Not_exists, Mkdir, Move, Info, Unzip, Zip.</property>
		</properties>
  </class>
  <class name="com.ataccama.extension.salesforce.dqc.io.SalesforceWriter$Operation">
    <description/>
  </class>
  <class name="com.ataccama.dqc.unify.config.IOperationConfig">
    <introduction>
		</introduction>
    <properties>
			<property name="id" type="string" required="true">
				Unique id of operation.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.mmm.writer.MMMReferenceArrayWriter$OperationType">
    <description>Operation to perform upon array of references property.</description>
  </class>
  <class name="com.ataccama.dqc.loqate.OptionElement">
    <properties>
			<property name="option" type="string" required="true">
				Server option name.
			</property>
			<property name="value" type="string" required="false">
				Option value. Allowed values depend on option, see Loqate documentation.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.iterators.order.IOrder">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.components.OrderBy">
    <properties>
			<property name="expression" type="string" required="true">
			Specifies the expression evaluated to a value used in sorting.
			</property>
			<property name="locale" type="string" required="false">
			Locale definition for compared string values.
			</property>
			<property name="nullsFirst" type="boolean" required="true">
			Specifies whether null records should be sorted at the beginning of the data set.
			</property>
			<property name="orderDescending" type="boolean" required="true">
			Specifies the sort direction.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.components.addresses.can.CANAddressesGenerated$OutEndPoint">
    <introduction>
            Output column mappings.

            Source/input values of address component are returned in case the address in not sufficiently identified.
        </introduction>
    <description>
            <linkTarget id="linkAddressValidityLevelCA"/>
            <div>
        <strong>
          <em>Address Validity Levels</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
          <td>DELIVERY_POINT</td>  <td>Address identified to specific delivery point (house, unit, PO BOX etc.)</td>
        </tr>
				<tr>
          <td>BUILDING</td>  <td>Address identified up to specific building, building unit is ambiguous</td>
        </tr>
				<tr>
          <td>STREET</td>  <td>Address identified up to specific street, ambiguous house on street (box in rural route for RR addresses)</td>
        </tr>
				<tr>
          <td>CITY</td>  <td>Address identified to city level only (ambiguous street) or addresses within rural areas.</td>
        </tr>
				<tr>
          <td>POSTAL_CODE</td>  <td>Address identified to postal code level. Mainly for Large Volume Receivers addresses.</td>
        </tr>
				<tr>
          <td>NULL</td> <td>No address component (or component combination) was found in reference data. Address invalid.</td>
        </tr>
            </table>

            <linkTarget id="linkAddressStatus"/>
            <div>
        <strong>
          <em>Address Statuses</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
				<tr>
          <td>V</td>  <td>CA POST SERP VALIDITY CODE: No or minimal correction was done to the input value. Software package is able to detect all address components. The result address is valid.</td>
        </tr>
				<tr>
          <td>N</td>  <td>CA POST SERP VALIDITY CODE: The result address is invalid. Software package is unable to detect all address components or make valid corrections.</td>
        </tr>
				<tr>
          <td>C</td>  <td>CA POST SERP VALIDITY CODE: An invalid address is “correctable” “C” when there are one or more components missing or inconsistent from an otherwise valid address; and only one address can be derived from the information provided. </td>
        </tr>
            </table>

             <linkTarget id="linkAddressLabelCA"/>
            <div>
        <strong>
          <em>Address Labels</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
				<tr>
          <td>VALID</td>  <td>Address is correct or differs only in standardization (state name, street direction etc.) </td>
        </tr>
				<tr>
          <td>CORRECTED_MINOR</td>  <td>Address quality is good, minor corrections performed (typos in names, small differences etc.) </td>
        </tr>
				<tr>
          <td>CORRECTED_MAJOR</td>  <td>Address quality is poor, address components corrected (different city or several minor corrections in different address elements)</td>
        </tr>
				<tr>
          <td>UNKNOWN</td>  <td>Address is invalid and was not parsed, or is ambiguous (unidentified to delivery point) </td>
        </tr>
				<tr>
          <td>INSUFFICIENT_INPUT</td>  <td>Input address elements are empty or not sufficient to be identified. </td>
        </tr>
			</table>

            <linkTarget id="linkScoAddress"/>
            <div>
        <strong>
          <em>Data Quality Scorings</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
          <td>0</td>  <td>Valid value. No modification was done to the input value or LVR identified.</td>
        </tr>
				<tr>
          <td>&lt; 400</td>  <td>Corrected value - corrected minor. Small modification was done to the input value (special places removed), but resulting value is still valid and verified.</td>
        </tr>
				<tr>
          <td>&gt;= 400 delivery point found</td>  <td>Corrected value - corrected major. Large modification was done to the input value. Resulting value is unsafe but still verified.</td>
        </tr>
				<tr>
          <td>&gt;= 400 delivery point not found</td>  <td>Unknown value. Input value is null or has wrong structure. Address was not identified.</td>
        </tr>
            </table>

            <linkTarget id="linkExpAddressCA"/>
            <div>
        <strong>
          <em>Explanation Codes</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
		            <td>A_ADDR_TYPE_DIFFERENT</td>
		            <td>Address Type different. Score 50-1000.</td>
		         </tr>
		         <tr>
		            <td>A_BOX_MISSING_MORE_IN_RANGE</td>
		            <td>Postal Box number missing. More in range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_BOX_MISSING_SINGLE_RANGE</td>
		            <td>Postal Box number missing. Single range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_BOX_OUTSIDE_SINGLE_RANGE</td>
		            <td>Postal Box number outside single range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_ADDRESS_TOO_FAR</td>
		            <td>Too many differences in cleansed output. Score 1000.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_ADDRESS_TYPE_SWITCH_TOO_LARGE</td>
		            <td>Address type correction possibly too large. Score 500.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_CIVICRR_MISSING_RR_INFO</td>
		            <td>Route service type in civic address missing. Score 50.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_ROUTE_NUMBER_MISSING</td>
		            <td>Route service number missing. Score 100.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_ROUTE_TYPE_MISSING</td>
		            <td>Route type missing. Score 100.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_STATION_NAME_MISSING</td>
		            <td>Station name missing. Score 20-50.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_STATION_TYPE_MISSING</td>
		            <td>Station type missing. Score 20-50.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_STREET_DIRECTION_DIFFERENT</td>
		            <td>Street direction different. Score 100.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_STREET_DIRECTION_MISSING</td>
		            <td>Street direction missing. Score 50.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_STREET_TYPE_ADDED</td>
		            <td>Street type added. Score 100.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_STREET_TYPE_DIFFERENT</td>
		            <td>Street type different. Score 250.</td>
		         </tr>
		         <tr>
		            <td>A_FINAL_STREET_TYPE_MISSING</td>
		            <td>Street type missing. Score 50.</td>
		         </tr>
		         <tr>
		            <td>A_LVR_POSTAL_CODE_FOUND</td>
		            <td>Large volume receivers postal code identified. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_MUNICIPALITY_ALTERNATE</td>
		            <td>Alternative municipality name identified. Score 1-20.</td>
		         </tr>
		         <tr>
		            <td>A_MUNICIPALITY_ALTERNATE_AND_DIFF_PROVINCE</td>
		            <td>Alternative municipality name identified. Province different. Score 1000.</td>
		         </tr>
		         <tr>
		            <td>A_MUNICIPALITY_ALTERNATE_INVALID</td>
		            <td>Invalid alternative municipality name. Score 0-30.</td>
		         </tr>
		         <tr>
		            <td>A_MUNICIPALITY_ALTERNATE_VALID</td>
		            <td>Valid alternative municipality name. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_MUNICIPALITY_CORRECTED</td>
		            <td>Municipality name corrected. Score 10 * difference. Max 30.</td>
		         </tr>
		         <tr>
		            <td>A_MUNICIPALITY_DIFFERENT</td>
		            <td>Municipality name different. Score 500-1000.</td>
		         </tr>
		         <tr>
		            <td>A_MUNICIPALITY_MISSING</td>
		            <td>Municipality name missing. Score 0-40.</td>
		         </tr>
		         <tr>
		            <td>A_POSTAL_CODE_CORRECTED</td>
		            <td>Postal Code corrected. Score 200.</td>
		         </tr>
		         <tr>
		            <td>A_POSTAL_CODE_AS_POSTAL_CODE3</td>
		            <td>Postal Code 3 identified. Score 10.</td>
		         </tr>
		         <tr>
		            <td>A_POSTAL_CODE_CONGRUENT_6</td>
		            <td>Postal Code 6 identified. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_POSTAL_CODE_CORRECTED_CHARACTER_CHANGE</td>
		            <td>Postal Code corrected. Character found and changed to digit. Score 30.</td>
		         </tr>
		         <tr>
		            <td>A_POSTAL_CODE_DIFFERENT</td>
		            <td>Postal Code different. Score 500-1000.</td>
		         </tr>
		         <tr>
		            <td>A_POSTAL_CODE_MISSING</td>
		            <td>Postal Code missing. Score 0-1000.</td>
		         </tr>
		         <tr>
		            <td>A_PROVINCE_CORRECTED</td>
		            <td>Province code corrected. Score 30.</td>
		         </tr>
		         <tr>
		            <td>A_PROVINCE_DIFFERENT</td>
		            <td>Province code different. Score 100-1000.</td>
		         </tr>
		         <tr>
		            <td>A_PROVINCE_INVALID</td>
		            <td>Invalid province code. Score 50.</td>
		         </tr>
		         <tr>
		            <td>A_PROVINCE_MISSING</td>
		            <td>Province code missing. Score 0-40.</td>
		         </tr>
		         <tr>
		            <td>A_PROVINCE_STANDARDIZED</td>
		            <td>Province code standardized. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_ROUTE_NUMBER_DIFFERENT</td>
		            <td>Route service number different. Score 100-1000.</td>
		         </tr>
		         <tr>
		            <td>A_ROUTE_NUMBER_MISSING</td>
		            <td>Route service number missing. Score 100.</td>
		         </tr>
		         <tr>
		            <td>A_ROUTE_NUMBER_ON_GD_ADDRESS</td>
		            <td>Route service number at general delivery address type. Score 500.</td>
		         </tr>
		         <tr>
		            <td>A_ROUTE_TYPE_DIFFERENT</td>
		            <td>Route service type different. Score 100-1000.</td>
		         </tr>
		         <tr>
		            <td>A_ROUTE_TYPE_IDENTIFIER_CORRECTED</td>
		            <td>Route service type corrected. Score 30.</td>
		         </tr>
		         <tr>
		            <td>A_ROUTE_TYPE_MISSING</td>
		            <td>Route service type missing. Score 50.</td>
		         </tr>
		         <tr>
		            <td>A_ROUTE_TYPE_ON_CIVIC_ADDRESS</td>
		            <td>Route service type at civic address type. Score 250.</td>
		         </tr>
		         <tr>
		            <td>A_SN_OUTSIDE_RANGE</td>
		            <td>Civic number outside range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SN_SUFFIX_ADDED</td>
		            <td>Civic number suffix added. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SN_SUFFIX_OUTSIDE_RANGE</td>
		            <td>Civic number suffix outside range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SRC_LVR_POSTAL_CODE_OVERRIDE</td>
		            <td>Large volume receivers Postal Code identified. All explanation codes overriden. Address
		               output has to be the same as input according to CA Post. Score back to 0.
		            </td>
		         </tr>
		         <tr>
		            <td>A_STATION_NAME_ADDED</td>
		            <td>Station name added. Score 70-500.</td>
		         </tr>
		         <tr>
		            <td>A_STATION_NAME_CORRECTED</td>
		            <td>Station name corrected. Score 10 * difference. Max 30.</td>
		         </tr>
		         <tr>
		            <td>A_STATION_NAME_DIFFERENT</td>
		            <td>Station name different. Score 100.</td>
		         </tr>
		         <tr>
		            <td>A_STATION_TYPE_ADDED</td>
		            <td>Station type added. Score 70.</td>
		         </tr>
		         <tr>
		            <td>A_STATION_TYPE_CORRECTED</td>
		            <td>Station type corrected. Score 30.</td>
		         </tr>
		         <tr>
		            <td>A_STATION_TYPE_STANDARDIZED</td>
		            <td>Station type standardized. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_STATION_TYPE_WNAME_DIFFERENT</td>
		            <td>Input and output station type differs. Station name is missing. Score 50.</td>
		         </tr>
		         <tr>
		            <td>A_STATION_TYPE_WONAME_DIFFERENT</td>
		            <td>Input and output station type differs. Score 30.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_ALTERNATE</td>
		            <td>Alternative street name identified. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_DIRECTION_ADDED</td>
		            <td>Street direction added. Score 50.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_DIRECTION_CORRECTED</td>
		            <td>Street direction corrected. Score 30.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_DIRECTION_DIFFERENT</td>
		            <td>Street direction different. Score 1000.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_DIRECTION_STANDARDIZED</td>
		            <td>Street direction standardized. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_NAME_CORRECTED</td>
		            <td>Street name corrected. Score 10-1000</td>
		         </tr>
		         <tr>
		            <td>A_STREET_NAME_DIFFERENT</td>
		            <td>Street name different. Score 1000.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_NAME_MISSING</td>
		            <td>Street name missing. Score 500.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_TYPE_AMBIGUOUS</td>
		            <td>Street type ambiguous. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_TYPE_CORRECTED</td>
		            <td>Street type corrected. Score 30.</td>
		         </tr>
		         <tr>
		            <td>A_STREET_TYPE_DIFFERENT</td>
		            <td>Street type different. Score 1000.</td>
		         </tr>
		         <tr>
		            <td>A_SUITE_ADDED</td>
		            <td>Suite/unit added. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SUITE_MISSING_MORE_IN_RANGE</td>
		            <td>Suite/unit missing. More in range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SUITE_MISSING_SINGLE_RANGE</td>
		            <td>Suite/unit missing. Single range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SUITE_MULTIPLE_OUTSIDE_MORE_IN_RANGE</td>
		            <td>Suite/unit multiple outside range. More in range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SUITE_MULTIPLE_OUTSIDE_SINGLE_RANGE</td>
		            <td>Suite/unit multiple outside range. Single range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SUITE_OUTSIDE_MORE_IN_RANGE</td>
		            <td>Suite/unit outside range. More in range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SUITE_OUTSIDE_SINGLE_RANGE</td>
		            <td>Suite/unit outside range. Single range. Score 0.</td>
		         </tr>
		         <tr>
		            <td>A_SUITE_WITH_HASH_EXTRACTED</td>
		            <td>&quot;#&quot; extracted from suite/unit. Score 10.</td>
		         </tr>
		         <tr>
		            <td>A_UNIT_INTERVAL_CUT</td>
		            <td>Suite/unit interval corrected. Score 0.</td>
		         </tr>
		         <tr>
		            <td>CIVIC_RR_MATCHED</td>
		            <td>Civic route service address type matched. Score 0.</td>
		         </tr>
		         <tr>
		            <td>GD_RR_FOUND</td>
		            <td>Route service address at general delivery address type identified. Score 0.</td>
		         </tr>
            </table>

            <linkTarget id="linkStdRecordType"/>
            <div>
        <strong>
          <em>Record Types</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
          <td>1</td>  <td>Street Address Record, Point of Call managed</td>
        </tr>
				<tr>
          <td>2</td>  <td>Street Served By Route Record</td>
        </tr>
				<tr>
          <td>3</td>  <td>Lock Box Address Record</td>
        </tr>
				<tr>
          <td>4</td>  <td>Route Service Address Record</td>
        </tr>
				<tr>
          <td>5</td>  <td>General Delivery Address Record</td>
        </tr>
            </table>

            <linkTarget id="linkStdStreetDirection"/>
            <div>
        <strong>
          <em>Street Directions</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
          <td>N</td>  <td>North/Nord</td>
        </tr>
				<tr>
          <td>S</td>  <td>South/Sud</td>
        </tr>
				<tr>
          <td>E</td>  <td>East/Est</td>
        </tr>
				<tr>
          <td>W</td>  <td>West</td>
        </tr>
				<tr>
          <td>O</td>  <td>Ouest</td>
        </tr>
				<tr>
          <td>NE</td>  <td>Northeast/Nord-est</td>
        </tr>
				<tr>
          <td>NW</td>  <td>Northwest</td>
        </tr>
				<tr>
          <td>NO</td>  <td>Nord-ouest</td>
        </tr>
				<tr>
          <td>SE</td>  <td>Southeast/Sud-est</td>
        </tr>
				<tr>
          <td>SW</td>  <td>Southwest</td>
        </tr>
				<tr>
          <td>SO</td>  <td>Sud-ouest</td>
        </tr>
            </table>

            <linkTarget id="linkStdDeliveryInstallationType"/>
            <div>
        <strong>
          <em>Delivery Installation Types</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
          <td>BDP</td>  <td>Bureau De Poste</td>
        </tr>
				<tr>
          <td>CC</td>  <td>Concession Commerciale</td>
        </tr>
				<tr>
          <td>CDO</td>  <td>Commercial Dealership Outlet</td>
        </tr>
				<tr>
          <td>CMC</td>  <td>Community Mail Centre</td>
        </tr>
				<tr>
          <td>CPC</td>  <td>Centre Postal Communautaire</td>
        </tr>
				<tr>
          <td>CSP</td>  <td>Comptoir Service Postal</td>
        </tr>
				<tr>
          <td>LCD</td>  <td>Letter Carrier Depot</td>
        </tr>
				<tr>
          <td>PDF</td>  <td>Poste De Facteurs</td>
        </tr>
				<tr>
          <td>PO</td>  <td>Post Office</td>
        </tr>
				<tr>
          <td>RPO</td>  <td>Retail Postal Outlet</td>
        </tr>
				<tr>
          <td>STN</td>  <td>Station</td>
        </tr>
				<tr>
          <td>SUCC</td>  <td>Succursale</td>
        </tr>
            </table>

            <linkTarget id="linkStdRouteServiceType"/>
            <div>
        <strong>
          <em>Route Service Types</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
          <td>RR</td>  <td>Rural Route</td>
        </tr>
				<tr>
          <td>SS</td>  <td>Suburban Service</td>
        </tr>
				<tr>
          <td>MR</td>  <td>Mobile Route</td>
        </tr>
				<tr>
          <td>GD</td>  <td>General Delivery</td>
        </tr>
            </table>

        </description>
    <properties>
			<property name="outAddressLine1" type="string" required="false">
	        Additional address information. Same as address line two and/or non-address data.
	        </property>
	        <property name="outAddressLine2" type="string" required="false">
	        Best possible value of delivery address. Includes point of delivery information such as civic number, street name, street type, street direction for a civic address, or delivery installation information for a Route Service, General delivery or Lock Box address.
	        </property>
	        <property name="outMunicipality" type="string" required="false">
	        Includes community/municipality or town for the address.
	        </property>
	        <property name="outProvinceCode" type="string" required="false">
	         Best possible value of province or territory for the address.
	        </property>
	        <property name="outPostalCode" type="string" required="false">
	        Best possible value of Postal Code identifier (ANANAN).
	        </property>
	        <property name="addressStatus" type="string" required="false">
			Output value of <strong>address validity status</strong>. Output value of address validity status. Indicates whether the address is valid or invalid. SERP classification (address status) is represented by single letters codes.
			</property>
	        <property name="addressLabel" type="string" required="false">
			Output value of <strong>address validity label</strong>. Output value of address validity label. Indicates whether the address is valid or invalid.
			</property>
			<property name="addressValidityLevel" type="string" required="false">
			Output value of <strong>validity level</strong> of the given address.
			</property>
	        <property name="scoAddress" type="string" required="false">
	        <strong>Data Quality Score</strong>. Value of 0 means perfect valid address (standardization only). The greater score the worse data quality of input address is.
	        </property>
	        <property name="expAddress" type="string" required="false">
	        Error or information <strong>codes</strong> explaining address status.
	        </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.components.addresses.gb.GBAddressesGenerated$OutEndPoint">
    <description>
			<LinkTarget id="linkAddressLabel"/>
			<div>
        <strong>
          <em>Address Label</em>
        </strong>
      </div>
			<table border="1">
				<th>
					<th>Value</th>
					<th>Description</th>
				</th>
				<tr>
					<td>VALID</td>
					<td>Address is correct or differs only in standardization (state name, street direction, numbers etc.).</td>
				</tr>
				<tr>
					<td>CORRECTED_MINOR</td>
					<td>Address quality is good, minor corrections performed (typos in names, missing ZIP, small differences).</td>
				</tr>
				<tr>
					<td>CORRECTED_MAJOR</td>
					<td>Address quality is poor, address components corrected (different city or several minor corrections in different address elements).</td>
				</tr>
				<tr>
					<td>UNKNOWN</td>
					<td>Address is invalid and was not parsed, or is ambiguous (unidentified to delivery point).</td>
				</tr>
				<tr>
					<td>INSUFFICIENT_INPUT</td>
					<td>Input address elements are empty or not sufficient to be identified.</td>
				</tr>
			</table>
			<LinkTarget id="linkAddressValidityLevel"/>
			<div>
        <strong>
          <em>Address Validity Level</em>
        </strong>
      </div>
			<table border="1">
				<th>
					<th>Value</th>
					<th>Description</th>
				</th>
				<tr>
					<td>DELIVERY_POINT </td>
					<td>Address identified to specific delivery point.</td>
				</tr>
				<tr>
					<td>BUILDING </td>
					<td>Address identified up to specific building, building unit is ambiguous</td>
				</tr>
				<tr>
					<td>STREET </td>
					<td>Address identified up to specific street, ambiguous house on street (box in rural route for RR addresses) </td>
				</tr>
				<tr>
					<td>CITY </td>
					<td>Address identified to city level only (ambiguous street) or addresses within rural areas. </td>
				</tr>
			</table>
			<LinkTarget id="LinkExpAddress"/>
			<div>
        <strong>
          <em>Exp Address</em>
        </strong>
      </div>
			<table border="1">
				<th>
					<th>Value</th>
					<th>Description</th>
				</th>
				<tr>
					<td>ADDRESS_DELETED</td>
					<td> Address has been deleted. Scored 0. </td>
				</tr>
				<tr>
					<td>ADDRESS_NULL</td>
					<td>No address inputted. Scored 10000.</td>
				</tr>
				<tr>
					<td>ADDRESS_UNKNOWN</td>
					<td>Address input is unknown or unable to be recognized. Scored 0.</td>
				</tr>
				<tr>
					<td>AMBIGUOUS_BUILDING</td>
					<td>Ambiguous or unrecognizable information submitted in the building field. Scored 0.</td>
				</tr>
				<tr>
					<td>AMBIGUOUS_THFARE</td>
					<td>Ambiguous or unrecognizable information submitted in the THFARE field. Scored 0.</td>
				</tr>
				<tr>
					<td>AMBIGUOUS_UNIT</td>
					<td>Ambiguous or unknown unit. Scored 5000.</td>
				</tr>
				<tr>
					<td>BUILDING_NUMBER_ADDED</td>
					<td>Building number has been added. Scored 50.</td>
				</tr>
				<tr>
					<td>BUILDING_NUMBER_APPROX</td>
					<td>Building number has been approximated. Scored 200.</td>
				</tr>
				<tr>
					<td>BUILDING_NUMBER_MISSING</td>
					<td>No building number submitted. Scored 200.</td>
				</tr>
				<tr>
					<td>BUILDING_NUMBER_DIFFERENT</td>
					<td>Building number is wrong or unrecognizable. Scored 500.</td>
				</tr>
				<tr>
					<td>BLINE_APPROX</td>
					<td>Building line approximation. Scored 50 + 10 times the LEVENSTEIN distance of the temporary building line and the lookups for organization,building and building name. </td>
				</tr>
				<tr>
					<td>BLINE_DIFFERENT</td>
					<td>Building line is different. Scored 100 + 25 times the symmetric difference of building line and the lookups for building name, sub building and organization. </td>
				</tr>
				<tr>
					<td>BLINE_MISSING</td>
					<td>Building line is missing. Scored 50 times the word count of the lookups for organization, sub building and building name. </td>
				</tr>
				<tr>
					<td>BLINE_ADDED</td>
					<td>Building line has been added. Scored 50 times the word count of building line.</td>
				</tr>
				<tr>
					<td>DEC_CO</td>
					<td>DEC_CO. Scored 0.</td>
				</tr>
				<tr>
					<td>HAD_NR</td>
					<td>HAD_NR. Scored 0.</td>
				</tr>
				<tr>
					<td>INCODE_APPROX</td>
					<td> In code has been approximated. Scored 0. </td>
				</tr>
				<tr>
					<td>INCODE_DIFFERENT</td>
					<td>In code is different from the ones in the database. Scored 10 000.</td>
				</tr>
				<tr>
					<td>INCODE_MISSING</td>
					<td>In code is missing. Scored 0.</td>
				</tr>
				<tr>
					<td>LOCALITY_APPROX</td>
					<td>Locality has been approximated. Scored 0.</td>
				</tr>
				<tr>
					<td>LOCALITY_DIFFERENT</td>
					<td>Locality is different from the ones in the database. Scored 10 000.</td>
				</tr>
				<tr>
					<td>LOCALITY_MISSING</td>
					<td>Locality is missing. Scored 0.</td>
				</tr>
				<tr>
					<td>OUTCODE_APPROX</td>
					<td>Out code has been approximated. Scored 0.</td>
				</tr>
				<tr>
					<td>OUTCODE_DIFFERENT</td>
					<td>Out code is different from the ones in the database. Scored 10 000.</td>
				</tr>
				<tr>
					<td>OUTCODE_MISSING</td>
					<td> Out code is missing. Scored 0. </td>
				</tr>
				<tr>
					<td>PLACE_ENRICH</td>
					<td>Address has been enriched. Scored 0.</td>
				</tr>
				<tr>
					<td>POBOX_APPROX</td>
					<td>Post box has been approximated. Scored 0.</td>
				</tr>
				<tr>
					<td>POBOX_DIFFERENT</td>
					<td>Post box number is different from the database. Scored 10 000.</td>
				</tr>
				<tr>
					<td>POBOX_MISSING</td>
					<td>Post box is missing. Scored 0.</td>
				</tr>
				<tr>
					<td>POSTCODE_APPROX</td>
					<td>Post code has been approximated. Scored 0.</td>
				</tr>
				<tr>
					<td>POSTCODE_CONGRUENT</td>
					<td>Post code congruent. Scored 0.</td>
				</tr>
				<tr>
					<td>POSTCODE_CORRECTED</td>
					<td>Corrections were applied to the post code. Scored 25.</td>
				</tr>
				<tr>
					<td>POSTCODE_DECODED</td>
					<td>Postcode successfully decoded. Scored 5.</td>
				</tr>
				<tr>
					<td>POSTCODE_DIFFERENT</td>
					<td>Postcode not found in database. Scored 10 000.</td>
				</tr>
				<tr>
					<td>POSTCODE_EXTRACTED</td>
					<td>Postcode successfully recognized. Scored 0.</td>
				</tr>
				<tr>
					<td>POSTCODE_MISSING</td>
					<td>Postcode has been submitted but it was not found in the database. Scored 100.</td>
				</tr>
				<tr>
					<td>POSTCODE_NULL</td>
					<td>No postcode submitted. Scored 50.</td>
				</tr>
				<tr>
					<td>POSTCODE_TRANSLITERATE</td>
					<td>Post code has been transliterated. Scored 0.</td>
				</tr>
				<tr>
					<td>POSTCODE_WRONG</td>
					<td>Wrong postcode has been inputted. Scored 50.</td>
				</tr>
				<tr>
					<td>POSTTOWN_APPROX</td>
					<td>Post town has been approximated. Scored 0.</td>
				</tr>
				<tr>
					<td>POSTTOWN_DIFFERENT</td>
					<td>Posttown is different from the database. Scored 10 000.</td>
				</tr>
				<tr>
					<td>POSTTOWN_MISSING</td>
					<td>Posttown is not submitted or now found in the database. Scored 200.</td>
				</tr>
				<tr>
					<td>THDESC_ADDED</td>
					<td>THDESC has been added. Scored 100.</td>
				</tr>
				<tr>
					<td>THDESC_CORRECTED</td>
					<td>THDESC has been corrected. Scored 50.</td>
				</tr>
				<tr>
					<td>THDESC_DIFFERENT</td>
					<td>ESC is different from the database. Scored 200.</td>
				</tr>
				<tr>
					<td>THDESC_MISSING</td>
					<td>THDESC is missing. Scored 50.</td>
				</tr>
				<tr>
					<td>THFARE_CORRECTED_DEP</td>
					<td>THFARE has been corrected. Scored 100.</td>
				</tr>
				<tr>
					<td>THNAME_ADDED</td>
					<td>THNAME has been added. Scored 200.</td>
				</tr>
				<tr>
					<td>THNAME_APPROX</td>
					<td>THNAME has been approximated. Scored 10.</td>
				</tr>
				<tr>
					<td>THNAME_APPROX_WORD</td>
					<td>THNAME has been approximated to a single word. Scored 200.</td>
				</tr>
				<tr>
					<td>THNAME_DIFFERENT</td>
					<td>THNAME is different from the database. Scored 200.</td>
				</tr>
				<tr>
					<td>THNAME_MISSING</td>
					<td>THNAME is missing. Scored 50.</td>
				</tr>
				<tr>
					<td>TH_DIFFERENT</td>
					<td>TH_DIFFERENT is different from the database. Scored 500.</td>
				</tr>
			</table>
			<LinkTarget id="LinkScoAddress"/>
			<div>
        <strong>
          <em>Score Address</em>
        </strong>
      </div>
			<table border="1">
				<th>
					<th>Value</th>
					<th>Description</th>
				</th>
				<tr>
					<td>0</td>
					<td>Valid value. No modification was done to the input value.</td>
        </tr>
				<tr>
					<td>0 to 400</td>
					<td>Corrected value - corrected minor. Small modification was done to the input value (special places removed), but resulting value is still valid and verified. </td>
        </tr>
				<tr>
					<td>400 to 1000</td>
					<td>Corrected value - corrected major. Large modification was done to the input value. Resulting value is unsafe but still verified. </td>
        </tr>
				<tr>
					<td>5000</td>
					<td>Invalid value. If address_validity_level is &quot;BUILDING&quot; or &quot;STREET&quot;</td>
        </tr>
				<tr>
					<td>10000</td>
					<td>Unknown value. Input value is null or has wrong structure. Address was not identified.</td>
				</tr>
			</table>
		</description>
    <properties>
			<property name="out_building" type="string" required="false">Best existing value of building</property>
			<property name="out_thfare" type="string" required="false">Best existing value of thfare</property>
			<property name="out_locality" type="string" required="false">Best existing value of locality</property>
			<property name="out_post_town" type="string" required="false">Best existing value of post town</property>
			<property name="out_postcode" type="string" required="false">Best existing value of postcode</property>
			<property name="out_county" type="string" required="false">Best existing value of county</property>
			<property name="out_district" type="string" required="false">Best existing value of district</property>
			<property name="out_dps" type="string" required="false">Best existing value of DPS</property>
			<property name="out_udprn" type="string" required="false">Best existing value of UDPRN (Unique Delivery Point Reference Number)</property>
			<property name="address_label" type="string" required="false">Output value of address validity label. Indicates whether the address is valid or invalid. </property>
			<property name="address_validity_level" type="string" required="false">Output value of validation level of the given address</property>
			<property name="sco_address" type="integer" required="false">Data quality score for whole address</property>
			<property name="exp_address" type="string" required="false">Explanation codes of data quality problems in whole address</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.components.addresses.us.USAddressesGenerated$OutEndPoint">
    <description>
            <linkTarget id="linkAddressValidityLevel"/>
            <div>
        <strong>
          <em>Address Validity Levels</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
          <td>DELIVERY_POINT</td>  <td>Address identified to specific delivery point (house, unit, POBOX etc.) </td>
        </tr> 
				<tr>
          <td>BUILDING</td>  <td>Address identified up to specific building, building unit is ambiguous </td>
        </tr>  
				<tr>
          <td>STREET</td>  <td>Address identified up to specific street, ambiguous house on street (box in rural route for RR addresses) </td>
        </tr>   
				<tr>
          <td>CITY</td>  <td>Only city identified (ambiguous street)</td>
        </tr>  
				<tr>
          <td>COUNTRY</td>  <td>Invalid address, parsing failed </td>
        </tr>  
            </table>
            
             <linkTarget id="linkAddressLabel"/>
            <div>
        <strong>
          <em>Address Labels</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>                 
				<tr>
          <td>VALID</td>  <td>Address is correct or differs only in standardization (state name, street direction etc.) </td>
        </tr> 
				<tr>
          <td>CORRECTED_MINOR</td>  <td>Address quality is good, minor corrections performed (typos in names, small differences etc.) </td>
        </tr> 
				<tr>
          <td>CORRECTED_MAJOR</td>  <td>Address quality is poor, address components corrected (different city or several minor corrections in different address elements)</td>
        </tr> 
				<tr>
          <td>UNKNOWN</td>  <td>Address is invalid and was not parsed, or is ambiguous (unidentified to delivery point) </td>
        </tr> 
				<tr>
          <td>INSUFFICIENT_INPUT</td>  <td>Input address elements are empty or not sufficient to be identified. </td>
        </tr> 
			</table>
           
            
            <linkTarget id="linkExpAddress"/>
            <div>
        <strong>
          <em>Explanation Codes</em>
        </strong>
      </div>
            <table border="1">
                <th>
          <th>Value</th>
          <th>Description</th>
        </th>
                <tr>
                     <td>AMBIGUOUS_BUILDING</td>
                     <td>Scored 10 000. Invalid (unrecognizable) street number</td>
                  </tr>
                  <tr>
                     <td>AMBIGUOUS_CITY</td>
                     <td>Scored 10 000 000. Invalid (unrecognizable) city</td>
                  </tr>
                  <tr>
                     <td>AMBIGUOUS_GD</td>
                     <td>Scored 10 000 000. Invalid (unrecognizable) general delivery address </td>
                  </tr>
                  <tr>
                     <td>AMBIGUOUS_POBOX</td>
                     <td>Scored 10 000 000. Invalid (unrecognizable) PO Box address</td>
                  </tr>
                  <tr>
                     <td>AMBIGUOUS_ROUTE</td>
                     <td>Scored 10 000 000. Invalid (unrecognizable) Rural route address</td>
                  </tr>
                  <tr>
                     <td>AMBIGUOUS_RRBOX</td>
                     <td>Scored 10 000. Rural route box number is invalid (Either there is some value on input but according to etalon there should be none or the other way around)</td>
                  </tr>
                  <tr>
                     <td>AMBIGUOUS_STREET</td>
                     <td>Scored 10 000 000. Invalid (unrecognizable) street</td>
                  </tr>
                  <tr>
                     <td>AMBIGUOUS_UNIT</td>
                     <td>Scored 10 000. Invalid (unrecognizable) unit</td>
                  </tr>
                  <tr>
                     <td>BOX_OUTSIDE_RANGE</td>
                     <td>Scored 50. PO Box number is outside the number range defined in etalon</td>
                  </tr>
                  <tr>
                     <td>BOX_OUTSIDE_SINGLE</td>
                     <td>Scored 50. PO Box number is different from etalon value</td>
                  </tr>
                  <tr>
                     <td>BOX_TYPO_SINGLE</td>
                     <td>Scored 5. PO Box number is slightly different from etalon value. The values differ only in letters (e.g. D1234 in etalon and 1234 on input)</td>
                  </tr>
                  <tr>
                     <td>CITY_APPROX</td>
                     <td>Scored 5. Cleansed value of city is similar with certain proximity to the value of city in etalon but not exactly the same. Approximation limit is max 2 differencies for GD, RR and POBOX addresses (with relative difference max 0.3 which means that to accept 2 differencies the etalon value of the city must have at least 6 characters) and 3 differencies for standard addresses (with relative difference 0.25).</td>
                  </tr>
                  <tr>
                     <td>CITY_DIFFERENT</td>
                     <td>Scored 50. Cleansed value of city is different from proposed value of city in etalon</td>
                  </tr>
                  <tr>
                     <td>CITY_MISSING</td>
                     <td>Scored 5. Cleansed value of city is empty but proposed value of city from etalon is not</td>
                  </tr>
                  <tr>
                     <td>CITY_PREFERRED</td>
                     <td>Not scored. Cleansed value of city was replaced to the preferred value of the city name.</td>
                  </tr>
                  <tr>
                     <td>NAME_CHANGED_NUMBER</td>
                     <td>Not scored. Cardinal and ordinal numbers within street name represented as words were transformed  into ordinal digits (TWO-&gt;2ND)</td>
                  </tr>
                  <tr>
                     <td>POBOX_IDENTIFIER_CORRECTED</td>
                     <td>Scored 1. PO box identifier was corrected to fit the standardized value in etalon.</td>
                  </tr>
                  <tr>
                     <td>POBOX_STREET_ADDRESS</td>
                     <td>Not Scored. PO BOX Street address line included in the output but street address is not validated.</td>
                  </tr>
                  <tr>
                     <td>ROUTE_IDENTIFIER_CORRECTED</td>
                     <td>Scored 1. Route identifier was corrected to fit the standardized value in etalon.</td>
                  </tr>
                  <tr>
                     <td>ROUTE_NUMBER_DIFFERENT</td>
                     <td>Scored 50. Route number has a different value from the one defined by etalon.</td>
                  </tr>
                  <tr>
                     <td>ROUTE_NUMBER_MISSING</td>
                     <td>Scored 10. Route number is missing.</td>
                  </tr>
                  <tr>
                     <td>ROUTE_TYPE_DIFFERENT</td>
                     <td>Scored 10. Route type has a different value from the one defined by etalon.</td>
                  </tr>
                  <tr>
                     <td>ROUTE_TYPE_MISSING</td>
                     <td>Scored 5. Route type is missing.</td>
                  </tr>
                  <tr>
                     <td>RRBOX_IDENTIFIER_CORRECTED</td>
                     <td>Scored 1. Rural route box identifier was corrected according to the standardized value &quot;BOX&quot;</td>
                  </tr>
                  <tr>
                     <td>RRBOX_IDENTIFIER_MISSING</td>
                     <td>Scored 1. Rural route box identifier is missing.</td>
                  </tr>
                  <tr>
                     <td>RRBOX_NO_INVALID</td>
                     <td>Scored 5. Rural route box number is invalid (not found in etalon)</td>
                  </tr>
                  <tr>
                     <td>RRBOX_NO_MISSING</td>
                     <td>Scored 5. Rural route box number is missing.</td>
                  </tr>
                  <tr>
                     <td>SN_FRACT_SURPLUS</td>
                     <td>Scored 5. Cleansed value of street number is empty and etalon value of by the given street id is a range of numbers.</td>
                  </tr>
                  <tr>
                     <td>SN_INVALID</td>
                     <td>Scored 10. Street number was not found in etalon or found as default.</td>
                  </tr>
                  <tr>
                     <td>SN_NUMBERIZED</td>
                     <td>Not scored. Street number contains digits (street line contains number indicators such as No. and numbers)</td>
                  </tr>
                  <tr>
                     <td>STATE_CORRECTED</td>
                     <td>Scored 1. Cleansed value of state was corrected using replacement etalon.</td>
                  </tr>
                  <tr>
                     <td>STATE_DIFFERENT</td>
                     <td>Scored 50. Cleansed value of state is different from proposed value of state in etalon.</td>
                  </tr>
                  <tr>
                     <td>STATE_MISSING</td>
                     <td>Scored 1. Cleansed value of state is empty but proposed value of state is not.</td>
                  </tr>
                  <tr>
                     <td>STATE_STANDARDIZED</td>
                     <td>Not scored. Cleansed value of state was standardized using replacement etalon.</td>
                  </tr>
                  <tr>
                     <td>STREET_INVALID</td>
                     <td>Not scored. Invalid (unrecognizable) street</td>
                  </tr>
                  <tr>
                     <td>STREET_NAME_APPROX</td>
                     <td>Scored 5. Cleansed value of street name is different from proposed value but approximately match the proposed value. Maximum proximity is 3 different characters (but relative distance cannot exceed value 0.25 - this means that to accept 3 differencies the etalon value of street name has to be at least 12 characters long)</td>
                  </tr>
                  <tr>
                     <td>STREET_NAME_APPROX_WORD</td>
                     <td>Scored 10. Cleansed value of street name is different from proposed value from etalon in less than 50% words.</td>
                  </tr>
                  <tr>
                     <td>STREET_NAME_DIFFERENT</td>
                     <td>Scored 50. Cleansed value of street name is different from proposed value from etalon.</td>
                  </tr>
                  <tr>
                     <td>STREET_NAME_MISSING</td>
                     <td>Scored 10.Cleansed value of street name is empty but proposed value from etalon is not.</td>
                  </tr>
                  <tr>
                     <td>STREET_POST_ADDED</td>
                     <td>Scored 5. Proposed value of cardinal direction after street name is not null and proposed value from etalon is empty.</td>
                  </tr>
                  <tr>
                     <td>STREET_POST_CORRECTED</td>
                     <td>Scored 1. Cardinal direction at the end of street name was corrected using replacement etalon</td>
                  </tr>
                  <tr>
                     <td>STREET_POST_DIFFERENT</td>
                     <td>Scored 10. Cleansed value of cardinal direction after street name is different from proposed etalon value.</td>
                  </tr>
                  <tr>
                     <td>STREET_POST_MISSING</td>
                     <td>Scored 5. Cleansed value of cardinal direction after street name is empty but proposed value from etalon is not.</td>
                  </tr>
                  <tr>
                     <td>STREET_POST_STD</td>
                     <td>Not scored. Cardinal direction at the end of street name was standardized using replacement etalon</td>
                  </tr>
                  <tr>
                     <td>STREET_PRE_ADDED</td>
                     <td>Scored 5. Proposed value of cardinal direction before street name is not null and proposed value from etalon is empty.</td>
                  </tr>
                  <tr>
                     <td>STREET_PRE_CORRECTED</td>
                     <td>Scored 1. Cardinal direction at the beginning of street name was corrected using replacement etalon</td>
                  </tr>
                  <tr>
                     <td>STREET_PRE_DIFFERENT</td>
                     <td>Scored 10. Cleansed value of cardinal direction before street name is different from proposed etalon value.</td>
                  </tr>
                  <tr>
                     <td>STREET_PRE_MISSING</td>
                     <td>Scored 5. Cleansed value of cardinal direction before street name is empty but proposed value from etalon is not.</td>
                  </tr>
                  <tr>
                     <td>STREET_PRE_STD</td>
                     <td>Not scored. Cardinal direction at the beginning of street name was standardized using replacement etalon</td>
                  </tr>
                  <tr>
                     <td>STREET_TYPE_ADDED</td>
                     <td>Scored 1. Proposed value of street type from etalon is empty but cleansed value is not.</td>
                  </tr>
                  <tr>
                     <td>STREET_TYPE_DIFFERENT</td>
                     <td>Scored 10.Cleansed value of street tyep is different from the value in etalon.</td>
                  </tr>
                  <tr>
                     <td>STREET_TYPE_MISSING</td>
                     <td>Scored 1. Cleansed value of street type is empty but the proposed value from etalon verification is not.</td>
                  </tr>
                  <tr>
                     <td>TYPE_STRIPPED</td>
                     <td>Not scored. Street type found in etalon</td>
                  </tr>
                  <tr>
                     <td>UN_INVALID</td>
                     <td>Scored 10. Unit is found in etalon with default units or not found at all </td>
                  </tr>
                  <tr>
                     <td>UN_MISSING</td>
                     <td>Scored 5. Cleansed value of unit is null</td>
                  </tr>
                  <tr>
                     <td>UN_STD</td>
                     <td>Not scored. Unit was numberized - word to number</td>
                  </tr>
                  <tr>
                     <td>UN_SURPLUS</td>
                     <td>Scored 1. Building was not accurately identified (building id is null) but 4-digit additional zip code can be identified.</td>
                  </tr>
                  <tr>
                     <td>UNIT_DESIGNATOR_CORRECTED</td>
                     <td>Scored 1. Cleansed value of unit designator has is different from the value in etalon. It was set to the etalon value.</td>
                  </tr>
                  <tr>
                     <td>UNIT_DESIGNATOR_MISSING</td>
                     <td>Scored 1. Cleansed value of unit designator is null but etalon value is filled</td>
                  </tr>
                  <tr>
                     <td>UNIT_DESIGNATOR_STANDARDIZED</td>
                     <td>Not scored. Cleansed value of unit designator standardized using replacement etalon</td>
                  </tr>
                  <tr>
                     <td>UNIT_DESIGNATOR_SURPLUS</td>
                     <td>Scored 1. Cleansed value of unit designator is not null but was not found in etalon</td>
                  </tr>
                  <tr>
                     <td>ZIP_DECODED</td>
                     <td>Scored 1. Zip code contained unsupported characters</td>
                  </tr>
                  <tr>
                     <td>ZIP_EXTRACTED</td>
                     <td>Scored 1. Zip code was extracted from concatenated address lines</td>
                  </tr>
                  <tr>
                     <td>ZIP_INVALID</td>
                     <td>Scored 5. Zip code is invalid</td>
                  </tr>
                  <tr>
                     <td>ZIP_NULL</td>
                     <td>Scored 5. Zip code is missing</td>
                  </tr>
                  <tr>
                     <td>ZIP_TRANSLITERATED</td>
                     <td>Scored 1. Zip code was modified by transliterating letters (any Case) &quot;i&quot; and &quot;o&quot; to numbers 1 and 0.</td>
                  </tr>
                  <tr>
                     <td>ZIP4_CORRECTED</td>
                     <td>Scored 1. 4-digit additional zip code has a different value from the one defined by etalon and was set to the etalon value.</td>
                  </tr>
                  <tr>
                     <td>ZIP4_DEFAULT_RR</td>
                     <td>Not scored. Rural route number was found in etalon with default numbers.</td>
                  </tr>
                  <tr>
                     <td>ZIP4_DIFFERENT</td>
                     <td>Scored 1. 4-digit additional zip code has a different value from the one defined by etalon.</td>
                  </tr>
                  <tr>
                     <td>ZIP4_INVALID</td>
                     <td>Scored 1. Cleansed value of zip code does not contain additional 4-digit zip code but only the basic 5 (or even only four) followed by several trash characters (anything else than 4 digits) delimited from the basic part by hyphen.</td>
                  </tr>
                  <tr>
                     <td>ZIP4_MISSING</td>
                     <td>Not scored. Cleansed and parsed value of 4-digit addition to zip code is empty (only on condition that zip code pattern is different from &quot;5-digit zip code with following thrash characters (anything else than 4 digits) without any delimiter before thrash&quot;)</td>
                  </tr>
                  <tr>
                     <td>ZIP5_CORRECTED</td>
                     <td>Scored 10. 5-digit zip code has a different value from the one defined by etalon but was found approximate and was set to the etalon value. Maximum approximation is 1 different character for POBOX (relative difference max 0.21) and RR (relative difference max 0.3) addresses , max 2 differencies for standard addresses (relative difference 0.4). There is zero tolerance for GD addresses.</td>
                  </tr>
                  <tr>
                     <td>ZIP5_DIFFERENT</td>
                     <td>Scored 50. Cleansed value of 5-digit zip code is different form proposed value of zip code in etalon.</td>
                  </tr>
                  <tr>
                     <td>ZIP5_MISSING</td>
                     <td>Scored 10. Cleansed value of 5-digit zip code is empty but proposed value from etalon is not.</td>
                  </tr>
              	  <tr>
                     <td>ZIP+4_ONLY_VALIDATED</td>
                     <td>Not scored. Only ZIP+4 part(9 digits) is validated.</td>
                  </tr>
                  <tr>
                     <td>ZSC_INVALID</td>
                     <td>Not scored. Not even combination of zip code, state and city is valid and could not be identified</td>
                  </tr>
                  <tr>
                     <td>UNPARSED_DATA_FOUND</td>
                     <td>Scored 10000. Some parts of street address line were not parsed\identified. Unparsed data can be found Additional Info attribute.</td>
                  </tr>
                  <tr>
                     <td>STREET_ADDRESS_PMB</td>
                     <td>Scored 10000. Street line includes PMB number, however only the street address is validated, PMB Addresses aren&#39;t among supported address types.</td>
                  </tr>
                  <tr>
                     <td>POBOX_INFO_SPLIT</td>
                     <td>Scored 1. Unit designator and number information was not separated on the input. Data was split\corrected to ensure proper parsing of the address (e.g. APT8 into APT 8)</td>
                  </tr>
                  <tr>
                     <td>UNIT_INFO_SPLIT</td>
                     <td>Scored 1. PO BOX information was not separated on the input. Data was split\corrected to ensure proper parsing of the address (e.g. BOX23 into BOX 23)</td>
                  </tr>
            </table>

            
        </description>
    <properties>
			<property name="outOut_street" type="string" required="false">
			Column that stores street in best possible output as compared to USPS database.
			In case of successfully parsed and validated addresses - HOUSE_NUMBER STREET_PRE_DIRECTION STREET_NAME STREET_TYPE STREET_POST_DIRECTION UNIT_TYPE UNIT_NUMBER.
			In case of invalid addresses - standardized input or plain input depending on quality of input.
			</property>
			<property name="outOut_city" type="string" required="false">
			Column that stores identified city, either validated or parsed.
			</property>
			<property name="outOut_county" type="string" required="false">
			Column that stores identified county, either validated or parsed.
			</property>
			<property name="outOut_state" type="string" required="false">
			Column that stores identified state abbreviation, either validated or parsed.
			</property>
			<property name="outOut_zip" type="string" required="false">
			Column that stores ZIP. ZIP+4 for address identified to delivery point, ZIP5 for ambiguous or partially identified address.			
			</property>
			<property name="outAddress_label" type="string" required="false">
			Output value of <strong>address validity label</strong>. Output value of address validity label. Indicates whether the address is valid or invalid.
			</property>
			<property name="outAddress_validity_level" type="string" required="false">
			Output value of <strong>validity level</strong> of the given address.	
			</property>
			<property name="outSco_address" type="string" required="false">
			Data quality score for whole address.
			</property>
			<property name="outExp_address" type="string" required="false">
			Error or information <strong>codes</strong> explaining address status.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.nme.dqc.steps.MdcStepBase$OutputColumn">
    <properties>
            <property name="name" type="string" required="true">
                Column name in MDM model.
                Columns present in the flow will be filled by the MDM search results, i.e. any previous values will be lost.
                Columns not present in the flow will be automatically added and filled.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.unify.ExtendedUnify$OutputScope"/>
  <class name="com.ataccama.dqc.unify.ExtendedUnify$OutputStrategy">
    <properties>
			<property name="exportUnchanged" type="boolean" required="true">
				Changed records are all records from input, including deletions.
				Records expanded from repository may or need not have changed
				some unify attribute (group id, unification role) during unify operations.
				This switch specifies that expanded but unchanged records will be sent to
				output, too. When true, whole candidate group will be sent to output
				and <code>Scope</code> and <code>Group By Column</code> properties are irrelevant.
				<br/>Default value: True.
			</property>
			<property name="exportDiscarded" type="boolean" required="true">
				Send discarded records to the output. Discarded records are:
				<ul>
					<li>Records with an empty or duplicate primary key</li>
					<li>Records with a timestamp that is older than the repository</li>
				</ul>
				Default value: False.
			</property>
			<property name="scope" type="com.ataccama.dqc.unify.ExtendedUnify$OutputScope" required="false">
				Specifies which changed record unit this strategy applies to.
				Has meaning only if <code>Export Unchanged</code> property is false.
			</property>
			<property name="groupByColumn" type="string" required="false">
				When <code>Export Unchanged</code> is false and ENTIRE_GROUPS scope is selected,
				this property specifies grouping column
				(usually candidate or matching id) that determines the groups.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.base.KeyValueMapping$Parameter">
    <description>Set of user defined parameters.</description>
    <properties>
			<property name="expression" type="string" required="true">Expression evaluating the value of the parameter.</property>
			<property name="name" type="string" required="true">Name of the parameter.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.nme.ext.workflow.ParameterDef">
    <description>Set of parameters to pass to the batch operations. These can be used as component parameters, path variable definitions, or elements in more complex parameter definitions.</description>
    <properties>
            <property name="name" type="string" required="true">Name of the parameter as defined in the plan.</property>
            <property name="value" type="string" required="true">Value of the parameter.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.html.ParameterDefinition">
    <introduction>Defines the POST parameter to be sent with the HTTP
			query. Note that some pages may
			require posting of some special
			values. To determine the required properties
			consult the individual
			page (technology) requirements.
		</introduction>
    <properties>
			<property name="name" type="string" required="true">
				Defines the
				property&#39;s name.
			</property>
			<property name="value" type="string" required="false">
				Defines the value of the property. It is processed the same way as
				<code>Url Pattern</code>
				so it may contain bindings to the input record format values.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.base.Mapping$ParameterMapping">
    <description>Defines set of the output parameters to be read from the query. Applicable when calling stored procedures.</description>
    <properties>
			<property name="name" type="string" required="true">Defines the name of the mapping. Value read from the mapping will be available under this name in the condition and saved in the task&#39;s variables.</property>
			<property name="type" type="com.ataccama.dqc.expressions.model.data.DataType" required="true">Defines how to read the value from the statement. Currently supported types are: STRING, INTEGER, LONG, DAY, DATETIME, BOOLEAN.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.io.gdr.reader.member.StructuredMemberBase" name="com.ataccama.dqc.tasks.io.gdr.reader.member.ParameterizedIteration">
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.config.EwfExecutionWorkflow">
    <introduction>Parameters</introduction>
    <description>Parameters</description>
    <properties>
			<property name="description" type="string" required="false">
			Arbitrary description of the workflow, e.g., of its purpose.
			</property>
			<property name="name" type="string" required="false">
			Human-friendly name of the workflow.
			</property>
			<property name="multiplicity" type="integer" required="true">
			Multiplicity. Defines the maximum number of simultaneously running instances of this workflow. If 0 is defined or multiplicity is not defined, the number of instances of a given workflow is not limited. The default value is 0. See Workflow Resource Management for more information.
			</property>
			<property name="continueOnFailure" type="string" required="true">
			Continue on failure. Defines whether the workflow supports error endpoints. If unchecked, the workflow is stopped immediately after any of the tasks fails.
			</property>
			<property name="role" type="string" required="false">
			Defines the role that is required to run the workflow. If undefined, anyone can run the workflow.
			</property>
			<property name="finalState" type="string" required="false">
			Final state expression.
			</property>
			<property name="variables" type="com.ataccama.adt.config.EwfVariables" required="false">
			This is where you set up <strong>Input</strong> and <strong>Derived</strong> variables for the workflow.
			</property>
			<property name="groups" type="com.ataccama.adt.config.EwfGroup[]" required="false">
			Groups are used by visualizers to display similar tasks together in the same &quot;group.&quot;
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.parquet.reader.ParquetFileReaderAlgorithm">
    <introduction>Reads a file in <a href="https://parquet.apache.org/" target="_blank">Parquet format</a> and outputs its content into multiple streams of data.</introduction>
    <description>
			The step can create several output streams from one Parquet file where rows of one stream can be
			logically children to rows in another stream. E. g. if a file contains client records
			with each client having several addresses, it can be read as a stream of clients
			and a separate stream of addresses of all clients.
			The streams can also be independent.
		</description>
    <properties>
			<property name="fileName" type="string" required="true">
				The input file.
			</property>
			<property name="dataStreams" type="com.ataccama.dqc.tasks.hadoop.io.parquet.reader.ParquetStreamConfig[]" required="true">
				Output end points defined on the root level.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.parquet.writer.ParquetFileWriter">
    <introduction>Writes data into a file using <a href="https://parquet.apache.org/" target="_blank">Parquet format</a>.</introduction>
    <description>
			<p align="justify">The data output for this step is a file in <a href="https://parquet.apache.org/" target="_blank">Parquet format</a>.</p>
			<p align="justify">Along with a new parquet file, file for verifying the data integrity is generated (with suffix .crc ).</p>
		</description>
    <properties>
			<property name="fileName" type="string" required="true">
				The output file.
			</property>
			<property name="compression" type="com.ataccama.dqc.tasks.hadoop.io.parquet.EParquetCompression" required="true">
				Defines compression type of the output file.<br/>
				Default value: NONE.
			</property>
			<property name="blockSize" type="integer" required="true">
				The block size (in kilobytes) is the size of a row group being buffered in memory. <br/>
				Larger values will improve the IO when reading but consume more memory when writing.
			</property>
			<property name="pageSize" type="integer" required="true">
				The page size (in kilobytes) is for compression. When reading, each page can be decompressed independently. <br/>
				A block is composed of pages. The page is the smallest unit that must be read fully to access a single record.<br/>
				If this value is too small, the compression will deteriorate
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="true">
                Definition of columns (corresponding by order, names and types).
            </property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.parquet.reader.ParquetStreamConfig">
    <description>A single stream of data with one output endpoint.</description>
    <properties>
			<property name="name" type="string" required="true">
				The name of this stream and its associated output endpoint.
			</property>
			<property name="path" type="string" required="true">
				The path to the elements that are to be read by this stream. Structure of the path is based on dot notation, root stream is am empty string,
				current element is accessed by &quot;@&quot;. If this is a sub-stream of another stream, then
				the path is relative to the path of the parent stream. Path containing the dot character (&quot;.&quot;) must be surrounded with
				quotation marks (e.g.: &quot;sub.stream&quot;)
			</property>
			<property name="parentIdColumn" type="string" required="false">
			 	Expression evaluating unique id of the parent record. The id is used as part of <code>Record Descriptor</code>
			 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
			 	is used as dot-source name referring to parent record columns.
			 	Inapplicable at the top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
			 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
			 	at non-top level only and when <code>Parent Id Column</code> is defined.
		 	</property>
			<property name="dataStreams" type="com.ataccama.dqc.tasks.hadoop.io.parquet.reader.ParquetStreamConfig[]" required="false">
				The substreams of this stream. They will produce records that are logically children of the records of this parent stream.
			</property>
			<property name="attributes" type="com.ataccama.dqc.tasks.hadoop.io.parquet.reader.Attribute[]" required="true">
				The attributes of this stream - columns of the associated output mapped to fields of Parquet format.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.abp.parser.configuration.ParserConfig">
    <description>

		</description>
    <properties>
			<property name="components" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.Component[]" required="false">
				Definition of user components that can be used in patterns.
			</property>
			<property name="patternGroups" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.PatternGroup[]" required="false">
				Definition of pattern groups.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.mdu.MduPartition">
    <description>
       	Partitions allow user to split the input records into different groups of records which shouldn&#39;t be matched together. Typically for splitting a Party entity into records representing persons and companies.
       </description>
    <properties>
          <property name="rules" type="com.ataccama.mdu.MduKeyRule[]" required="true">List of Matching Rules.</property>
          <property name="keeperSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">Criterion for selecting of &quot;id keeper record&quot; for this partition.</property>
          <property name="when" type="string" required="false">Column containing values used to split input data into partitions. A boolean value is returned; only records belonging to the same partition will be matched together.
<br/>
 Default value: true. </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.PartitionColumn">
    <properties>
			<property name="name" type="string" required="true">Column Name</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.communication.auth.server.IPasswordBasedIdentityProvider">
    <properties/>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.IServerAuthenticationMethod" name="com.ataccama.dqc.communication.auth.server.PasswordServerMethod">
    <introduction>Returns the identity according to the username and password extracted from the request.</introduction>
    <description>Returns the identity according to the username and password extracted from the request. The definition of the identity (defined by usernames, passwords and roles) and the IP address of the client depends on the provider. Possible implementations: Ldap Identity Provider, File Based Identity Provider. 
			<p align="justify">
				This method is the recommended solution for password protection of access to the server. 
			</p>
		</description>
    <properties>
			<property name="provider" type="com.ataccama.dqc.communication.auth.server.IPasswordBasedIdentityProvider" required="false">Defines the identity (defined by usernames, passwords and roles) and the IP address of the client. Possible implementations: Ldap Identity Provider, File Based Identity Provider.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfDqcTask$PathVariableBean">
    <description>Set of local path variables to use with the current task.</description>
    <properties>
			<property name="name" type="string" required="true">Name of the path variable.</property>
			<property name="value" type="string" required="true">Value of the path variable.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.abp.parser.configuration.Pattern">
    <description>Parsing pattern which describes the structure of an input string.</description>
    <properties>
			<property name="definition" type="string" required="true">
				Parsing pattern definition.
			</property>
			<property name="name" type="string" required="true">
				Name of the parsing pattern (stored in <code>patternName</code>).
			</property>
			<property name="priority" type="integer" required="true">
				Priority of the parsing pattern. The greater the number, the higher the priority of the pattern.
				The default value for the pattern priority (when not defined) is 0. If the input string conforms to more
				than one pattern with the same priority, the first parsing pattern in the definition list is applied.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorPattern">
    <description>
			<p align="justify">Column value is randomly generated from pattern. Pattern can consist of:</p>
			<table border="1">
				<th>
					<th>Pattern token</th>
          <th>Description</th>
				</th>
				<tr>
					<td>[somechars]</td>
					<td>any character from set, with same probability (expansion via [a-z is not supported])</td>
				</tr>
				<tr>
					<td>(aa|bb|cc)</td>
					<td>any string from set, with same probability (nesting of parentheses is not supported)</td>
				</tr>
				<tr>
					<td>
            <em>token</em>?</td>
					<td>preceding token is omitted for approx. 50% generated records</td>
				</tr>
				<tr>
					<td>
            <em>token</em>{<em>integer</em>}</td>
					<td>preceding token is replicated, e.g. <code>(hi |hello){3}</code>
          </td>
				</tr>
				<tr>
					<td>
            <em>token</em>{<em>min</em>,<em>max</em>}</td>
					<td>preceding token is replicated n-times, where n is random number &gt;=min and &lt;=max</td>
				</tr>
				<tr>
          <td>[:digit:]</td>
          <td>any digit</td>
        </tr>
				<tr>
          <td>[:lower:]</td>
          <td>any lowercase letter</td>
        </tr>
				<tr>
          <td>[:upper:]</td>
          <td>any uppercase letter</td>
        </tr>
				<tr>
          <td>[:alpha:]</td>
          <td>any letter</td>
        </tr>
				<tr>
          <td>[:alnum:]</td>
          <td>any digit or letter</td>
        </tr>
			</table>
			<p align="justify">
				Standard English alphabet is used for <code>any letter</code>. Example: <code>[:alpha:][:alnum:]{2,10}@(gmail|hotmail|yahoo|aol).com</code>
			</p>
		</description>
    <properties>
			<property name="pattern" type="string" required="true">Pattern similar to limited regular expression</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.text.WordAnalyzer$Pattern">
    <description>
	The patterns can be used to normalize output patterns. The pattern definition consists of symbols defined in mlListOfValue or
	slListOfValue and are separated by spaces. The output mask is replaced by some pattern if this pattern has the same count of symbols
	as the output mask has identified words and each symbol in the pattern is contained in the token in the output mask. Words that are not found
	are ignored when looking for a pattern.
	Eg. using the following values:
	<ul>
	   <li>symbols - &quot;m&quot; and &quot;M&quot;</li>
	   <li>output mask - &quot;mM m&quot; or &quot;mM trash m&quot;</li>
	   <li>pattern - &quot;M m&quot;</li>
	</ul>
	then the output mask is replaced by the pattern because the first symbol &quot;M&quot; is contained in &quot;mM&quot; and the second symbol &quot;m&quot; is contained
	in &quot;m&quot;. If some pattern can be applied for some output mask then following patterns are ignored.
	</description>
    <properties>
	    <property name="name" type="string" required="false">
	    Name of the pattern.
	    </property>
	    <property name="definition" type="string" required="true">
	    Symbols defined in slListOfValue or mlListOfValue, separated by spaces.
	    </property>
	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.domain.PatternAnalysis">
    <description>
			Discovers that string values conform to limited number of
			patterns. The pattern for value is created in the following manner:
			<ul>
				<li>single digit is converted to letter &quot;D&quot;</li>
				<li>sequence of more digits is converted to letter &quot;N&quot;</li>
				<li>single letter is converted to character &quot;L&quot;</li>
				<li>sequence of more letters is converted to letter &quot;W&quot;</li>
				<li>sequence of whitespace characters is converted to one space</li>
				<li>control character or character not defined in unicode is converted to letter &quot;U&quot;</li>
				<li>any other characters are copied as is</li>
			</ul>
			For example: &quot;J.Smith, born 12.4.1976&quot; conforms to pattern &quot;L.W, W N.D.N&quot;.
			<br/>
			Values conforming to only trivial patterns (having only single character)
			are not assigned to this domain. For example, purely numeric values would be
			in little significant patterns &quot;N&quot; and &quot;D&quot;.
		</description>
    <properties>
			<property name="patternCountLimit" type="integer" required="true">
				Maximal number of patterns. The number of distinct patterns must not
				exceed this limit to be assumed in this domain.
				<br/>Default = 10.
			</property>
			<property name="active" type="boolean" required="true">
				Specifies whether the analysis will be performed.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.abp.parser.configuration.PatternGroup">
    <description>
			Tag which defines a group of patterns. It contains the tag <code>Patterns</code>, which associate individual
			definitions of patterns within the same group. See the example for more details.<br/>
			Dividing parsing rules into groups allows for the next level of rule prioritization. 
			The parsing engine takes each group in turn and takes all the rules from it
			and tries to match them against the input string. The parsing ends
			the moment when any rule is found or no more groups exist.
			If a group is found, it is processed without any relation to
			any other already processed group nor to any other group still to be processed.<br/>
			Structuring rules into isolated groups might thus lead to situations
			where more possible rules
			found in several groups with only one matching rule in the first matching group
			result in not setting the GP_MORE_PATTERNS flag.
		</description>
    <properties>
			<property name="patterns" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.Pattern[]" required="true">
				Tag representing the list of parsing patterns <code>pattern</code>. See the example.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.parse.PatternParserAlgorithm">
    <introduction>Parses and validates any string against a dictionary file.</introduction>
    <description>
			<p align="justify">
			This step performs parsing of the input string data based on defined parsing rules.
			It tries to find a pattern that matches the input text. If such pattern is found, its 
			definition is used to recognize individual parts (components) and store their values
			in the output.<br/>
			</p>
			<p align="justify">
			The input text is first split into tokens using the defined tokenizer. Tokens are then matched 
			against defined patterns and their components. For parsing purposes, pattern
			definitions and the input string are both pre-compiled using an identical tokenizer and 
			therefore correct (identical) construction of all components is guaranteed.<br/>
			</p>
			<p align="justify">
			Patterns consists of components. Generally there are two types of components:
			<ul>
				<li>basic components - these are components whose purpose is to recognize input chunks
				only syntactically (for example: a word must contain only letters, a number must contain 
				only digits, etc.). They do not care about the meaning of the matched text - they
				also do not provide access to the matched value.</li>
				<li>user specified components - these are components that consists of some other 
				components (typically basic ones) and the addition of other features: 
				<ul>
					<li>
                <strong>naming</strong> - the component can be named and therefore used in 
					the patterns or other custom components</li>
					<li>
                <strong>storing of matched text</strong> - it is possible to define a column 
					that the matched value should be stored in</li>
					<li>
                <strong>validation</strong> - it is possible to define a lookup file where 
					matched text should be validated against</li>
					<li>
                <strong>scoring</strong> - it is possible to score if the given component
					does not match</li>
				</ul>
				</li>
			</ul>
			</p>
			
			<div>
        <strong>
          <em>Basic components</em>
        </strong>
      </div>
			<p align="justify">			 						
				The predefined basic components are:
				<table border="1">
					<th>
            <th>Component name</th>
            <th>Description</th>
          </th>
					<tr>
            <td>LETTER</td>
            <td>A letter (no parameters available)</td>
          </tr>
					<tr>
            <td>WORD</td>
						 <td>A (single) word. Available parameters:<br/>
					<ul>
								<li>int <code>minLength</code> - minimum number of required characters (default value: 2)</li>
								<li>int <code>maxLength</code> - maximum number of required characters (default value: integer max)</li>
								<li>string <code>chars</code> - string that defines which characters the words can be composed of;
								default value: [:letter:] (see <strong>ConfigurableTokenizerConfig</strong>)
								</li>
					</ul>
					</td>
          </tr>
					<tr>
            <td>MULTIWORD</td>
						<td>A multiple word string - a string consisting of more than one word.<br/>
							Available parameters:<br/>
							<ul>
								<li>int <code>minLength</code> - minimum number of required characters (default value: 2)</li>
								<li>int <code>maxLength</code> - maximum number of required characters (default value: integer max)</li>
								<li>string <code>chars</code> - see WORD</li>
								<li>string <code>wordSeparators</code>
									A string that defines characters that are considered to be acceptable word delimiters (separators).
									It is not necessary to define a space as a separator; it is automatically considered as a delimiter.
									The default value is an empty string.
								</li>
							</ul>
							<code>MULTIWORD</code> accepts various numbers of input tokens, depending 
							on the verifier and the pattern where it is used:
							<ul>
								<li>
									If a verifier is specified, then <code>MULTIWORD</code> accepts as many words 
									as possible until:
									<ul>
										<li>the whole read string is present in multi-word lookup, or</li> 
										<li>each read chunk is present in single-word lookup</li>
									</ul>
								</li>
								<li>
									If a verifier is not specified:<br/>
									then the number of words read from the input depends on the pattern where 
									<code>MULTIWORD</code> is used. <code>MULTIWORD</code> will then contain 
									as many words as possible according to the rest of the pattern.
								</li>
							</ul>
							See the <strong>detailed multiword description here</strong> 
							to find more information about this topic.<br/>
							<p align="justify">
							The main purpose and advantage of the <code>MULTIWORD</code> component over a 
							set of <code>WORD</code> components is its flexibility. Contrary to a set of 
							<code>WORD</code> components that matches only exactly the same number of 
							input tokens, the <code>MULTIWORD</code> component allows you to read 
							various numbers of input words depending on the given verifier or 
							pattern.
							</p>
							<p align="justify">
							Known limitations:
								<ul> 
									<li>there must not be more separators in a sequence, otherwise 
									<code>MULTIWORD</code> component will not accept the string (even it 
									is specified in lookup file)</li>
									<li>only single-character separators are supported</li>
								</ul>
							</p>
						</td>
					</tr>
					<tr>
            <td>INTERLACED_WORD</td>
						<td>Word where each character is separated by a space character.
							<ul>
								<li>string <code>chars</code> - see WORD</li>
							</ul>
						</td>
					</tr>
					<tr>
            <td>ANWORD</td>
						<td>An alphanumeric word (no parameters available).
						</td>
					</tr>
					<tr>
            <td>DIGIT</td>
						<td>A single digit (no parameters available).
						</td>
					</tr>
					<tr>
            <td>NUMBER</td>
						<td>A natural number. Available parameters:
							<ul>
								<li>boolean <code>acceptSeparators</code> - specifies whether the delimiter specified in
									<code>separatorChar</code> is acceptable between digits within a number.
									Default value: <code>false</code>
                </li>
								<li>char <code>separatorChar</code> - value which is acceptable as a delimiter
									of single digits within a number. Default value: <code>&#39; &#39;</code>
                </li>
								<li>int <code>minLength</code> - minimum number of required characters (default value: 2)</li>
								<li>int <code>maxLength</code> - maximum number of required characters (default value: integer max)</li>
							</ul>
						</td>
					</tr>
					<tr>
            <td>INTEGER</td>
						<td>Whole number. Available parameters:<br/>
							The same as in the case of <code>NUMBER</code>, with the following exceptions:
							<ul>
								<li>
                  <code>acceptSeparators</code> - default value: <code>true</code>
                </li>
								<li>operators are also acceptable ( &#39;+&#39; and &#39;-&#39;)</li>
							</ul>
						</td>
					</tr>
					<tr>
            <td>REAL_NUMBER</td>
						<td>Real number. Available parameters:
							<ul>
								<li>char <code>floatingPoint</code> - a character representing a decimal separator.
									Default value: &#39;.&#39;</li>
							</ul>
						</td>
					</tr>
					<tr>
            <td>ROMAN_NUMBER</td>
						<td>Roman number (no parameters available).
						</td>
					</tr>
					<tr>
            <td>REGEXP</td>
						<td>Regular expression. Available parameters:
							<ul>
								<li>string <code>pattern</code> - a string with a Java <code>regex.Pattern</code>
									(see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank">class Pattern</a>).
								</li>
							</ul>
						</td>
					</tr>
					<tr>
            <td>A component defined using a string.</td>
						<td>No parameters available.
						</td>
					</tr>
					<tr>
						<td>*</td>
						<td>Component accepting any text.</td>
					</tr>
				</table>
			<br/>
			</p>
			<p align="justify">
			<strong>NOTE:</strong> The components <code>NUMBER</code> and <code>WORD</code> are 
			defined by default using at least 2 digits (for NUMBER) or 2 characters (for WORD) in order
			to be distinguished from <code>DIGIT</code> or <code>LETTER</code> (which are defined using one 
			digit or character, respectively).
			</p>

			<p align="justify">
			<linkTarget id="multiwordDetailedDesc"/>
			<div>
          <strong>
            <em>MULTIWORD component - detailed information</em>
          </strong>
        </div>
			<p align="justify">
			This component reads individual tokens from the input (tokenizer&#39;s output; the tokenizer 
			preprocesses data for the parser). When reading, single character tokens (and those which 
			are equal to the one defined in the	<code>wordSeparators</code>	parameter) are considered 
			to be a part of a word.
			</p>
			<p align="justify">
			The result of this reading process (acquired words) are merged using the &#39; &#39; character. 
			This way the component reads a maximum possible number of words and then processes the 
			rest of the string against the rest of the pattern (i.e. consecutive parsing when the 
			rest of the pattern is applied). If the consecutive parsing is not	successful, the 
			component detaches the last read word and performs consecutive parsing again.
			Finally the input string is either not parsed or when the process is successful, the 
			component stores the result in the specified output column.
			</p>
			<p align="justify">
			For accepting processes, the <code>MULTIWORD</code> component can be used either with the 
			standard single word verifier or with the <code>MultiwordVerifier</code> verifier, which 
			tries to lookup the actual input in the multi-word dictionary (if defined - it is optional). 
			If the lookup is not successful, the step attempts to lookup individual words (i.e. 
			sequences of characters delimited by spaces) in the single word dictionary. If any
			of this process succeeds, the token sequence is accepted.
			</p>
			<p align="justify">
				<strong>NOTE:</strong> the <code>MULTIWORD</code> component is the only component that uses 
				the multiword-lookup identifier	&#39;Multi file name&#39; in the related 
				<strong>Verifier</strong>
			</p>
			<p align="justify">
			If a dictionary based verification is not required for the <code>MULTIWORD</code> 
			component, the first component defined this way accepts a maximum number of tokens. At 
			the same time, the rest of the components must be considered to meet pattern&#39;s 
			requirements. For example, two consecutive <code>MULTIWORD</code> components which have 
			no verification will share an input with N tokens in the following way: the first
			component reads N-1 tokens and the second reads one token only.
			</p>
			Example:<br/>
			Input string: <code>Anna-Maria o&#39;Donald</code> - the string is split by the tokenizer of the parser in the
			following way: <code>Anna</code>,<code>-</code>,<code>Maria</code>,<code> </code>,<code>o</code>,
			<code>&#39;</code>,<code>Donald</code>
        <br/>
			Using <code>wordSeparators=&quot;-&#39;&quot;</code> definition, the <code>MULTIWORD</code> component merges this
			(the tokenizer&#39;s) output into this result: <code>Anna-Maria</code>, <code>o&#39;Donald</code>
        <br/>.
			If using a multi-word dictionary, the following combination is looked up:
			<code>Anna-Maria o&#39;Donald</code>
        <br/>, in case of failure, the single-word dictionary is used and this
			combination is looked up: <code>Anna-Maria</code>,<code>o&#39;Donald</code>
        <br/>
			If case of no match, the <code>MULTIWORD</code> component detaches the last word (<code>o&#39;Donald</code>) and
			if a consecutive parsing succeeds, the test is performed again, this time with the same value
			<code>Anna-Maria</code> in the multi-word dictionary and subsequently in the single-word dictionary.<br/>
			</p>
			
			<div>
        <strong>
          <em>Pattern and component definitions</em>
        </strong>
      </div>
			<p align="justify">
			There are two ways to define a component.
			<ul>
				<li>a named component whose definition is specified in a 
					  <strong>component</strong> element.</li>
				<li>redefine a component directly within a pattern</li>
			</ul>
			</p>
			<p align="justify">
			<strong>Using a component in a pattern:</strong>
        <br/>
			The component name is enclosed by brackets: &#39;{&#39; and &#39;}&#39; within the parsing pattern 
			definition. Any other string defined outside brackets is considered literally; in the 
			parsing process, such text must be part of the parsed input string to match the parsing 
			pattern. The component usage specification is as follows:<br/>
			<code>{component_name[:name_par=value_par,name_par=value_par] [| list_of_components_defining_the_structure]}</code>
			</p>
			
			
			<div>
        <strong>
          <em>Component customization</em>
        </strong>
      </div>
			<p align="justify">
				In order to locally modify behavior of the component, you can: 
				<ul>
					<li>change values of component parameters</li>
					<li>redefine the component definition</li>
				</ul>
			</p>
			
			<p align="justify">					
			<strong>Change component parameters</strong>
        <br/>
			Setting of component behavior and properties can be performed using the component&#39;s parameters (see the table).
			Parameters are specified in the following way: parameter_name=parameter_value. The specification requires
			that the component name and parameter definition be separated by a  colon (&#39;:&#39;).<br/>
			The component parameter&#39;s value can be quoted using both single and double quotes (&#39; and &quot;). When a
			quote is intended to be part of the value, it must be escaped using the same quote (i.e. producing <code>&quot;&quot;</code>
			or <code>&#39;&#39;</code>). It is also possible to use no quotation (the parameter value is not escaped) up to
			a first &quot;,&quot; (comma), &quot;|&quot; (pipe) or &quot;}&quot; (right parenthesis). In this case, escape sequences for definition
			of the special characters (such as \t, \n, \r or \f) cannot be defined (the only possible definition is when the value is quoted).
			It is also possible to use a special definition using the @ character. When escaped by @, every character
			within escaping quotes has the explicit value (a value that has no special meaning) - e.g. definition
			of @&quot;\t&quot; means that \t is interpreted as the appropriate string (\t) and not as a tab. <br/>
			Pay special attention to coding patterns of the regular expression component (<code>REGEXP</code>), where special
			characters such as &#39;{&#39; or &#39;\&#39; are often used in the pattern, e.g. when backslash should be used in the quoted parameter,
			you have to duplicate it.<br/>
			Examples:<br/>
			<ul>
				<li>
            <code> {MULTIWORD:wordSeparators=&quot;-&#39;&amp;quot;&amp;quot;\t&quot;} </code>
					  = delimiters: dash, single quote and (one) double quote, tab</li>
				<li>
            <code>{MULTIWORD:wordSeparators=@&quot;-&#39;.\t&quot;}</code>
					  = delimiters: dash, single quote, dot, backslash, character &#39;t&#39;</li>
				<li>
            <code>{WORD:minLength=2}</code>
          </li>
				<li>
            <code>{REGEXP:pattern=&quot;[a-zA-Z\\\\]\\d*\\.\\d{1,2}&quot;}</code>
				      = letter or backslash followed by digits, dot and 1-2 digits</li>
				<li>
            <code>{REGEXP:pattern=@&quot;[a-zA-Z\\]\d*\.\d{1,2}&quot;}</code>
				      = the same pattern as above without necessary double escaping</li>
			</ul>
			<br/>
			For some parameters a special acronym can be used. An acronym definition must follow the
			parameter&#39;s name (before the separating colon). Currently only one acronym is available : &quot;!&quot;
			(the exclamation mark). When used, the presence of the specified component in the dictionary is required,
			otherwise the component is not considered to be valid (it does not match the pattern).
			</p>

			<strong>Redefinition of existing components</strong>
			<p align="justify">
			For a named component definition, an attribute <code>definition</code> is used. The attribute contains
			a string of components representing actual components&#39; structure definition. Redefining a component
			means changing the parsing pattern structure while other functional capabilities of the component
			remain unchanged (verifying against dictionaries, output column, etc.). For redefining components,
			a &#39;|&#39; character	is used as a delimiter between the component name and its new definition. For example we
			have a named component <code>COMP</code> defined by <code>{WORD} {WORD}</code> with output column <code>output</code>
			then we can create the following definition <code>{COMP|{WORD} a}</code>. Then for parsing the <code>{WORD} a</code> will be used
			instead of <code>{WORD} {WORD}</code> and if trashing is switched on the output will be stored in the <code>output</code> column.
			<br/>
			</p>

			<strong>Optional components</strong>
			<p align="justify">
			If you put after the component name the question mark then the parser will try first parse the input text
			with component and if it fails it tries to parse the input text without the component. Therefore we call
			it the optional component. An example is: <code>{REGEXP?:pattern=&quot;.&quot;}</code>. If there are more optional 
			components in the pattern then the parser tries to omit the components from the right side.
			</p>

			<div>
        <strong>
          <em>Pattern processing</em>
        </strong>
      </div>
			<p align="justify">
			To allow for extended prioritization of parsing rules, they are divided
			into parsing groups and each of them is parsed in isolation from
			others. For a complete description see the 
			<strong>Pattern Group</strong> configuration element.
			</p>

			<div>
        <strong>
          <em>Scoring</em>
        </strong>
      </div>
			<p align="justify">
			<strong>Scoring</strong> functionality of the <code>Pattern Parser</code> step is
			performed via two types of <strong>scorers</strong>. The first is a main scorer applied to
			the overall step. The second is applied separately to each component participating in the parsing process.
			Every component scores its activity and thus it is possible to obtain detailed information about the process.
			Component scorers are not required.
			</p>

<example>
        <pre>
&lt;step id=&#39;alg&#39; className=&#39;com.ataccama.dqc.tasks.parse.PatternParserAlgorithm&#39;&gt;
	&lt;properties&gt;
		&lt;in&gt;input&lt;/in&gt;
		&lt;parserConfig&gt;
			&lt;patternGroups&gt;
				&lt;patternGroup&gt;
					&lt;patterns&gt;
						&lt;!-- use of custom component --&gt;
						&lt;pattern name=&quot;rule#1&quot; definition=&quot;ulice {CP}&quot; priority=&quot;0&quot; /&gt;

						&lt;!-- use of other named component --&gt;
						&lt;pattern name=&quot;rule#2&quot; definition=&quot;Match {MATCHED_WORD}&quot; priority=&quot;0&quot; /&gt;

						&lt;!-- component override --&gt;
						&lt;pattern name=&quot;rule#3&quot; definition=&quot;{WORD | {REGEXP:pattern=&#39;[A-Z][a-z]+&#39;}}&quot; priority=&quot;0&quot; /&gt;

						&lt;!-- component override - the regular expression is not effective here, only the verifier if specified --&gt;
						&lt;!-- input text &#39;123 456&#39; is accepted by the parsing sequence: {NUMBER} {NUMBER} --&gt;
						&lt;pattern name=&quot;rule#4&quot; definition=&quot;{MATCHED_WORD | {NUMBER} {NUMBER}}&quot; priority=&quot;0&quot; /&gt;

						&lt;!-- input text &#39;abc + def&#39; is accepted (again by the parsing sequence) --&gt;
						&lt;!-- whatever verifier is still effective --&gt;
						&lt;pattern name=&quot;rule#5&quot; definition=&quot;{MATCHED_WORD | {WORD} + {WORD}}&quot; priority=&quot;0&quot; /&gt;
					&lt;/patterns&gt;
				&lt;/patternGroup&gt;
			&lt;/patternGroups&gt;

			&lt;components&gt;
				&lt;component name=&quot;CP&quot; definition=&quot;{WORD}&quot; storeParsedInto=&quot;parsed&quot;&gt;
					&lt;verifier&gt;
						&lt;fileName&gt;data/ext/street.sl.cif&lt;/fileName&gt;
						&lt;type&gt;stringLookup&lt;/type&gt;
					&lt;/verifier&gt;
				&lt;/component&gt;

				&lt;component name=&quot;MATCHED_WORD&quot; definition=&quot;{REGEXP:pattern=&#39;[a-zA-Z0-9]+&#39;}&quot; storeParsedInto=&quot;eWord&quot;&gt;
				&lt;/component&gt;
			&lt;/components&gt;
		&lt;/parserConfig&gt;

		&lt;scorer explanationColumn=&#39;expl&#39;&gt;
			&lt;scoringEntries&gt;
				&lt;scoringEntry key=&#39;GP_NULL&#39; score=&#39;300&#39; explain=&#39;true&#39; /&gt;
				&lt;scoringEntry key=&#39;GP_NO_PATTERN&#39; score=&#39;300&#39; explain=&#39;true&#39; /&gt;
				&lt;scoringEntry key=&#39;GP_MORE_PATTERNS&#39; score=&#39;300&#39; explain=&#39;true&#39; /&gt;
			&lt;/scoringEntries&gt;
		&lt;/scorer&gt;
	&lt;/properties&gt;
&lt;/step&gt;</pre>
      </example>
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="in" type="string" required="true">
				Column that contains the text be processed.
			</property>
			<property name="patternName" type="string" required="false">
				Column that contains the name of the pattern which was used to parse the input string.
			</property>
			<property name="trash" type="string" required="false">
				Column that stores the trash information. Trash information is the part
				of the input text which was not recognized
				as a known component or, when the <code>Full Trash Scope</code> flag is true,
				text parsed by a component not having its own output column <code>Store Parsed Into</code>.
				The binding is not mandatory, thus the property <code>Full Trash Scope</code>
				is effective only when this binding is set.
			</property>		
			<property name="fullTrashScope" type="boolean" required="true">
				Specifies whether text parsed by components which don&#39;t use the <code>Store Parsed Into</code> parameter is
				stored into the column defined by the binding <code>Trash</code>. Text not parsed by any component is stored in any case.
				This parameter has effect only if the binding <code>Trash</code> is defined.
				<br/>
				Default value: <code>false</code>.
			</property>
			<property name="parserConfig" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.ParserConfig" required="true">
				Configuration of the parser.
			</property>
			<property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Configuration of the tokenizer.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
            <scoringKey name="PP_NULL">
                A scoring flag indicating that input data is missing.
            </scoringKey>
            <scoringKey name="PP_NO_PATTERN">
                A scoring flag indicating that no parsing pattern corresponding to the input value was found.
            </scoringKey>
            <scoringKey name="PP_MORE_PATTERNS">
                A scoring flag indicating that more than one parsing pattern matched the input string.
            </scoringKey>
            <scoringKey name="PP_TRASH">
                A scoring flag indicating that some text wasn&#39;t parsed or was parsed by a component having no
                special output in the case that <code>Full Trash Scope</code> is specified. This flag is set even if the binding <code>Trash</code>
                is not defined.
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.PkAnalysis">
    <introduction>
		Defines a key whose uniqueness is analyzed.
		Result of this analysis is number of unique, non unique and <code>null</code> keys.
		</introduction>
    <properties>
			<property name="name" type="string" required="false">
			Descriptive name of this analysis.
			</property>
			<property name="components" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
			Components of the key. The whole key is assumed to be <code>null</code> when all components
			are <code>null</code>.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.experimental.asyncwriter.service.IAsyncWriterTarget" name="com.ataccama.dqc.tasks.experimental.asyncwriter.service.PlanTarget">
    <introduction>Enables submitting records into another processing configured via plan.</introduction>
    <description>Enables submitting records into another processing configured via plan.</description>
    <properties>
			<property name="fileName" type="string" required="true">Path (relative to the server configuration file or absolute) to the target DQC plan.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.reader.PrefixNamespacePair">
    <description>
		Defines a prefix for some namespace.
		</description>
    <properties>
		 	<property name="prefix" type="string" required="true">An XML namespace is declared using the reserved XML attribute <strong>xmlns</strong> or <strong>xmlns:prefix</strong>, the value of which must be a valid namespace name. For example, the following declaration maps the <code>&quot;xhtml:&quot;</code> prefix to the XHTML namespace:<br/>
			<code>xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;</code>
      </property>
		 	<property name="namespace" type="string" required="true">A namespace name is a uniform resource identifier (URI) or a unique name identifying the namespace, e.g. <code>&quot;http://www.w3.org/1999/xhtml&quot;</code>
      </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.AbstractGuessNameSurnameAlgorithm$PreserveDifferentType"/>
  <class name="com.ataccama.dqc.unify.common.ProcessingMode">
    <description>
			Specifies the mode processing.
			<br/>Default value: NORMAL.
		</description>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.ProfiledData">
    <description>
		Defines the values the statistical and/or frequency analysis will be applied to.
	</description>
    <properties>
			<property name="expression" type="string" required="true">
			The specified multi-column expression, or a single <em>column</em> expression, to evaluate for all records.
			</property>
			<property name="analyseDomain" type="boolean" required="true">
			Specifies if the domain analyse of values will be performed.
			</property>
			<property name="frequencyAnalysis" type="com.ataccama.dqc.tasks.profiling.config.ProfiledData$FrequencyAnalysis" required="true">
			Specifies whether frequency analysis will be performed and its type.
			</property>
			<property name="maskName" type="string" required="false">
			Specifies name of mask definition if frequency analysis of patterns should be performed.<br/>
			Meaningful only for frequency analysis of string data.
			<br/>Default value: no pattern analysis
			</property>
			<property name="groupSizeAnalysis" type="com.ataccama.dqc.tasks.profiling.config.ProfiledData$FrequencyAnalysis" required="true">
			Specifies whether analysis of group sizes will be performed and its type.
			</property>
			<property name="locale" type="string" required="false">
			Locale definition for a specified column. If not specified, the value of defaultLocale is used.
			</property>
			<property name="standardStats" type="com.ataccama.dqc.tasks.profiling.config.ProfiledData$StandardStatistics" required="true">
			Specifies which statistics will be counted.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.ProfilingAlgorithm">
    <introduction>Computes statistics and other data analysis measures.</introduction>
    <description>
				<p align="justify">
					This profiling step is used in statistical analysis of data.
					For each data column this step will compute
					statistics (values) such as minimum, maximum, standard and error values.
				</p>
				<p align="justify">
					The profiling step is capable of multiple analytical operations
					in a single pass over multiple columns of input data.<br/>
					All date types supported by [branding:product.name.abbreviation] can be specified as long as they correspond
					to the applied date operations.<br/>
        <br/>
					<table border="1">
						<th>
							<th/>
							<th>INTEGER, LONG</th>
							<th>DAY, DATETIME</th>
							<th>BOOLEAN</th>
							<th>STRING</th>
						</th>
						<tr>
							<td>Data Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Null Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Not Null Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Different Value Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Unique Value Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>
              <br/>
            </td>
							<td/>
							<td/>
							<td/>
							<td/>
						</tr>
						<tr>
							<td>Sum</td>
							<td>yes</td>
							<td>-</td>
							<td>yes</td>
							<td>-</td>
						</tr>
						<tr>
							<td>
								Variance
								<a href="http://en.wikipedia.org/wiki/Variance#Definition" target="_blank">
									Definition
								</a>.
								Result for DAY/DATETIME values are in squared days.
							</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
							<td>-</td>
						</tr>
						<tr>
							<td>
								Standard Deviation
								<a href="http://en.wikipedia.org/wiki/Standard_deviation#Definition_and_calculation" target="_blank">
									Definition
								</a>.
								Result for DAY/DATETIME values are in days.
							</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
							<td>-</td>
						</tr>
						<tr>
							<td>
              <br/>
            </td>
							<td/>
							<td/>
							<td/>
							<td/>
						</tr>
						<tr>
							<td>Average</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
						</tr>
						<tr>
							<td>Median</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Quantile</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>
              <br/>
            </td>
							<td/>
							<td/>
							<td/>
							<td/>
						</tr>
						<tr>
							<td>Maximum</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Minimum</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>
              <br/>
            </td>
							<td/>
							<td/>
							<td/>
							<td/>
						</tr>
						<tr>
							<td>First X Values</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Last X Values</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
					</table>
				</p>
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="inputs" type="com.ataccama.dqc.tasks.profiling.config.ProfilingInput[]" required="true">
			List of input sources on which the profiling is performed. Each element needs an 
			appropriate input endpoint.
			</property>
			<property name="fkAnalysis" type="com.ataccama.dqc.tasks.profiling.config.FkAnalysis[]" required="false">
			List of definitions of foreign key analyses.
			</property>
			<property name="defaultLocale" type="string" required="false">
			Locale represents a specific geographical, political, or cultural region, with respect
			to data parsing and comparison as performed by the step.<br/>
			Default value: <code>en_US</code>
			</property>
			<property name="outputFile" type="string" required="true">
			Filename of the result file where the profile results will be stored.
			</property>
			<property name="exportFile" type="string" required="false">
			XML or JSON file where the profile results will be exported.
			</property>
			<property name="outputLimit" type="integer" required="true">
			Specifies the maximum number of frequency records being stored into the output.
			The parameter is applied on both most frequent values
			and least frequent values.
			The amount of data is thus at most twice as this value.
			The value is applicable only to results of frequency and group size analysis
			and is applied to all profiled data separately.
			If the value is set to zero, number of stored records is unlimited.
			<br/>
			Default value: <code>1000</code>
			</property>
			<property name="dataSource" type="string" required="false">
			Data source name of database for storing drill-through data.
			Required when at least one <code>input</code> has specified <code>Drill-through</code>.
			</property>
			<property name="tableNamePrefix" type="string" required="false">
			Prefix for names of database tables to which drill-through data will be stored.
			Required when at least one <code>input</code> has specified <code>Drill-through</code>.
			</property>
			<property name="masks" type="com.ataccama.dqc.tasks.profiling.config.MaskCfg[]" required="false">
			List of mask definitions.
			</property>
			<property name="domains" type="com.ataccama.dqc.tasks.profiling.config.DomainAnalysisCfg" required="true">
			Specifies which and how domain analysis will be performed.
			</property>
			<property name="userMetadata" type="com.ataccama.dqc.tasks.common.config.UserMetadata" required="true">
			Additional metadata appended to result file.
			</property>
			<property name="threaded" type="boolean" required="true">
			Specifies whether the step will perform calculations in single thread (one after one)
			or in multiple-threads (parallel processing).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.ProfilingColumn">
    <description>Columns that will be profiled by the <strong>Simple Profiling</strong> step.</description>
    <properties>
			<property name="expression" type="string" required="false">Expression that you can use for setting up a condition on column that should be profiled.</property>
			<property name="name" type="string" required="true">Name of the column that should be profiled.</property>
			<property name="statistics" type="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic[]" required="true">List of <strong>Statistic Implementations</strong> that will be applied to profiled column.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.ProfilingInput">
    <properties>
			<property name="name" type="string" required="true">
			The unique name of the input, and consequently the step input endpoint.
			</property>
			<property name="dataToProfile" type="com.ataccama.dqc.tasks.profiling.config.ProfiledData[]" required="false">
			Input column for profile operation.
			</property>
			<property name="businessRules" type="com.ataccama.dqc.tasks.profiling.config.BusinessRule[]" required="false">
			List of definitions of business rules.
			</property>
			<property name="pkAnalysis" type="com.ataccama.dqc.tasks.profiling.config.PkAnalysis[]" required="false">
			List of definitions of primary key analyses.
			</property>
			<property name="dependencies" type="com.ataccama.dqc.tasks.profiling.config.DependencyAnalysis[]" required="false">
			List of definitions of dependency analyses.
			</property>
			<property name="rollUps" type="com.ataccama.dqc.tasks.profiling.config.RollUp[]" required="false">
			List of keys defining hierarchical splitting of the data set into subsets.
			All the calculations defined for this input are then performed for the subsets.
			</property>
			<property name="drillThrough" type="boolean" required="true">
			Specify whether data of this input have to be written to database to allow
			drill-through.
			<br/>Default = false.
			</property>
			<property name="drillThroughLimit" type="integer" required="false">
			Maximum number of rows written to the drill-through table. If not specified, all rows will be
			written.
			<br/>Default = full drill-through
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.spark.steps.SparkRDDRepartition$PropType">
    <description>Specifies the meaning of <code>partitions</code> property value.</description>
  </class>
  <class name="com.ataccama.adt.variables.write.WritePropertyFile$PropertyMapping">
    <introduction>Properties to write to file</introduction>
    <description/>
    <properties>
			<property name="name" type="string" required="true">Property name</property>
			<property name="expression" type="string" required="true">Expression to evaluate and write its result to property file</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.ProposalCount">
    <introduction>
    		Definition of proposal count to be written out when the given condition is met.
    	</introduction>
    <description>
    		Each element contains condition that will determine when to apply
    		result of limit expression on proposals to be written out. 
    	</description>
    <properties>
    		<property name="when" type="string" required="false">Condition when to apply <code>Limit</code> expression on proposals.</property>
      		<property name="limit" type="string" required="false">Expression returning maximum number of proposals.</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.evaluation.IProposalEvaluatorDefinition">
    <introduction>
			Definition of proposal evaluator.  
		</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.AbstractGuessNameSurnameAlgorithm$ProposalSelectionStrategy"/>
  <class name="com.ataccama.dqc.tasks.analysis.statistics.quantiles.Quantile$QuantileRank">
    <description>Rank of the quantile from 0 to 100.</description>
    <properties>
			<property name="rank" type="double" required="true">
            Rank of the quantile from 0 to 100.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.statistics.quantiles.QuantileStatistic">
    <description>Definition of quantiles to be computed.</description>
    <properties>
			<property name="ranks" type="com.ataccama.dqc.tasks.analysis.statistics.quantiles.Quantile$QuantileRank[]" required="true">
            Rank of quantiles to be computed.
			</property>
			<property name="expression" type="string" required="true">
			The specified multi-column expression, or a single <em>column</em> expression, to evaluate for all records.
			</property>
			<property name="name" type="string" required="true">
			Name of the quantiles computed in this operation.
			</property>
			<property name="error" type="double" required="true">
			Error of the quantiles. The quantile with rank r is guaranteed to be in the range [r - e*N; r + e*N],
			where e is the error and N is the number of values in the dataset.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.statistics.quantiles.QuantilesAlgorithm">
    <introduction>Computes quantiles of input data.</introduction>
    <description>
			<p align="justify">
				Step outputs quantiles in the following format: 
				<ul>
					<li>
						quantile_name [STRING] - user defined name for the group of quantiles
					</li>
					<li>
						quantile_value [STRING] - value of the quantiles
					</li>
					<li>
						quantile_distinction [STRING] - rank of the quantiles
					</li>
				</ul>
			</p>
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="quantiles" type="com.ataccama.dqc.tasks.analysis.statistics.quantiles.QuantileStatistic[]" required="true">
			Root quantiles node.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.RCValidatorAlgorithm">
    <introduction>Validates Czech birth number.</introduction>
    <description>
		This step verifies input Czech birth numbers and recognizes and completes missing information in them.<br/>
		<linkTarget id="RC_format_desc"/>
		<strong>RC format</strong>
      <br/>
		<p align="justify">
			The format of RC is the following:<br/>
			<code>yymmddttt[t]</code>
        <br/>
			The meaning of the fields and their restrictions follow:<br/>
			<ul>
				<li>
            <code>yy</code> = last two digits of the year of the person&#39;s birth year. The allowed range is
							00-99</li>
				<li>
            <code>mm</code> = month in year of the person&#39;s birth day, starting at 1. In this value is 
					also encoded the gender of the person. So allowed ranges are:
					<ul>
						<li>01-12 : for male</li>
						<li>51-62 : for female</li>
						<li>21-32	: for male - may appear only for dates after 1.4.2004 (including)</li>
						<li>71-82	: for female - may appear only for dates after 1.4.2004 (including)</li>
					</ul>
					Values 00,20,50,70 are considered as artificial dates, other values are considered as
					invalid date definition. 
				</li>
				<li>
            <code>dd</code> - day in month of the person&#39;s birth day, starting at 1. The allowed
					range, depending on the month, is 1-31. The value 00 is considered an artificial date, 
					other values are considered invalid date definitions.</li>
				<li>RCs issued before 1.1.1954 must consist of 9 digits, RCs issued this date or later must
					  consist of 10 digits</li>
				<li>all 10 digits numbers must fulfill the mod11 check. Assuming that:
					<ul>
						<li>A = a numerical value of the first 9 digits</li>
						<li>n = the numerical value of the 10th digit</li> 
					</ul>
					the following equation must be true: <code>A mod 11 = n</code>
            <br/>
					If the result of the modulo operation is 10, then 0 is considered.<br/>
					Examples:<br/>
					<ul>
					  	<li>
				    		Input birth number: <code>8151010043</code>, <code>A = 815101004, n = 3, A modulo 11 = 3</code>,
				       		which implies that the sample birth number meets the condition.
				       	</li>
				       	<li>
				       		Input birth number: <code>8102060110</code>, <code>A = 810206011, n = 0, A modulo 11 = 10</code>, 
				       		i.e. result = <code>0</code>, and the input birth number also meets the condition.
						</li>
				    </ul>						
				</li>
			</ul>
			RCValidator automatically removes non-digit characters, checks all of above, so in order to be considered valid the RC must match all of these rules.	
		</p>
 		
		<br/>
		<!-- Usage and scenarios -->	
		<strong>Algorithm usage and modes (scenarios)</strong>
      <br/>
		<p align="justify">
		The implemented step depends on the provided input data and therefore its processing continues according to 
		one of the following three scenarios:
			<ul>
				<li>
					Scenario A: The input birth number is provided in the input, in which case 
					the step verifies the birth number. If supplementary information about birth date and	
					gender is filled in, an	additional comparison with data computed from the input birth 
					number is made. Identified data	are written to output.<br/>
				</li>
				<li>
					Scenario B: The input birth number is not provided but additional information about gender 
					and birth date can be read from the input. A birth number is generated and written to the 
					output <code>RC Generated</code> together with gender and birth date input values.<br/>
					This scenario represents &quot;generation-mode&quot; when a missing RC is generated from provided gender
					and date information.
				</li>
				<li>
					Scenario C: The input birth number is not provided and both birth date and gender are missing. 
					In this	case, the birth number is not generated and output bindings are not set (contains
					null values).
				</li>
			</ul>
        <br/>
			
	      The best case scenario is that all the output columns are filled in (input data came through the validation process
    	  successfully) and no scoring flag was set. <br/>
        <br/>
		</p>
	
		<strong>Scenario B and C:</strong>	
		<p align="justify">
			If the birth number is not present in the input, the implemented step attempts to generate a <code>fake</code> birth number. 
			This operation requires valid input birth date and gender values to be provided.
	      	If any of these two pieces of information is missing, the scoring flag <code>RC_NOT_GENERATED</code> is set and 
	      	all algorithm outputs (<code>RC Out</code>, <code>RC Generated</code>, <code>Gender Out</code>, <code>Birth Date Out</code>) 
	      	will contain empty values.<br/>
	      	If the <code>fake</code> birth number has been successfully generated, the <code>RC_GENERATED</code> 
	      	scoring flag is set.<br/>
	      	<strong>Note</strong> that contrary to the previous versions that were generating <code>fake</code> RC numbers 
	      	directly to the <code>RC Out</code> output, now the generated RC numbers are written to the optional 
	      	<code>RC Generated</code> output.<br/>
	      	See the <strong>outputs description</strong>. 
		</p>
		
		<!--  validation process  -->
		<strong>Scenario A: RC verification process</strong>
		<p align="justify"> 
			Generally the algorithm first tries to determine the date from the provided RC value and then verifies the rest of the 
			information read from the RC against that date and provided hints. The algorithm first reads the RC value from the
			input RC binding and cleans it up. Cleaning means that all non-digit characters are removed. Then the
			cleaned value is sent to validation.<br/> 
			<br/>
			Generally, birth number validation includes:
			<ul>
				<li>general RC length validation</li>
				<li>RC date guess and the following validations:
					<ul>
						<li>artificial date validation</li>
						<li>validation of the date format of the date (valid month-day combinations, etc.)</li>
						<li>initial date guess</li>
						<li>comparison with the allowed date range which is defined by the interval 
							  &lt;BirthNumberSince, today&#39;s date&gt;</li>
						<li>dummy date validation</li>
						<li>comparison of the determined date with the date hint</li>	
					</ul>
				</li>
				<li>RC gender recognition and the following validations:
					<ul>
						<li>gender encoding format: checking gender-encoding-format vs. issue-era match.<br/>
							  (Gender may be encoded in various forms depending on the RC issue era)</li>
						<li>comparison of the determined gender with the gender hint</li>
					</ul>
				</li>
				<li>trailer checking &amp; fixing
					<ul>
						<li>verification of trailer length<br/>
							 (RCs may have different lengths depending on on the issue era)</li>
						<li>mod11 check</li>
						<li>trailer fixing</li>
					</ul>
				</li>
			</ul>
		</p>
		
		<strong>The following provides ad detailed description of each validation part:</strong>
		<br/>
		<br/>
		
		<strong>General length validation</strong>
		<p align="justify">
			The algorithm verifies RC values that (after cleansing) consist of:
			<ul>
				<li>6 digits: in such case the flag <code>RC_TRLR_MISSING</code> is set, and the number is considered 
					  invalid, but date &amp; gender validations are still performed and scored</li> 
				<li>9 or 10 digits: RC is passed on to further validations</li>
				<li>other lengths: RC is considered invalid, the flag <code>RC_INVALID</code> is set and no further
					  validation is performed</li>
			</ul>
		</p>
		
		<linkTarget id="RC_val_artif_date"/>
		<strong>Artificial date validation</strong>
      <br/>
		<p align="justify">
			Once the date string is read from the RC (the first 6 characters of the RC), it is checked for an artificial date. 
			The date is considered artificial if:
			<ul>
				<li>its month part equals 0</li>
				<li>its date part equals 0<br/>
					  this value is considered after gender decoding, so the RC date
					  is considered artificial if it contains these values for month in the input RC:
					  0 (male), 20 (extended male format), 50 (female), 70 (extended female format)
				</li>
			</ul>
			When a date is considered artificial the flag <code>RC_DATE_ARTIF</code> is set and the whole RC is considered
			invalid - no further validations are performed.<br/>
		</p>
		
		<linkTarget id="RC_val_date_format"/>
		<strong>Validation of date format</strong>
		<p align="justify">
			Values read from the first 6 positions (after gender decoding) are tested if the date they represent is valid.
			If some invalid date combination is detected (for example 30.2.1901 or 29.2.1901 - which are both invalid
			because date 30.2. has never existed, 29.2.1901 cannot exist since 1901 is not a leap year) then the 
			<code>FLAG_DATE_INVALID</code> flag is set, the whole RC is considered invalid and no further checks are
			performed.<br/>
			<br/>
		</p>
				
		<strong>Initial date guess</strong>
		<p align="justify">
			After checking date fields separately the initial date guess is performed. 
			This value depends on the length of the RC:
			<ul>
				<li>birth number length is 6:<br/>
			   		The birth number is assumed to be formed by the first six digits without trailer characters. 
			   		If the year value is greater than 53 then 1900 is added; if the year 
				    value is less than or equal to 53, the value 2000 is added. If the resulting year value denotes a year 
				    in the future, 100 is subtracted from the value.
				 </li>
				 <li>birth number length is 9:<br/>
				 	The birth number is assumed to be in the full format except for the last digit of the trailer(i.e. yyyyyyxxx). 
				 	If the year value is greater than 53 then 1800 is added, if the year value is less than or equal to 53 
				 	then 1900 is added.
				 </li>
				 <li>birth number length is 10:<br/>
				 	The birth number is assumed to be in the full format including the trailer. The year value is computed in the same 
				 	way as for the 6-digit birth numbers.
				 </li>
			</ul>
		</p>
		
		<linkTarget id="RC_val_bn_since"/>
		<strong>Date correction - birthNumberSince, date hint and extended-gender role:</strong>
      <br/>
		<p align="justify">
			After this initial guess is made, the date value is corrected by adding 100 years if one of following 
			situations occur:
			<ul>
				<li>the guessed date is before the date defined by the <code>Birth Number Since</code> attribute</li>
				<li>the guessed date is older than 1.4.2004 but gender encoding in the RC uses the extended form (see 
				<strong>RC format</strong>)</li>
			</ul>
			This correction is not performed if it would break these rules:  
			<ul>
				<li>the resulting date must not be in the future</li>
				<li>there&#39;s a date hint defined that supports (matches) the originally guessed date</li>
			</ul>
			If the correction cannot be performed because of the above rules then:
			<ul>
				<li>for a date before <code>Birth Number Since</code> the <code>RC_DATE_BEFORE_BN_SINCE</code> flag is set, 
					  but further validations are still processed</li>
				<li>for a mismatch of the date and gender-encoding the <code>RC_DATE_INVALID</code> flag is set and no 
					  further validation is performed</li>
			</ul>
		</p> 
		
		<linkTarget id="RC_val_dummy_date"/>
		<strong>Dummy date validation</strong>
		<p align="justify">
			After the date is determined, it is compared to the <code>Dummy Date</code> value. If they match
			the <code>RC_DUMMY_DATE</code> flag is set and the RC is considered invalid. If date is flagged as
			dummy, no further checks are performed.<br/>
		</p>
		
		<strong>Date hint compare</strong>
		<p align="justify">
			The final date check compares the date guessed from the RC with the given date hint (if present). If they do not match,
			the <code>RC_DATE_MISMATCH</code> is set and the RC is considered invalid, but further checks are still
			performed.<br/>
		</p>

		<strong>Gender recognition and validation</strong>
		<p align="justify">
			The gender is recognized from the RC (see <strong>RC format</strong>) and the  
			determined value is compared to the given gender hint (if defined). In case they are not equal the 
			<code>RC_GNDR_MISMATCH</code> flag is set and the RC is considered invalid. Further validations are still
			processed.
		</p>

		<strong>Trailer validation and fixing</strong>
		<p align="justify">
			<ul>
				<li>Trailer length validation<br/>
					The trailer&#39;s length must match the era the RC was issued in (see <strong>RC format</strong>)<br/>
					The algorithm compares the length of the trailer against the date guessed from the RC. If the trailer does not
					match the date, then the following attempts to fix the trailer are performed:
					<ul>
						<li>extension of 9-digit RC to 10-digits<br/>
							This correction is invoked automatically (and cannot be influenced by the configuration). 
							The correction tries to extend the RC by appending a &#39;0&#39; digit to the beginning or to the end of the 
							trailer. The correction is performed only if:
							<ul>
								<li>there&#39;s only one option how to fix the number (so numbers that can be fixed by adding &#39;0&#39; either to the
							beginning or the end of the trailer are considered unrepairable - it is not possible to decide which 
							correction is the right one)</li>
								<li>resulted number passes the mod11 trailer check (see <strong>RC format</strong>)</li>
							</ul> 
							If the number was repaired the <code>RC_TRLR_FIXED</code> flag is set. Otherwise the <code>RC_TRLR_INVALID</code> 
							is set and the RC is considered invalid.
						</li>
						<li>shortening 10-digit RC to 9-digits<br/>
							The correction tries to shorten a 10-digit RC to the 9-digit RC by removing a &#39;0&#39; from the beginning
							or the end of the trailer.
						</li>
					</ul>
				</li>
				<li>mod11 trailer check<br/>
					RC must pass the mod11 check as described in the <strong>RC format</strong> description above.
				</li>
			</ul>
		</p>
			
	  	<linkTarget id="RCValidator_gd_outputs"/>
	  	<strong>Setting up outputs</strong>
	  	<p align="justify">
	  		The algorithm outputs the following values:
	  		<ul>
	  			<li>RC (binding <code>RC Out</code>) - contains verified/fixed RC from the input. Users may suppress writing invalid RCs
	  				to this output by setting <code>omitInvalidRc=true</code>. It is also possible to choose whether to output the 
	  				original RC number or the cleansed one using the attribute <code>Preserve Input RC Value</code>. See their descriptions
	  				for more details.
	  			</li>
	  			
	  			<li>generated RC (binding rcGenerated) - see the <code>RC Generated</code> property description for more details.</li>
	  			
	  			<li>gender and date read from RC - these values are outputted always regardless on the overall validity of
	  				  the RC. The only case when these values are not written out is the case when it was impossible to read
	  				  or successfully parse the input RC value. This state is indicated by some of following flags:
	  				  <ul>
	  				  	<li>
                <code>FLAG_RC_INVALID</code>
              </li>
	  				  	<li>
                <code>FLAG_DATE_INVALID</code>
              </li>
	  				  	<li>
                <code>FLAG_DATE_ARTIF</code>
              </li>
	  				  	<li>
                <code>FLAG_DATE_DUMMY</code>
              </li>
	  				  </ul>
	  			</li>
	  		</ul>
	  	</p>
	</description>
    <properties>
			<property name="rc" type="string" required="true">
			A string expression describing where to read the birth number from. Non-digit characters are automatically removed from the input.
      		</property>
			<property name="rcOut" type="string" required="true">
			A string column indicating where the output birth number should be stored.
			</property>
			<property name="rcGenerated" type="string" required="false">
			A string column indicating where the generated birth number should be stored. If this property is not defined then birth numbers are not generated.
			</property>			
			<property name="birthDate" type="string" required="false">
			A day expression describing where to read the birth date hint from.
			</property>
			<property name="gender" type="string" required="false">
			A string expression describing where to read the gender hint from.
			</property>
			<property name="genderOut" type="string" required="false">
			A string column indicating where the output gender should be stored.
			</property>
			<property name="birthDateOut" type="string" required="false">
			A day column indicating where the output birth date should be stored.
			</property>

			<property name="allowArtificialTrailers" type="boolean" required="true">
			A flag determining if birth numbers containing artificial trailers should be considered
			valid (true) or invalid (false). If the <code>false</code> option is chosen (i.e. invalid), 
			the numbers are treated as any other invalid birth number - the <code>Omit Invalid RC</code> parameter 
			value indicates whether the values should be written to the output or not.
			<br/>
			Default value: <code>False</code>.
			</property>
			<property name="birthNumberSince" type="date" required="false">
				This attribute defines the oldest date that is acceptable as a date guess for the given RC.
				Because there&#39;s no century part specified in RCs, the algorithm tries to guess the correct century value. 
				See the <strong>birthNumberSince role</strong> for a detailed description.
				<br/>
				Usually it makes sense to set this value somewhere after the year 1900.<br/>
				Default value: <code>1.1.1901</code>.
			</property>
			<property name="canFix10digitBn" type="boolean" required="true">
			 	A flag indicating whether an incorrect trailer of a 10-digit birth number should be repaired or not.
				<br/>
				Default value: <code>False</code>.
			</property>
			<property name="dummyDate" type="date" required="false">
				A special value of the birth date in a birth number which is further considered <code>null</code>. 
				If such a value is extracted from a birth number, the date is treated as invalid and the scoring flag 
				<code>RC_DUMMY_DATE</code> is set. This flag does not prevent sending values read from RC to the 
				<code>Birth Date Out</code> and <code>Gender Out</code> outputs. See the <strong>outputs
				description</strong>.<br/>
				<strong>Note:</strong> date is considered a dummy date even if supported by the date-hint (because
				it is usually not possible to assure that hint was created independently of the RC in the primary system).
				This is a change from the previous version where hint-supported dummy dates were accepted as valid. 
				<br/>
				Default value: <code>Null</code>.
			</property>
			<property name="femaleDefinition" type="string" required="false">
				A string value defining identification of the female gender. This value is compared to the input 
				<code>Gender</code> value.
				<br/>
				Default value: <code>F</code>.
			</property>
			<property name="ignoreDefaultTrailers" type="boolean" required="true">
				A flag indicating whether default artificial trailers (<code>000</code>, <code>0000</code>, 
				<code>111</code>, <code>1111</code>, <code>999</code>, <code>9999</code>) should be ignored or not.
				<br/>
				Default value: <code>False</code>.
			</property>
			<property name="maleDefinition" type="string" required="false">
				A string value defining identification of the male gender. This value is compared to the input 
				<code>Gender</code> value.
				<br/>
				Default value: <code>M</code>.
			</property>
			<property name="omitInvalidBn" type="boolean" required="true">
				A flag indicating whether invalid birth numbers should be written to the output or not. If set to 
				<code>true</code> and either an error occurs during the birth number validation or an error occurs 
				during comparison of the input date and date obtained from birth number, the birth number is not 
				written to the output. The birth number is written to the output in all other cases. The birth 
				number is omitted when at least one of the following scoring flags is set: <br/>
					  <ul>
							<li>
            <code>RC_MISSING</code>
          </li>
							<li>
            <code>RC_INVALID</code>
          </li>
							<li>
            <code>RC_DATE_INVALID</code>
          </li>
							<li>
            <code>RC_DATE_ARTIF</code>
          </li>
							<li>
            <code>RC_DATE_MISMATCH</code>
          </li>
							<li>
            <code>RC_TRLR_MISSING</code>
          </li>
							<li>
            <code>RC_GNDR_MISMATCH</code>
          </li>
							<li>
            <code>RC_TRLR_INVALID</code>
          </li>
							<li>
            <code>RC_TRLR_ARTIF</code> - only if <code>allowArtificalTrailers</code> 
							is set to <code>false</code>
          </li>
					  </ul>
					  The output of <code>Birth Date Out</code> and <code>Gender Out</code> is not influenced by the 
					  <code>Omit Invalid RC</code> flag.<br/>
				If both properties <code>Preserve Input RC Value</code> and
				<code>Omit Invalid RC</code> are set, omitInvalidBn is used and therefore the output
				value is empty if one of the listed scoring flags is set.<br/>
			</property>
			<property name="preserveInputValue" type="boolean" required="true">
				A flag indicating whether the original input birth number (<code>preserveInputValue = true</code>) 
				or the modified birth number(<code>preserveInputValue = false</code>)should be written to the output.<br/>
				If a scoring flag <code>RC_TRLR_FIXED</code> is set, the property is overridden and there is a changed
				birth number written to the output.<br/>
				If both properties <code>Preserve Input RC Value</code> and
				<code>Omit Invalid RC</code> are set, omitInvalidBn is used and therefore the output
				value is empty if one of the listed scoring flags is set.<br/>
				See the <strong>outputs description</strong> for details. 
				<br/>
				Default value: <code>False</code>.
			</property>
			<property name="suffix" type="string" required="false">
			A string value specifying a suffix appended to the generated <code>fake</code> birth numbers.
			<br/>
			Default value is an empty string.
			</property>
			<property name="trailers" type="string[]" required="false">
				A list of trailers defined as artificial. Default items in the list are <code>000</code>, 
				<code>0000</code>, <code>111</code>, 
				<code>1111</code>, <code>999</code> and <code>9999</code>.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="RC_MISSING">
				A scoring flag indicating that the birth number was not filled in in the input. This flag is used
				only if the binding <code>RC Generated</code> is not defined (the algorithm works in &quot;non-generating&quot; mode). 
				Otherwise this flag is replaced with <code>RC_GENERATED</code> or <code>RC_NOT_GENERATED</code> 
				(&quot;generating&quot; mode).
			</scoringKey>
			<scoringKey name="RC_INVALID">
			A scoring flag is set in the following situations:
				<ul>
					<li>incorrect birth number length, i.e. not of length 6, 9 or 10 digits</li>
					<li>input birth number does not consist only of digits - this case is converted to the previous 
						  one and the birth	number length is reduced to 0</li>
					<li>an incorrect value occurred in the input birth number (e.g., day item = 99)</li>
					<li>control sum is not valid and the trailer cannot be repaired</li>
				</ul>
			</scoringKey>
			<scoringKey name="RC_DATE_INVALID">
			A scoring flag set in the following situations:
				<ul>
					<li>extended form of birth numbers containing a date earlier than 1.4.2004</li>
					<li>extended form of the date in a birth number of length 9 or 6</li>
				</ul>
			</scoringKey>
			<scoringKey name="RC_DATE_ARTIF">
			A scoring flag indicating that the date in the birth number is artificial, which means that either the day 
			or month is not filled in and the birth number length is only 6 digits (a typical birth number type assigned 
			to foreigners).
			The flag is set in the following situation:
				<ul>
					<li>artificial day or month value in a birth number of length 6 (e.g., 0 set for day or 50 set for 
						  month).</li>
				</ul>
			See <strong>artificial date validation</strong>.
			</scoringKey>
			<scoringKey name="RC_DUMMY_DATE">
			A scoring flag set when an artificial value is found in the date for birth numbers of length different from 6.
			See <strong>dummy date validation</strong>
			</scoringKey>
			<scoringKey name="RC_DATE_MISMATCH">
				A scoring flag indicating that the date computed from a birth number does not correspond to the date 
				obtained from the input column<code>Birth Date</code>.
			</scoringKey>
			<scoringKey name="RC_TRLR_FIXED">
				A scoring flag indicating that the input birth number had contained an incorrect trailer which was 
				repaired.
			</scoringKey>
			<scoringKey name="RC_TRLR_INVALID">
				A scoring flag indicating that trailer does not match the date guessed from the RC (for example the date was
				determined as a 10-digit era date, but the RC only has 9 digits and cannot be fixed). Situations flagged
				with this flag were flagged with the <code>RC_INVALID</code> or <code>RC_DATE_INVALID</code> flags in 
				previous versions. With the update of the validation logic this flag was introduced to flag problems
				that probably relate to the trailer. 
			</scoringKey>			
			<scoringKey name="RC_TRLR_MISSING">
				A scoring flag indicating that the input birth number did not contain any trailer (typical for 6-digit 
				birth numbers).
			</scoringKey>
			<scoringKey name="RC_TRLR_ARTIF">
				A scoring flag indicating that the birth number contains an artificial ending that is one of the following:
					 <code>000</code>, <code>999</code>, <code>111</code>, <code>0000</code>,
					<code>9999</code> or <code>1111</code> (or one of the set <code>Trailers</code>).
			</scoringKey>
			<scoringKey name="RC_9DIGITS">
				A scoring flag indicating that the output birth number consists of 9 digits. Whether the value 
				is actually written	to the output or not does not influence the flag (omission of the birth number output 
				might be caused by other types of errors or by a <code>true</code> value of the <code>Omit Invalid RC</code> 
				parameter)
			</scoringKey>
			<scoringKey name="RC_GNDR_MISMATCH">
				Indicates that the gender computed from the input <code>birth number</code> does not correspond to the 
				gender value found in the input <code>Gender</code>.
			</scoringKey>
			<scoringKey name="RC_GNDR_HINT_MISSING">
				A scoring flag denoting that the <code>Gender</code> input value was not filled in.
			</scoringKey>
			<scoringKey name="RC_GNDR_HINT_INVALID">
				A scoring flag indicating that input <code>Gender</code> value is different both from the 
				<code>Male Definition</code> and	<code>Female Definition</code> values.
			</scoringKey>
			<scoringKey name="RC_DATE_HINT_MISSING">
				A scoring flag indicating that input <code>date</code> value is missing.
			</scoringKey>
			<scoringKey name="RC_NOT_GENERATED">
				A scoring flag indicating that the birth number value was not present in the input and therefore 
				could not be generated. This flag can be set only if the algorithm operates in &quot;generating&quot; mode
				which means that the <code>RC Generated</code> property is defined.
			</scoringKey>
			<scoringKey name="RC_GENERATED">
				A scoring flag indicating that the birth number was not present in the input and a <code>fake</code> 
				birth number was generated from other entered values instead. This flag can be set only if the algorithm 
				operates in &quot;generating&quot; mode which means that the <code>RC Generated</code> property is defined.
			</scoringKey>
			<scoringKey name="RC_DATE_BEFORE_BN_SINCE">
				A scoring flag indicating that the input <code>Birth Date</code> is older than the specified 
				<code>Birth Number Since</code> value. See the <strong>birthNumberSince role</strong> 
				description.
			</scoringKey>
            <scoringKey name="RC_GNDR_FROM_HINT">
                This flag has been deprecated.
            </scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ge.RVNValidatorAlgorithm">
    <introduction>Validates the German personal identification number.</introduction>
    <description>
			Tests the input string as a RVN (Rentenversicherungsnummer - German personal ID) and verifies its validity.
			This step verifies RVN length, value of the check digit and whether a character corresponding to the first character
			of the maiden name is in the correct position.
			If the binding <code>Gender Hint</code> or the binding <code>Date Hint</code> is filled in, then the RVN is tested for these values as well.
			<br/>
      <br/>
			The method of the resultant gender computation is as follows:
			<ul>
				<li>Input gender (binding <code>Gender Hint</code>) is written to the output (binding <code>Gender Out</code>). </li>
				<li>If the input gender (binding <code>Gender Hint</code>) is not filled in and the RVN is valid, then the gender computed from the RVN is written to the output and the scoring flag <code>RV_GNDR_HINT_MISSING</code> is set.</li>
				<li>If the input gender (binding <code>Gender Hint</code>) and computed gender differ, then the input gender is written to the output and the scoring flag <code>RV_GNDR_MISMATCH</code> is set. </li>
				<li>If the input gender is invalid, then the input gender is written to the output and the scoring flag <code>RV_GNDR_HINT_INVALID</code> is set. </li>
				<li>If the input gender is missing, then the scoring flag <code>RV_GNDR_HINT_MISSING</code> is set.</li>
			</ul>
				<br/>
      <br/>
			The method of the resultant birth date computation is as follows:
			<ul>
				<li>Input birth date (binding <code>Date Hint</code>) is written to the output (binding <code>Date Out</code>). </li>
				<li>If the input birth date (binding <code>Date Hint</code>) and computed birth date differ, then the input birth date is written to the output and the scoring flag <code>RV_DATE_MISMATCH</code> is set. </li>
				<li>If the input birth date is missing, then the scoring flag <code>RV_DATE_HINT_MISSING</code> is set.</li>
			</ul>
				<br/>
      <br/>
				In addition to this standard behavior, the step takes care of the special RVN forms which can occur when the 
				day or month of birth (or both) is not specified. Such RVN are defined as valid. Since the date part is not
				complete, the birth date cannot be computed, and if the input birth date is also missing (binding <code>Date Hint</code>), then the output birth date (binding <code>Date Out</code>)
				remains empty.
				<br/>
      <br/>
				RVN date information is verified by separate parts - days, months and years are validated independently.
				If a part is missing then an appropriate scoring flag is set - <code>RV_RVN_DAY_UNKNOWN</code> or
				<code>RV_RVN_MONTH_UNKNOWN</code>. These flags are set independently of the comparison of the computed and input date and
				are set only if the RVN is valid (passes length and sum check tests).
				<br/>
      <br/>
				If the input RVN is not specified, but input birth date and gender are both specified, then the step attempts to generate a fake RVN.
				The generation requires also information about location of the RVN release and first letter of the person&#39;s maiden name.
				These additional values are defined in the <code>Gen Location</code> and <code>Gen Surname Letter</code> properties.
				The value specified for <code>Gen Location</code> must contain only two digit characters and the 
				value for the <code>Gen Surname Letter</code> only one letter character.
				<br/>
				An RVN is generated only if the input RVN is empty, e.g., for the input RVN value <code>&#39;abcd&#39;</code> which is eliminated during the cleansing
				to an empty string, the fake RVN is not generated and only the scoring flag <code>RVN_MISSING</code> (which indicates an empty RVN value after cleansing) is set.
		</description>
    <properties>
			<property name="rvn" type="string" required="true">
				Column that contains the input RVN.
			</property>
			<property name="rvnOut" type="string" required="true">
			    Column that stores the verified RVN.
			</property>
			<property name="dateHint" type="string" required="false">
			    Column that contains the birth date used to verify the RVN.
			</property>
			<property name="dateOut" type="string" required="false">
				Column that stores the resulting birth date (either input birth date or birth date computed from the RVN, depending on property settings).
			</property>
			<property name="genderHint" type="string" required="false">
			    Column that contains the gender used to verify the RVN.
			</property>
			<property name="genderOut" type="string" required="false">
			    Column that stores the resulting gender (either input gender or gender computed from the RVN, depending on property settings).
			</property>		
			<property name="femaleDefinition" type="string" required="false">
			 String defining identification of the female gender.
			  <br/>Default value: <code>F</code>.
			</property>
			<property name="genLocation" type="string" required="false">
			The string <code>location</code> is used in generation of the fake RVN. The length of the
			string must be only 2 characters (representing digits).
			<br/>
			Default value: <code>00</code>
			</property>
			<property name="genSurnameLetter" type="string" required="false">
			The string <code>Gen Surname Letter</code> is used in the generation of the fake RVN as a substitute
			for the first character of the maiden name.
			The length of the string must be 1 and the given character must represent a simple letter
			(letter from the range A-Z).<br/>
			Default value: <code>A</code>
			</property>
			<property name="maleDefinition" type="string" required="false">
			String value defining identification of the male gender.
			  <br/>Default value: <code>M</code>.
			</property>
			<property name="omitInvalidRVN" type="boolean" required="true">
			Flag that determines whether invalid RVNs should be written to the output (flag set to <code>false</code>)
			or not(flag set to <code>true</code>).
			<br/>
			Default value: <code>False</code>
			</property>
			<property name="preserveInputValue" type="boolean" required="true">
			Flag that determines whether the input RVN (flag set to <code>true</code>)
			or the corrected RVN (flag set to <code>false</code>) is written to the output.
			The value has meaning only for valid input data - for invalid input the cleaned input value is set to the output.
			<br/>
			Default value: <code>False</code>
        <br/>
			<!--Bližší informace o výstupech viz.<link id="ValidationOutputSettings">výstupy validačních algoritmů</link>.-->
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="RV_RVN_MISSING">
				A scoring flag indicating that the input RVN value is not filled in.
			</scoringKey>
			<scoringKey name="RV_RVN_INVALID_LENGTH">
				A scoring flag indicating that the input RVN is of an incorrect length.
			</scoringKey>
			<scoringKey name="RV_RVN_INVALID_DATE">
				A scoring flag indicating that the birth date from the RVN is invalid.
			</scoringKey>
			<scoringKey name="RV_RVN_INVALID_SURNAME">
				A scoring flag indicating that there is an incorrect character at the position reserved for the first character of the maiden name.
			</scoringKey>
			<scoringKey name="RV_RVN_INVALID_CHECK">
				A scoring flag indicating that the input RVN is invalid (content does not correspond to the sum check).
			</scoringKey>
			<scoringKey name="RV_GNDR_HINT_INVALID">
				A scoring flag indicating that the input gender is invalid (does not correspond to any of the
				values of the properties <code>Male Definition</code> or <code>Female Definition</code>).
			</scoringKey>
			<scoringKey name="RV_GNDR_HINT_MISSING">
			    A scoring flag indicating that input gender value is not filled in.
			</scoringKey>
			<scoringKey name="RV_GNDR_MISMATCH">
				A scoring flag indicating that the gender computed from the RVN is different from
				the input gender value.
            </scoringKey>
			<scoringKey name="RV_DATE_HINT_MISSING">
			   A scoring flag indicating that input birth date value is not filled in.
			</scoringKey>
			<scoringKey name="RV_DATE_MISMATCH">
			   A scoring flag indicating that birth date computed from the RVN is different from
				the input birth date value.
			</scoringKey>
			<scoringKey name="RV_RVN_GENERATED">
			  A scoring flag indicating that the input RVN is not filled in but a fake RVN is generated.
			</scoringKey>
			<scoringKey name="RV_RVN_NOT_GENERATED">
			  A scoring flag indicating that the input RVN is not filled in and a fake RVN cannot be generated.
			</scoringKey>
			<scoringKey name="RV_RVN_DAY_UNKNOWN">
		      A scoring flag indicating that the day component of the birth date stored in the RVN is not complete
				(set only for valid RVNs).
			</scoringKey>
			<scoringKey name="RV_RVN_MONTH_UNKNOWN">
				 A scoring flag indicating that the month component of the birth date stored in the RVN is not complete
				(set only for valid RVNs).
			</scoringKey>
		</scoring>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorDate">
    <description>
			Column value is random date from defined interval. If there are no formats given, output column type is DATETIME.
			If there is at least one format given, output column type is STRING and
			random date will be formatted to string by randomly chosen format from defined set.
		</description>
    <properties>
			<property name="minimumDate" type="date" required="true">
				Minimum date to generate.
			</property>
			<property name="maximumDate" type="date" required="true">
				Maximum date to generate.
			</property>
			<property name="formats" type="com.ataccama.dqc.tasks.generator.beans.ColumnGeneratorDateFormat[]" required="false">
				List of possible date formats.
			</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorPatternSet">
    <description>
			Column value is randomly generated from one pattern that is randomly chosen form defined set.
			If patterns have different frequencies, probability of patterns being used is <code>its frequency / sum of all frequencies</code>.
		</description>
    <properties>
			<property name="patterns" type="com.ataccama.dqc.tasks.generator.beans.ColumnGeneratorPatternSetItem[]" required="true">
				List of possible patterns.
			</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.generator.multi.IRandomRecordCountGeneratorConfig">
    <description>
			Strategy providing number of child records to be generated for one parent record. Different implementations has different providing strategies.
			If the implementation provides negative value, no child records are generated.
		</description>
    <properties>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.generator.RandomRecordGenerator">
    <introduction>Generates records with random values.</introduction>
    <description>
			This step generates records with defined columns filled with random values according to definition of column generators.
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="recordCount" type="integer" required="true">
				Number of records to generate.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.generator.IColumnGenerator[]" required="false">
				List of columns in generated records with definition how to generate random value.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.generator.RandomRecordMultiplicator">
    <introduction>Generates random number (according selected distribution strategy) of child records with random values for input parent records.</introduction>
    <description>
			This step reads parent records from <code>in</code> endpoint and for every record it generates N random child records.
			N is provided by strategy configured in <code>recordCountGenerator</code>.
			Child records contain all columns and values of their parent record with additional columns defined in <code>Columns</code>.
			Parent records are optionally output to <code>out_parent</code> endpoint.
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="Distribution strategy" type="com.ataccama.dqc.tasks.generator.multi.IRandomRecordCountGeneratorConfig" required="true">
				Strategy to get number of child records to generate per one parent record.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.generator.IColumnGenerator[]" required="false">
				List of added columns in generated child records with definition how to generate random value.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of child record in group. The identifier will be computed and
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.global.sampling.SamplingParams" name="com.ataccama.one.profiling.linear.simple.params.global.sampling.RandomSamplingParams">
    <introduction>Random Sampling Parameters</introduction>
    <properties>
			<property name="sampleProbability" type="float" required="true">Sample Probability</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorExternalStringSet">
    <description>
			Column value is one random string from defined set. Set is loaded from LKP file.
			If <code>Has Frequencies</code> is true, LKP file should have additional column with frequencies (type INTEGER).
		</description>
    <properties>
			<property name="fileName" type="string" required="true">Name of LKP file with possible string values.</property>
			<property name="hasFrequencies" type="boolean" required="true">
				If false every value has same probability. If true, probability of value is <code>its frequency / sum of all frequencies</code>.
			</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorStringSet">
    <description>
			Column value is one random string from defined set.
			If strings have different frequencies, probability of string being used as a value is <code>its frequency / sum of all frequencies</code>.
		</description>
    <properties>
			<property name="items" type="com.ataccama.dqc.tasks.generator.beans.ColumnGeneratorStringSetItem[]" required="true">
				List of possible string values.
			</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.IColumnGenerator" name="com.ataccama.dqc.tasks.generator.generators.ColumnGeneratorSin">
    <description>
			Column value is random valid Canadian SIN, Social Insurance Number.
		</description>
    <properties>
			<property name="groupDelimiter" type="string" required="false">
				Delimiter of SIN groups (three digits), default is <code>-</code>, example value is <code>406-152-744</code>.
			</property>
		<property name="name" type="string" required="true">Name of a given column. Must be unique.</property>
      <property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type for a given column.</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.frequency.RangeCfg">
    <description>
		Range specification node. Defines the number of intervals of values. The frequency will be counted
		for each interval instead of for each distinct value.
		<br/>If the the string data type is used, the property <code>Count</code> means the length of the string value prefix
		on which the counting is performed. This is the same as using the expression <code>substr(expression, 0, count)</code>.
		</description>
    <properties>
			<property name="count" type="integer" required="true">
			Interval count = histogram column count OR length of the string prefix.
			</property>
			<property name="from" type="string" required="false">
			Lower limit of interval definition. For DAY or DATETIME types the required formats are
			&quot;yyyy-MM-dd&quot; and &quot;yyyy-MM-dd HH:mm:ss&quot;, respectively.
			<br/>If the string data type is used, this property has no meaning and is ignored.
			</property>
			<property name="to" type="string" required="false">
			Upper limit of interval definition. For DAY or DATETIME types the required formats are
			&quot;yyyy-MM-dd&quot; and &quot;yyyy-MM-dd HH:mm:ss&quot;, respectively.
			<br/>If the string data type is used, this property has no meaning and is ignored.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.RangeCfg">
    <description>
		The range specification node. Specifies that frequency will be counted according to some range of values
		instead to value itself.<br/>
		For STRING data type, only <code>count</code> property has meaning and specifies length of value prefix used.<br/>
		For other types, except BOOLEAN, range bounds with number of intervals or interval length (and unit for DAY/DATETIME)
		can be specified.
		</description>
    <properties>
			<property name="count" type="integer" required="false">
			Interval count = histogram column count OR length of string prefix.
			</property>
			<property name="from" type="string" required="false">
			Lower limit of interval definition.
			For DAY/DATETIME types the required format is &quot;yyyy-MM-dd [HH:mm:ss]&quot;.
			</property>
			<property name="to" type="string" required="false">
			Upper limit of interval definition.
			For DAY/DATETIME types the required format is &quot;yyyy-MM-dd [HH:mm:ss]&quot;.
			</property>
			<property name="interval" type="integer" required="false">
			Interval length. When specified, properties count/from/to are not used.
			</property>
			<property name="intervalUnit" type="com.ataccama.profiling.results.model.RangeIntervalUnit" required="false">
			For DAY/DATETIME types, specified time unit to which the interval length is related.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.profiling.results.model.RangeIntervalUnit"/>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.model.evaluation.Rating">
    <description>
    		The rating value serves to evaluate the quality of addresses on the basis of comparison score values, etc.
    		Rating configuration is performed with the help of the following pseudo inputs:
    		<p align="justify">
    		<code>scoring</code>
			<ul>
				<li>scoring.best_score – score of the best proposal</li>
				<li>scoring.count_best – count of best address (with the lowest score)</li>
				<li>scoring.count_component – count of address components</li>
			</ul>  
			</p>
			<p align="justify">
			<code>out</code>
			<ul>
				<li>out.score - score of the best proposal</li>
				<li>out.explanation - explanation of the best proposal</li>
				<li>out.proposalCount - number of proposals to be rated (and possibly written out)</li>
				<li>out.foundProposalCount - number of proposals read during searching dictionary</li>
				<li>out.possibleProposalCount - number of proposals seen during searching dictionary</li>
				<li>out.possibleProposalsIndicator - indicates that the dictionary might contain more proposals to those seen</li>
			</ul>
			</p>
			<p align="justify">
			Aggregation functions are available in rating as well and the possible pseudo inputs there include (in addiction to those mentioned above)
			<code>pa</code> for proposal values, <code>expl</code> for explanation of these values 
			against the input and <code>unexpl</code> for unexplained (unmatched) input text.
			</p>   
    	</description>
    <properties>
	    	<property name="when" type="string" required="true">
	    		Determines when the rate value is written. 
	    	</property>
	    	<property name="rate" type="string" required="true">
	    		Integer expression whose result is assigned into rate column after accomplishing the <code>When</code> condition.
	    	</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.model.evaluation.RatingCase">
    <introduction>
    		Definition of a rating case. Each case has its own output column
    		(<code>Classification Column</code>) whereto store the result.
    	</introduction>
    <properties>
    		<property name="ratings" type="com.ataccama.dqc.tasks.addresses.dictionary.model.evaluation.Rating[]" required="false">
    			Definition of rating rules. All rules in the case are evaluated one by one possibly stopping
    			at the first one whose <code>when</code> expression evaluates to TRUE.
    		</property>
      		<property name="classificationColumn" type="string" required="true">
      			Name of the column (type INTEGER) where the classification of either 
      			input entity (endpoint out) or proposal (endpoint out_proposals) 
      			should be written. 
      		</property>
    	</properties>
  </class>
  <class name="com.ataccama.rdm.commons.types.RdmEditedState">
    <description>Available allowed changes that the imported records can cause.</description>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmSynchronizeStep">
    <introduction>Exports data from a selected RDM table.</introduction>
    <description>
            <p align="justify">RDM Extended Reader lets you import data from a selected RDM table, including historical values. The step has one input endpoint, which should be connected to a data source with one row that contains parameters for the step. The
                columns in the parameters input source can have arbitrary names; they will be mapped to the configuration fields in the step.
            </p>
            <p align="justify">Below is a sample parameters source:</p>
            <pre>
                username;password;timestamp;timestamp_increment
                betty;5ecurePassword;;2016-01-01 00:00:00
            </pre>
            <p align="justify">Leaving the timestamp column empty like in the example above is treated as &quot;now.&quot;</p>
        </description>
    <properties>
            <property name="atDate" type="string" required="true">The column in the parameters which contains (1) the date as of which to export data; (2) in case incremental timestamp is set, the end of the period for which to export data from the
                ALL_HISTORY mode.
            </property>
            <property name="columns" type="com.ataccama.rdm.manager.steps.RdmStepColumn[]" required="true">This is where you define which columns to export.</property>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="deduplicateIncrement" type="string" required="false">Controls the number of exported records in case one record has been changed and published multiple times in the selected period. The input data source attribute should
                contain either <code>true</code> or <code>false</code>. If true, only the latest publication will be exported. If false, all changes in the selected period will be exported.
            </property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="ignoreBusinessDates" type="string" required="false">Allows the regulation of the impact of business dates on the exported data (makes a difference in versioned tables only). The input data source attribute should contain
                either true or false. If true, Extended Reader will ignore records&#39; business dates when selecting records to export. If false, Extended Reader will place an additional constraint on the period, from which it will export records (per
                record).
            </property>
            <property name="incDate" type="string" required="false">The beginning of the period for which to export data from the ALL_HISTORY mode.</property>
            <property name="input" type="string" required="false">Name of the counterpart connected system table.</property>
            <property name="sqlFilter" type="string" required="false">The column that contains a condition limiting data selection. Condition example: &quot;id = &#39;19&#39;&quot;</property>
            <property name="tablename" type="string" required="true">Data is exported from this RDM table.</property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmGetDataStep$RdmGetDataStepData">
    <description>Data are exported from these tables.</description>
    <properties>
            <property name="columns" type="com.ataccama.rdm.manager.steps.RdmStepColumn[]" required="true">This is where you specify the columns to export.</property>
            <property name="name" type="string" required="true">Table name as specified in the model.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmImportHistoryStep$RdmHistoryImportStepColumnMapping">
    <description/>
    <properties>
            <property name="columnType" type="com.ataccama.rdm.commons.types.RdmStepColumnType" required="true">Defines the column type.</property>
            <property name="fromColumn" type="boolean" required="true">This column contains the beginning of the validity period.</property>
            <property name="groupingColumn" type="boolean" required="true">This column is (part of) the primary key. Several columns can form a primary key.</property>
            <property name="inColumn" type="string" required="true">Column name in the source data.</property>
            <property name="name" type="string" required="true">Column name in the RDM table.</property>
            <property name="toColumn" type="boolean" required="true">This column contains the end of the validity period.</property>
            <property name="type" type="com.ataccama.rdm.manager.steps.RdmStepDataType" required="true">Data type of the column in the source data.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmImportHistoryStep">
    <introduction>Imports records to an RDM table along with their historical values.</introduction>
    <description>
            <p align="justify">RDM History importer lets you import records to an RDM table along with their historical values. Compared to the Importer step, your source data should contain two additional columns: <code>d_from</code> and <code>d_to</code> column
                that together form the validity period of a given edit. Therefore, the source data can contain multiple values for the same row of data with different historical validity periods.
            </p>
            <p align="justify">The step has an optional output endpoint for reporting errors.</p>
            <p align="justify">After you run a plan that contains this step, make sure to restart the RDM web application configuration to ensure the changes are correctly synchronized. For details, see the article <a href="https://docs.ataccama.com/rdm/latest/configuration/how-to-deploy-an-rdm-web-app-configuration.html" target="_blank">How to Deploy an RDM Web App Configuration</a> in Ataccama documentation.</p>
        </description>
    <properties>
            <property name="columns" type="com.ataccama.rdm.manager.steps.RdmImportHistoryStep$RdmHistoryImportStepColumnMapping[]" required="true">This is where you map columns in the source data to the columns in the RDM table.</property>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="tablename" type="string" required="true">Data is imported to this table.</property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmImportDataStep$RdmImportDataStepData">
    <description>This is where you specify the tables into which the data is imported.</description>
    <properties>
            <property name="columns" type="com.ataccama.rdm.manager.steps.RdmStepColumnMapping[]" required="true">This is where you map columns in the source data to the columns in the RDM table.</property>
            <property name="name" type="string" required="true">Table name as specified in the model.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmImportStep$RdmImportStepColumnMapping">
    <description>This is where you map columns in the source data to the columns in the RDM table.</description>
    <properties>
            <property name="columnType" type="com.ataccama.rdm.commons.types.RdmStepColumnType" required="true">Defines RDM the column type.</property>
            <property name="inColumn" type="string" required="true">Column name in the source data.</property>
            <property name="name" type="string" required="true">Column name in the RDM table.</property>
            <property name="type" type="com.ataccama.rdm.manager.steps.RdmStepDataType" required="true">Data type of the column in the source data.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmImportStep">
    <introduction>Imports data to an RDM table.</introduction>
    <description>
            <p align="justify">RDM Importer is used for importing data to the specified RDM table.</p>
            <p align="justify">The step has an optional output endpoint for reporting errors.</p>
        </description>
    <properties>
            <property name="allowedEditStates" type="com.ataccama.rdm.commons.types.RdmEditedState[]" required="true">Determines the allowed changes that the imported records can cause.</property>
            <property name="columns" type="com.ataccama.rdm.manager.steps.RdmImportStep$RdmImportStepColumnMapping[]" required="true">This is where you map columns in the source data to the columns in the RDM table.</property>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="importTable" type="boolean" required="true">If checked, the data are imported to the corresponding table in the Import mode. This lets you check the imported data before moving it to the Edit mode and publishing.
            </property>
            <property name="incremental" type="boolean" required="true">Turns on the incremental mode: new records are imported, existing records not present in the input file are untouched, matched records are updated.</property>
            <property name="moveToEditAction" type="com.ataccama.rdm.commons.types.RdmMoveToEditActionType" required="false">Determines the edit state of the imported records.</property>
            <property name="tablename" type="string" required="true">Data is imported to this table.</property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmStartProcessStep">
    <introduction>Creates an instance ID of DB synchronization process.</introduction>
    <description>
            <p align="justify">RDM Integration Input is used in conjunction with other RDM steps for the synchronization of RDM data with external databases in a process spanning several plans. The step creates a shadow column <code>id</code> and populates it with a
                unique process identifier which can be consumed by the RDM Reader step. Part of the configuration is specifying the <strong>Process Name</strong>, which is the name of a DB synchronization defined under <strong>Synchronization &gt; Database
                </strong> in the RDM model project.
            </p>
            <p align="justify">The step has one input endpoint, which should be connected to a data source with one row that contains parameters for the step. The columns in the parameters input source can have arbitrary names; they will be mapped to the
                configuration fields in the step:
            </p>
            <ul>
                <li>
                    <strong>Username</strong>
                    (Optional: if you are passing credentials manually) - a valid RDM user with read rights to the table.
                </li>
                <li>
                    <strong>Password</strong>
                    (Optional: if you are passing credentials manually) - user password.
                </li>
                <li>
                    <strong>Type</strong>
                    - type of synchronization to perform:
                    <ul>
                        <li>
                            <strong>FULL</strong>
                            - exports all published data as seen on the date specified in the timestamp.
                        </li>
                        <li>
                            <strong>INCREMENT</strong>
                            - exports only the changes since the last synchronization until the date specified in the timestamp.
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Timestamp</strong>
                    - data are downloaded in the published state as of this date.
                </li>
            </ul>
            <p align="justify">Below is a sample parameters source:</p>
            <pre>
                username;password;type;timestamp
                betty;5ecurePassword;INCREMENT;2016-01-01 00:00:00
            </pre>
        </description>
    <properties>
            <property name="atDate" type="string" required="true">Mapping to the <code>timestamp</code> parameter.
            </property>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="name" type="string" required="true">Process name. One of the synchronization tasks defined under <strong>Synchronization &gt; Database</strong> in the RDM model project.
            </property>
            <property name="type" type="string" required="true">Mapping to the <code>type</code> parameter
            </property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmFinishProcessStep">
    <introduction>Reports back to RDM about the outcome of the process started by RDM Integration Input.</introduction>
    <description>
            <p align="justify">RDM Integration Output is used in conjunction with other RDM steps for the synchronization of RDM data with external databases in a process spanning several plans. The step reports back to RDM about the outcome of the process started
                by RDM Integration Input.
            </p>
            <p align="justify">The step has one input endpoint, which should be connected to a data source with one row that contains parameters for the step. Usually, this a text file generated in the first plan that starts the DB synchronization. In order to
                report errors during the sychronization process, the parameters source should also contain a column containing an error message.
            </p>
        </description>
    <properties>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="error" type="string" required="true">Mapping to the column where errors will be written.</property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="processId" type="string" required="true">Mapping to the column contain the ID of the process started by RDM Integration Input. Usually, it is <code>id</code>.
            </property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmMergeInputDataStep">
    <introduction>Used for importing data from external synchronized sytem to RDM.</introduction>
    <description>RDM Merge Importer imports data from external synchronized system (database). The step sends the data to the INPUTS mode, where the incoming data can be reviewed and merged with the published.</description>
    <properties>
            <property name="columns" type="com.ataccama.rdm.manager.steps.RdmMergeInputDataStep$RdmMergeInputDataStepColumnMapping[]" required="true">This is where you map columns from the connected system to the columns in the RDM table.</property>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="inputName" type="string" required="true">Name of the counterpart connected system table. The name consists of <code>&lt;system_name&gt;_&lt;table_name&gt;</code> as defined in the model project. Data are exported from this
                table.
            </property>
            <property name="tablename" type="string" required="true">Data are imported to this RDM table.</property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmMergeInputDataStep$RdmMergeInputDataStepColumnMapping">
    <description>
            <p align="justify">This is where you map columns from the connected system to the columns in the RDM table.</p>
            <p align="justify">It is important that the RDM generated primary is present in this configuration: <code>generatedPk</code>. See the table below.
            </p>
            <table border="1">
                <tr>
                    <th>Column Type</th>
                    <th>In</th>
                    <th>Name</th>
                    <th>Type</th>
                </tr>
                <tr>
                    <td>PRIMARY_KEY</td>
                    <td>rdm_primary_key</td>
                    <td>generatedPk</td>
                    <td>LONG_INTEGER</td>
                </tr>
            </table>
        </description>
    <properties>
            <property name="columnType" type="com.ataccama.rdm.commons.types.RdmStepColumnType" required="true">Defines the RDM column type.</property>
            <property name="inColumn" type="string" required="true">Column name in the connected system.</property>
            <property name="name" type="string" required="true">Column name in the RDM table.</property>
            <property name="type" type="com.ataccama.rdm.manager.steps.RdmStepDataType" required="true">Defines the column data type.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.commons.types.RdmMoveToEditActionType">
    <description>Available edit states of imported records.</description>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmGetDataStep">
    <introduction>Exports data from one or several RDM tables based on the process started by RDM Integration Input.</introduction>
    <description>
            <p align="justify">RDM Reader is used in conjunction with other RDM steps for the synchronization of RDM data with external databases in a process spanning several plans. The step reads data from the specified RDM tables based on the ID of the process
                started by RDM Integration Input.
            </p>
        </description>
    <properties>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="data" type="com.ataccama.rdm.manager.steps.RdmGetDataStep$RdmGetDataStepData[]" required="true">Tables.</property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="idColumn" type="string" required="true">Mapping to the column containing the ID of the process started by RDM Integration Input; usually, <code>id</code>.
            </property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmStepColumn">
    <description>The columns specified here will be exported.</description>
    <properties>
            <property name="columnType" type="com.ataccama.rdm.commons.types.RdmStepColumnType" required="true">Defines the RDM column type.</property>
            <property name="name" type="string" required="true">Column name as seen in the logical model definition.</property>
            <property name="type" type="com.ataccama.rdm.manager.steps.RdmStepDataType" required="true">Define the column data type.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmStepColumnMapping">
    <description>This is where you map columns in the source data to the columns in the RDM table.</description>
    <properties>
            <property name="columnType" type="com.ataccama.rdm.commons.types.RdmStepColumnType" required="true">Defines the column type.</property>
            <property name="inColumn" type="string" required="true">Column name in the source data.</property>
            <property name="name" type="string" required="true">Column name in the RDM table.</property>
            <property name="type" type="com.ataccama.rdm.manager.steps.RdmStepDataType" required="true">Data type of the column in the source data.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.commons.types.RdmStepColumnType">
    <description>Available RDM column types.</description>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmStepDataType">
    <description>Available RDM column data types.</description>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmImportDataStep">
    <introduction>Imports records to several RDM tables.</introduction>
    <description>RDM Tables Importer lets you import records to several RDM tables at the same time. Compared to the regular Reader step, Tables Importer locks all related tables of the table in which the data is imported: parents, children, and
            any other related entities. This is a highly recommended way of importing data.
        </description>
    <properties>
            <property name="allowedEditStates" type="com.ataccama.rdm.commons.types.RdmEditedState[]" required="true">Determines the allowed changes that the imported records can cause.</property>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="data" type="com.ataccama.rdm.manager.steps.RdmImportDataStep$RdmImportDataStepData[]" required="true">Tables.</property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="incremental" type="boolean" required="true">Turns on the incremental mode: new records are imported, existing records not present in the input file are untouched, matched records are updated.</property>
            <property name="moveToEditAction" type="com.ataccama.rdm.commons.types.RdmMoveToEditActionType" required="false">Determines the edit state of the imported records.</property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig">
    <description>Credentials for accessing RDM. When configured, these credentials override the credentials entered in the RDM web server connection.</description>
    <properties>
            <property name="password" type="string" required="true">User password.</property>
            <property name="username" type="string" required="true">Username.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.rdm.manager.steps.RdmWriteErrorsStep">
    <introduction>Reports errors on a record basis during DB synchronization.</introduction>
    <description>
            <p align="justify">RDM Write Errors is used in conjunction with other RDM steps for the synchronization of RDM data with external databases in a process spanning several plans. The step reports errors that occur when trying to synchronize RDM with the
                external system.
            </p>
            <p align="justify">The step expects two inputs:</p>
            <ul>
                <li>A list of errors associated with any particular record, which should contain the following columns (names are arbitrary; these columns are then mapped to the relevant step properties):</li>
                <ul>
                    <li>
                        <strong>RDM generated id of the record</strong>
                        - this id is usually captured by the Reader step together with other data as a column with the PRIMARY_KEY column type. Mapped to the <strong>Primary Key</strong> property.
                    </li>
                    <li>
                        <strong>History Change Number</strong>
                        - the column captured by the Reader step with the HCN column type. Mapped to the <strong>Publish Operation Number</strong> property.
                    </li>
                    <li>
                        <strong>Error string</strong>
                        - user populated column that contains the error message associated with the record. Mapped to the <strong>Errors</strong> property.
                    </li>
                </ul>
                <li>Parameters:</li>
                <ul>
                    <li>
                        <strong>Username</strong>
                        (Optional: if you are passing credentials manually) - a valid RDM user with read rights to the table.
                    </li>
                    <li>
                        <strong>Password</strong>
                        (Optional: if you are passing credentials manually) - user password.
                    </li>
                    <li>The id of the process started by RDM Integration Input. Mapped to the <strong>Process Id</strong> property.
                    </li>
                </ul>
            </ul>
            <p align="justify">Example of the list of errors input:</p>
            <table border="1">
                <tr>
                    <th>primary_key</th>
                    <th>hcn</th>
                    <th>error</th>
                </tr>
                <tr>
                    <td>123</td>
                    <td>5</td>
                    <td>Cannot write to DB: size limit exceeded</td>
                </tr>
                <tr>
                    <td>679</td>
                    <td>24</td>
                    <td>Cannot write to DB: wrong data type</td>
                </tr>
            </table>
            <p align="justify">Example of the parameters input (a text file):</p>
            <pre>
                username;password;id
                betty;5ecurePassword;12
            </pre>
        </description>
    <properties>
            <property name="credentials" type="com.ataccama.rdm.manager.steps.RdmUrlParametersConfig" required="false">Credentials to use when connecting to the web application. If not defined, the credentials defined in the server connection
                definition are used.
            </property>
            <property name="error" type="string" required="true">Mapping to the input column that contains the error strings.</property>
            <property name="hcn" type="string" required="true">Mapping to the input column that contains the History Change Number of the record.</property>
            <property name="id" type="string" required="false">Unique step identifier.</property>
            <property name="pk" type="string" required="true">Mapping to the input column that contains the RDM generated primary key of the record.</property>
            <property name="processId" type="string" required="true">Mapping to the parameters column that contains the ID of the process started by RDM Integration Input.</property>
            <property name="system" type="string" required="true">Name of the external synchronized system.</property>
            <property name="systemTable" type="string" required="true">Name of the table in the synchronized system.</property>
            <property name="url" type="string" required="true">Name of the server connection where the RDM app is accessible.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfReadFileVariablesTask">
    <introduction>Reads workflow variables from a source file</introduction>
    <description>Source file format and its mapping to variables depends on selected strategy (see File Variable Strategy). In case the limit set in <code>maxLines</code> is exceeded or the value cannot be converted to requested input data type, a warning is issued. Any lines beyond limit are ignored. Once the data is loaded, you can reuse the values across the workflow using the following syntax:<br/>
			<code>${ewfGetTaskVariable(&quot;task_name&quot;, &quot;key&quot;)}</code>
		</description>
    <properties>
			<property name="encoding" type="string" required="true">The encoding used in the source file.</property>
			<property name="fileVariableStrategy" type="com.ataccama.adt.variables.read.IFileVariables" required="true">Defines how the variables should be read from the source file.</property>
			<property name="maxLines" type="integer" required="true">The maximum number of lines that the task reads from file.</property>
			<property name="sourceFile" type="string" required="true">The file that should be read. Default extension: <code>.ewfv.</code>
      </property>
		</properties>
  </class>
  <class super="com.ataccama.adt.variables.read.IFileVariables" name="com.ataccama.adt.variables.read.ReadLinesFile">
    <introduction>Read workflow variables from lines in file.</introduction>
    <description>
			Each variable is read from a line of the source file. The line itself is fully used as variable&#39;s value, including all white-spaces except line-ending characters.
		</description>
    <properties>
			<property name="variables" type="com.ataccama.adt.variables.read.ReadLinesFile$VariableMapping[]" required="false">Variables</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.variables.read.IFileVariables" name="com.ataccama.adt.variables.read.ReadPropertyFile">
    <introduction>Read workflow variables from property file</introduction>
    <description>
			Source file contains properties defined as key-value pairs (syntax <code>property.key=property.value</code>) with one property per line. If a line is not correctly structured,
			the property is skipped. Using white-spaces in values is allowed at any position in the string, for example, <code>key= value</code> or <code>key=va lue</code>. If the source file
			contains duplicated keys, the task fails.
		</description>
    <properties>
			<property name="variables" type="com.ataccama.adt.variables.read.ReadPropertyFile$VariableMapping[]" required="false">Variables</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfReadSqlResultTask">
    <introduction>Reads data provided by a query to the variables defined by the mapping.</introduction>
    <description>Reads data provided by a query to the variables defined by the mapping. If the query returns no result set or the result set contains no rows, then the task fails. Otherwise, the first row of the returned result set is mapped to the variables using defined mappings. Therefore it is recommended to specify the query the way it returns only one specific row or use order by clause in order to retrieve rows in an intended order.</description>
    <properties>
			<property name="connectionName" type="string" required="true">Name of the database connection.</property>
			<property name="mapping" type="com.ataccama.adt.task.base.Mapping" required="false">Set of mappings describing mapping of the columns of the result set to the variables. Individual result rows are mapped to the defined mappings in the order they are defined.</property>
			<property name="query" type="string" required="true">Query to be executed to get the data; supports variable mappings.</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.variables.read.IFileVariables" name="com.ataccama.adt.variables.read.ReadWholeFile">
    <introduction>Read whole file and store it to workflow variable.</introduction>
    <description>
			Whole file is read and stored into a variable. Any lines beyond limit are discarded, i.e. not part of the variable value. Note that value may contain also line-ending characters (<code>&#39;\r&#39;</code> or <code>&#39;\n&#39;</code>).
		</description>
    <properties>
			<property name="variable" type="string" required="true">Variable name</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.reconcile.ReconcileAlgorithm">
    <introduction>Calculates aggregated accounting records based on value expressions built from input records.</introduction>
    <description>
    		The algorithms calculates accounting records based on input records and reconcile rules. 
    		Each rule defines a condition when it is to be applied, expression for getting
    		account number and amount value, string for account name (informative to make
    		rules better readable) and a flag whether the rule is to sum into a debit or credit
    		column.<br/>
    		The algorithm sends all records to its <code>out</code> endpoint and
    		produces a new record for each distinct account number with aggregated debit
    		and a new record for each distinct account number with aggregated credit  
    		to <code>outAccountingRecords</code>
    		endpoint. The records at this endpoint have the following format:<br/>
    		<ul>
    			<li>
          <code>account</code> : String (account number)</li>
    			<li>
          <code>debit</code> : Float</li>
    			<li>
          <code>credit</code> : Float</li>
    		</ul>
    		See also steps <strong>Compute General Ledger</strong> 
    		and <strong>Mapped Reconcile</strong>.
    	</description>
    <properties>
    		<property name="rules" type="com.ataccama.dqc.tasks.experimental.reconcile.ReconciliationRule[]" required="false">
    			Rules defining creating accounting records.
    		</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.reconcile.ReconciliationRule">
    <introduction>Reconciliation rule to group debit and credit values</introduction>
    <description>Determines which values of debit and credit to group</description>
    <properties>
    		<property name="amount" type="string" required="true">
    			Expression returning value of the amount for the record. The return type must be <code>float</code>.
    		</property>
     		<property name="when" type="string" required="true">
     			Condition that must evaluate to true to make this rule effective.
     		</property>
     		<property name="accountNumber" type="string" required="true">
     			Expression returning account number. The return type must be <code>string</code>.
     		</property>
     		<property name="accountName" type="string" required="false">
     			Optional account name to make the rules more readable.
     		</property>
     		<property name="debitCredit" type="string" required="true">
     			Flag indicating where to add the value. Possible values are
     			<code>debit</code> or <code>credit</code>.
     		</property>
     	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.RecordCounter">
    <introduction>Logs the run into a text file or the console.</introduction>
    <description>
		This step serves for counting (tracking) records in a data flow. The tracking is done by virtually splitting the
		records into batches of a specified size and tracing the exact event when the
		last record of each batch passed. This information is then sent to the specified output. This
		can be either a file, the standard output, or the standard error output.<br/>
		This step tracks processing time for each batch, and based on the
		settings (the properties <code>Report Perf Per Second</code>and <code>Report Perf Per Batch</code>)
		outputs this information in a given format. The step also outputs information about the
		start (event when the first record came) and the end of the processing (event when the
		activity of the step finished). The last record event is sent to the output
		at the moment the last batch is finished.
		<p align="justify">
        <strong>Note</strong>
      </p>
		<p align="justify">The Record Counter step is disabled by default. To enable it, use <code>-DenableRecordCounters=true</code>.</p>
		</description>
    <properties>
			<property name="append" type="boolean" required="true">
			Indicates whether the output should be appended at the end
			of the report file or to rewrite the report file.
			Default value is set.
			</property>
			<property name="batchSize" type="integer" required="true">
			Size of the virtual batch (in number of records) <br/>
			Default value: 100 000.
			</property>
			<property name="reportFileName" type="string" required="true">
			Filename for sending the output. It can be either a filename or \\stdout for standard
			output or \\stderr for standard error output or \\logger for logger output.
			</property>
			<property name="reportPerfPerBatch" type="boolean" required="true">
			Indicates whether to output the time needed to process each batch.
			<br/>Default value is set.
			</property>
			<property name="reportPerfPerSecond" type="boolean" required="true">
			Indicates whether to output the speed of processing in records per second.
			<br/>Default value is set.
			</property>
			<property name="timeStampFormat" type="string" required="false">
			Formating string for the timestamp. It is a string supported by the date formatter
			(SimpleDateFormat) from Java SE.
			<br/>Default value: <code>dd.MM.yyyy HH:mm:ss</code>
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property> 
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.rd.RecordDescriptorMerger$RecordDescriptor">
    <description>List of columns containing child Record Descriptors.</description>
    <properties>
          <property name="column" type="string" required="true">Input column for child Record Descriptor.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.rd.RecordDescriptorAggregateFilter">
    <introduction>The Record Descriptor Aggregate Filter step is used similarly to the <strong>Record Descriptor Filter</strong>, but instead of discarding records that don&#39;t meet criteria (which can be configured in the condition parameter), a condition is applied to them before they are passed down to the next step, helping in the cleansing and processing of data.</introduction>
    <description>
		</description>
    <properties>
          <property name="condition" type="string" required="false">Logical expression that controls record filtering. The expression allows usage of Aggregating functions.</property>
          <property name="id" type="string" required="false">Step identification string.</property>
          <property name="recordDescriptorColumn" type="string" required="true">Input and output column for Record Descriptor.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.rd.RecordDescriptorBuilder">
    <introduction>A record descriptor builder step is used to assign a record descriptor to specified data.</introduction>
    <description>While other steps that generate record descriptors have other primary functions, Record Descriptor Builder&#39;s sole purpose is generating record descriptors by specified expressions. A record descriptor builder step is used to assign a record descriptor to specified data.<br/>
        <p align="justify">
        <strong>Example Data</strong>
      </p>
        <table border="1">
		<th>
			<th>#</th>
          <th>Color</th>
          <th>Brakes</th>
          <th>Windows</th>
		</th>
		<tr>
			<td>1</td>
          <td>red</td>
          <td>smart</td>
          <td>electric</td>
		</tr>	
		<tr>
			<td>2</td>	 <td>blue</td>	 <td>analog</td>	 <td>manual</td>
		</tr>
		<tr>
			<td>3</td>	 <td>red</td>	 <td>smart</td>	 <td>manual</td>
		</tr>
		<tr>
			<td>4</td>	 <td>blue</td>	 <td>analog</td>	 <td>electric</td>
		</tr>
		<tr>
			<td>5</td>	 <td>red</td>	 <td>analog</td>	 <td>manual</td>
		</tr>
		<tr>
			<td>6</td>	 <td>blue</td>	 <td>smart</td>	 <td>electric</td>
		</tr>
		<tr>
			<td>7</td>	 <td>yellow	</td> <td>smart</td>	 <td>manual</td>
		</tr>
		<tr>
			<td>8</td>	 <td>yellow	</td> <td>analog</td>	 <td>manual</td>
		</tr>
		<tr>
			<td>9</td>	 <td>yellow	</td> <td>analog</td>	 <td>electric</td>
		</tr>
		</table>
		<p align="justify">
        <strong>We will demonstrate the following cases</strong>
      </p>
		<ul>
			<li>1. Group by <code>color</code>
        </li>
			<li>2. Group by <code>color=&#39;blue&#39;</code>
        </li>
			<li>3. Group by</li>
				<ul>	
					<li>a. <code>color</code>
          </li>
					<li>b. <code>brakes</code>
          </li>
				</ul>
		</ul>
		<p align="justify">
        <strong>Group by Color</strong>
      </p>
		<span>Grouping by the <code>color</code> column creates n groups, where n equals the number of unique values in the <code>color</code> column. Values in other columns are irrelevant.</span>
      <br/>
      <br/>
		<strong>Image images/record_descriptor_color.png</strong>
      <br/>
      <br/>
		<span>When using <code>color</code> as the Record Descriptor Builder expression, source data is sorted by color, and three Group ID&#39;s are created. A Group ID of 1 corresponds to records of one sort (in this case, color Yellow), Group ID 2 corresponds to records of another (Red), and Group ID 3 corresponds to Blue. Had there been more colors, in the column, they would be assigned unique Group ID&#39;s as well.</span>
      <br/>
		<span>The input data with generated record descriptors will look like follows (ordered by <code>record_descriptor_color</code>):</span>
      <br/>
      <br/>
		<table border="1">
		<th>
			<th>#</th>
          <th>color</th>
          <th>brakes</th>
          <th>windows</th>
          <th>record_descriptor_color</th>
		</th>
		<tr>
			<td>7</td>
          <td>yellow</td>
          <td>smart</td>
          <td>manual</td>
          <td>1:3:1</td>
		</tr>
		<tr>
			<td>8</td>
          <td>yellow</td>
          <td>analog</td>
          <td>manual</td>
          <td>1:3:2</td>
		</tr>
		<tr>
			<td>9</td>
          <td>yellow</td>
          <td>analog</td>
          <td>electric</td>
          <td>1:3:3</td>
		</tr>
		<tr>
			<td>1</td>
          <td>red</td>
          <td>smart</td>
          <td>electric</td>
          <td>2:3:1</td>
		</tr>
		<tr>
			<td>3</td>
          <td>red</td>
          <td>smart</td>
          <td>manual</td>
          <td>2:3:2</td>
		</tr>
		<tr>
			<td>5</td>
          <td>red</td>
          <td>analog</td>
          <td>manual</td>
          <td>2:3:3</td>
		</tr>
		<tr>
			<td>2</td>
          <td>blue</td>
          <td>analog</td>
          <td>manual</td>
          <td>3:3:1</td>
		</tr>
		<tr>
			<td>4</td>
          <td>blue</td>
          <td>analog</td>
          <td>electric</td>
          <td>3:3:2</td>
		</tr>
		<tr>
			<td>6</td>
          <td>blue</td>
          <td>smart</td>
          <td>electric</td>
          <td>3:3:3</td>
		</tr>
		</table>
		<p align="justify">
        <strong>Group by Color Blue</strong>
      </p>
        <span>Grouping by <code>color=&#39;blue&#39;</code> creates two groups: a group for records where the values in the <code>color</code> column are &quot;blue&quot; and all other records. Again, values in other columns are irrelevant.</span>
      <br/>
      <br/>
		<strong>Image images/record_descriptor_color_blue.png</strong>
      <br/>
      <br/>
		<span>The input data with generated record descriptors will look like follows (ordered by <code>record_descriptor_color_blue</code>):</span>
      <br/>
      <br/>
		<table border="1">
		<th>
		<th>#</th>
          <th>color</th>
          <th>brakes</th>
          <th>windows</th>
          <th>record_descriptor_color_blue</th>
		</th>
			<tr>
          <td>2</td>
          <td>blue</td>
          <td>analog</td>
          <td>manual</td>
          <td>1:3:1</td>
        </tr>
			<tr>
          <td>4</td>
          <td>blue</td>
          <td>analog</td>
          <td>electric</td>
          <td>1:3:2</td>
        </tr>
			<tr>
          <td>6</td>
          <td>blue</td>
          <td>smart</td>
          <td>electric</td>
          <td>1:3:3</td>
        </tr>
			<tr>
          <td>1</td>
          <td>red</td>
          <td>smart</td>
          <td>electric</td>
          <td>2:6:1</td>
        </tr>
			<tr>
          <td>3</td>
          <td>red</td>
          <td>smart</td>
          <td>manual</td>
          <td>2:6:2</td>
        </tr>
			<tr>
          <td>5</td>
          <td>red</td>
          <td>analog</td>
          <td>manual</td>
          <td>2:6:3</td>
        </tr>
			<tr>
          <td>7</td>
          <td>yellow</td>
          <td>smart</td>
          <td>manual</td>
          <td>2:6:4</td>
        </tr>
			<tr>
          <td>8</td>
          <td>yellow</td>
          <td>analog</td>
          <td>manual</td>
          <td>2:6:5</td>
        </tr>
			<tr>
          <td>9</td>
          <td>yellow</td>
          <td>analog</td>
          <td>electric</td>
          <td>2:6:6</td>
        </tr>
		</table>
		<p align="justify">
        <strong>Group by Color and Brakes</strong>
      </p>
		<span>Grouping by <code>color</code> and <code>brakes</code> (two grouping rules) creates a separate group for each unique color/brakes combination. The values in the windows column are irrelevant.</span>
      <br/>
      <br/>
		<strong>Image images/record_descriptor_color_brakes.png</strong>
      <br/>
      <br/>
		<span>The input data with generated record descriptors will look like follows (ordered by <code>record_descriptor_color_brakes</code>):</span>
      <br/>
      <br/>
		<table border="1">
		<th>
			<th>#</th>
          <th>color</th>
          <th>brakes</th>
          <th>windows</th>
          <th>record_descriptor_color_brakes</th>
		</th>
		<tr>
          <td>5</td>
          <td>red</td>
          <td>analog</td>
          <td>manual</td>
          <td>1:1:1</td>
        </tr>
		<tr>
          <td>6</td>
          <td>blue</td>
          <td>smart</td>
          <td>electric</td>
          <td>2:1:1</td>
        </tr>
		<tr>
          <td>8</td>
          <td>yellow</td>
          <td>analog</td>
          <td>manual</td>
          <td>3:2:1</td>
        </tr>
		<tr>
          <td>9</td>
          <td>yellow</td>
          <td>analog</td>
          <td>electric</td>
          <td>3:2:2</td>
        </tr>
		<tr>
          <td>7</td>
          <td>yellow</td>
          <td>smart</td>
          <td>manual</td>
          <td>4:1:1</td>
        </tr>
		<tr>
          <td>1</td>
          <td>red</td>
          <td>smart</td>
          <td>electric</td>
          <td>5:2:1</td>
        </tr>
		<tr>
          <td>3</td>
          <td>red</td>
          <td>smart</td>
          <td>manual</td>
          <td>5:2:2</td>
        </tr>
		<tr>
          <td>2</td>
          <td>blue</td>
          <td>analog</td>
          <td>manual</td>
          <td>6:2:1</td>
        </tr>
		<tr>
          <td>4</td>
          <td>blue</td>
          <td>analog</td>
          <td>electric</td>
          <td>6:2:2</td>
        </tr>
		</table>
</description>
    <properties>
          <property name="alreadySorted" type="boolean" required="true">Check indicating that input records are already sorted by columns defined in <code>Partition By</code> and don&#39;t need to be sorted. Use with caution, step logs the 							inconsistencies, however the output might contain invalid Record Descriptor values when the input is in wrong order.</property>
          <property name="id" type="string" required="false">Step identification string.</property>
          <property name="outputRecordDescriptorColumn" type="string" required="true">Output column for Record Descriptor.</property>
          <property name="partitionBy" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="true">Sort column/key definition; column list in <code>orderBy</code>.</property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.rd.RecordDescriptorFilter">
    <introduction>The Record Descriptor Filter step is used to filter specified records that meet criteria described in the condition field, and filters those that do not. </introduction>
    <description>
		<span>An example use case would be to filter a record containing columns with invalid or repeating data.</span>
		<p align="justify">
        <strong>Example</strong>
      </p>
		<span>With the following input data</span>
      <br/>
      <br/>
		<table border="1">
		<th>
		<th>#</th>
          <th>Color</th>
          <th>Shape</th>
          <th>Size</th>
          <th>Record Descriptor</th>
		</th>
		<tr>
		<td>1</td>
          <td>Red</td>
          <td>Round</td>
          <td>Big</td>
          <td>2:3:1</td>
		</tr>
		<tr>
		<td>2</td>
          <td>Red</td>
          <td>Round</td>
          <td>Small</td>
          <td>2:3:2</td>
		</tr>
		<tr>
		<td>3</td>
          <td>Red</td>
          <td>Square</td>
          <td>Small</td>
          <td>2:3:3</td>
		</tr>
		<tr>
		<td>4</td>
          <td>Blue</td>
          <td>Square</td>
          <td>Small</td>
          <td>4:3:1</td>
		</tr>
		<tr>
		<td>5</td>
          <td>Blue</td>
          <td>Square</td>
          <td>Big</td>
          <td>4:3:2</td>
		</tr>
		<tr>
		<td>6</td>
          <td>Blue</td>
          <td>Round</td>
          <td>Big</td>
          <td>4:3:3</td>
		</tr>
		</table>
		<br/>
      <span>Filtering <code>Size = &#39;Small&#39;</code> would result in this output:</span>
      <br/>
      <br/>
		<table border="1">
		<th>
		<th>#</th>
          <th>Color</th>
          <th>Shape</th>
          <th>Size</th>
          <th>Record Descriptor</th>
		</th>
		<tr>
		<td>2</td>
          <td>Red</td>
          <td>Round</td>
          <td>Small</td>
          <td>2:3:2</td>
		</tr>
		<tr>
		<td>3</td>
          <td>Red</td>
          <td>Square</td>
          <td>Small</td>
          <td>2:3:3</td>
		</tr>
		<tr>
		<td>4</td>
          <td>Blue</td>
          <td>Square</td>
          <td>Small</td>
          <td>4:3:1</td>
		</tr>
		</table>
		</description>
    <properties>
 		  <property name="condition" type="string" required="false">Logical expression that controls record filtering.</property>
          <property name="id" type="string" required="false">Step identification string.</property>
          <property name="recordDescriptorColumn" type="string" required="true">Input and output column for <strong>Record Descriptor</strong>.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.merge.RdJoin">
    <introduction>Can be used for quick join of two data flow, where the data flow contains parent key and child
      record descriptor (e.g. after XML Reader step).</introduction>
    <properties>
          <property name="childRecordDescriptor" type="string" required="true">Input column for child Record Descriptor.</property>
          <property name="columnDefinitions" type="com.ataccama.dqc.tasks.merge.ColumnDefinition[]" required="false"/>
          <property name="id" type="string" required="false">
			Step identification string.
			</property>
          <property name="joinMode" type="com.ataccama.dqc.tasks.merge.RdJoin$JoinMode" required="true">
          - <code>PARENT</code> - Custom aggregations of children data are done for each parent record.<br/>
          - <code>CHILD</code> - Each child record is enriched with data from parent record with matching key.<br/>
          </property>
          <property name="outer" type="boolean" required="true">
          	Step puts all records to the output (similarly to SQL outer join).
          </property>
          <property name="parentKey" type="string" required="true">Parent key for join</property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.rd.RecordDescriptorMerger">
    <introduction>Step merges record descriptor values from multiple columns into one valid <strong>Record Descriptor</strong>.</introduction>
    <description>
			Usage of this step is after the input records were multiplied by a Multiplicative step and then multiplied again by another one or more steps and they have multiple different <strong>Record Descriptors</strong>.
			The output of this step is a single <strong>Record Descriptor</strong> value based on the input <strong>Record Descriptors</strong>, which reflects	groups based on the input <strong>Record Descriptors</strong>.<br/>
			<p align="justify">
        <strong>Example</strong>
      </p>
			<table border="1">
				<th>
					<th>Outer Record Descriptor</th>
					<th>Inner Record Descriptor</th>
					<th>Output Record Descriptor</th>
				</th>
				<tr>
					<td>1:1:1</td>
					<td>1:2:1</td>
					<td>1:2:1</td>
				</tr>
				<tr>
					<td>1:1:1</td>
					<td>1:2:2</td>
					<td>1:2:2</td>
				</tr>
				<tr>
					<td>2:2:1</td>
					<td>2:3:1</td>
					<td>2:5:1</td>
				</tr>
				<tr>
					<td>2:2:1</td>
					<td>2:3:2</td>
					<td>2:5:2</td>
				</tr>
				<tr>
					<td>2:2:1</td>
					<td>2:3:3</td>
					<td>2:5:3</td>
				</tr>
				<tr>
					<td>2:2:2</td>
					<td>3:2:2</td>
					<td>2:5:4</td>
				</tr>
				<tr>
					<td>2:2:2</td>
					<td>3:2:1</td>
					<td>2:5:5</td>
				</tr>
			</table>
		</description>
    <properties>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="innerRecordDescriptors" type="com.ataccama.dqc.tasks.rd.RecordDescriptorMerger$RecordDescriptor[]" required="false">Columns containing inner Record Descriptors to be merged.</property>
			<property name="outerRecordDescriptorColumn" type="string" required="true">Outer record descriptor describing the group as whole.</property>
			<property name="outputRecordDescriptorColumn" type="string" required="true">Output column for Record Descriptor.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.rd.RecordDescriptorPartitioner">
    <introduction>The Record Descriptor Partitioner Step is used to extract existing record descriptor data into another record descriptor column.</introduction>
    <description>
		<p align="justify">
        <strong>Example</strong>
      </p>
		<span>With the following input data</span>
      <br/>
      <br/>
		<table border="1">
			<th>
				<th>#</th>
          <th>Color</th>
          <th>Shape</th>
          <th>Size</th>
          <th>Record Descriptor</th>
			</th>
			<tr>
				<td>1</td>
          <td>Red</td>
          <td>Square</td>
          <td>Small</td>
          <td>1:3:3</td>
			</tr>
			<tr>
				<td>2</td>
          <td>Red</td>
          <td>Round</td>
          <td>big</td>
          <td>1:3:1</td>
			</tr>
			<tr>
				<td>3</td>
          <td>Red</td>
          <td>Round</td>
          <td>Small</td>
          <td>1:3:2</td>
			</tr>
			<tr>
				<td>4</td>
          <td>Blue</td>
          <td>Square</td>
          <td>Small</td>
          <td>2:2:1</td>
			</tr>
			<tr>
				<td>5</td>
          <td>Blue</td>
          <td>Square</td>
          <td>Big</td>
          <td>2:2:2</td>
			</tr>
			<tr>
				<td>6</td>
          <td>Blue</td>
          <td>Round</td>
          <td>Big</td>
          <td>2:3:3</td>
			</tr>
		</table>
		<br/>
      <span>Partitioning by shape would remove all small sizes from the current record descriptor and output the following: </span>
      <br/>
      <br/>
			<table border="1">
			<th>
				<th>#</th>
          <th>Color</th>
          <th>Shape</th>
          <th>Size</th>
          <th>Record Descriptor</th>
          <th>Partitioned Record Descriptor</th>
			</th>
			<tr>
				<td>1</td>
          <td>Red</td>
          <td>Square</td>
          <td>Small</td>
          <td>1:3:3</td>
          <td>1:1:1</td>
			</tr>
			<tr>
				<td>2</td>
          <td>Red</td>
          <td>Round</td>
          <td>big</td>
          <td>1:3:1</td>
          <td>2:2:1</td>
			</tr>
			<tr>
				<td>3</td>
          <td>Red</td>
          <td>Round</td>
          <td>Small</td>
          <td>1:3:2</td>
          <td>2:2:2</td>
			</tr>
			<tr>
				<td>4</td>
          <td>Blue</td>
          <td>Square</td>
          <td>Small</td>
          <td>2:2:1</td>
          <td>3:2:1</td>
			</tr>
			<tr>
				<td>5</td>
          <td>Blue</td>
          <td>Square</td>
          <td>Big</td>
          <td>2:2:2</td>
          <td>3:2:2</td>
			</tr>
			<tr>
				<td>6</td>
          <td>Blue</td>
          <td>Round</td>
          <td>Big</td>
          <td>2:3:3</td>
          <td>4:1:1</td>
			</tr>
		</table>
		</description>
    <properties>
          <property name="id" type="string" required="false">Step identification string.</property>
          <property name="inputRecordDescriptorColumn" type="string" required="true">Input column for Record Descriptor.</property>
          <property name="outputRecordDescriptorColumn" type="string" required="true">Output column for Record Descriptor.</property>
          <property name="partitionBy" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="false">List of columns containing key for partitioning input Record Descriptor.</property>
        </properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.common.group.AbstractGroupingStrategy" name="com.ataccama.dqc.tasks.common.group.RecordDescriptorStrategy">
    <properties>
			<property name="recordDescriptorColumn" type="string" required="true">
				Specifies string column where record descriptor is stored.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.dqi.RecordsOutFilterType"/>
  <class name="com.ataccama.dqc.tasks.io.soap.RecordsOutput">
    <description>
			Defines a single output end point where source for rows are elements
			returned by
			the
			<code>XPath Expression</code>
			property.
		</description>
    <properties>
			<property name="out" type="string" required="true">
				Name of the
				output end point.
			</property>
			<property name="rowsRootXPath" type="string" required="true">
				This is the XPATH which selects elements from the input XML element
				into this
				<code>RecordsOutput</code>
				and creates from each element one row.
			</property>
			<property name="recordsOutputs" type="com.ataccama.dqc.tasks.io.soap.RecordsOutput[]" required="false">
				Child
				output end points.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of additional columns that are not extracted from the<br/>
				XML data and are added to the record format to the columns defined by <code>Attributes</code> property.<br/>
				Default expressions can access parent output end points using their names. They also can access input end point.
			</property>
			<property name="attributes" type="com.ataccama.dqc.tasks.io.xml.reader.Attribute[]" required="true">
				Columns for this end point.
			</property>
			<property name="appendInputColumns" type="boolean" required="true">
				All columns on
				the input are appended to this output end point.
			</property>
			<property name="recordDescriptor" type="string" required="false">
				Record
				descriptor is written to this column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.reader.RecordsOutput">
    <description>
			Defines a single output end point where source for rows are elements returned by
			the <code>XPath Expression</code> property.
		</description>
    <properties>
		 	<property name="out" type="string" required="true">
		 	Name of the output end point.
		 	</property>
		 	<property name="rowsRootXPath" type="string" required="true">
		 	This is the xpath which selects elements from the input xml element into this
		 	<code>RecordsOutput</code> and creates from each element one row. If the <code>RecordsOutput</code>
		 	is at root level then <code>XPath Expression</code> is only very simplified version of the xpath which
		 	can be only sequence of element names separated by slash (eg. root/rows/row).
		 	</property>
			<property name="recordsOutputs" type="com.ataccama.dqc.tasks.io.xml.reader.RecordsOutput[]" required="false">
			Child output end points.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of additional columns that are not extracted from the xml data and
				are added to the record format to the columns defined by <code>Attributes</code> property.
			</property>
			<property name="attributes" type="com.ataccama.dqc.tasks.io.xml.reader.Attribute[]" required="true">
			Columns for this end point.
			</property>
		 	<property name="schemaFile" type="string" required="false">
		 	Each node which is the source for each row can be validated using xsd file given by this property.
		 	The validation on the top level for whole document is not supported because it would be slow.
		 	</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <code>Record Descriptor</code>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <code>Parent Id Column</code> is defined.
		 	</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.redshift.reader.RedshiftReader">
    <introduction>Reads data from a Redshift data source.</introduction>
    <description>
			<p align="justify">
				This step reads data records from the results of a specified query executed on a specified Redshift database table.
			</p>

			<p align="justify">
				If the parameter <code>Distributed</code> is checked, this step loads data to
				<a href="https://aws.amazon.com/s3/" target="_blank">Amazon S3</a> when running on cluster
				by calling LOAD command and then reads the data from there in distributed fashion.
				Data from Amazon S3 is NOT automatically deleted.
			</p>
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="afterScript" type="string" required="false">
				SQL instructions representing the script to be executed in the database after reading is done.
			</property>
			<property name="beforeScript" type="string" required="false">
				SQL instructions representing the script to be executed in the database before reading.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.io.jdbc.read.JdbcReaderColumn[]" required="true">
				Contains definitions of columns which will be constructed from the JDBC query result set.
			</property>
			<property name="dataSourceName" type="string" required="true">
				Name of the DataSource. DataSource groups together information regarding
				access to the database, such as: URL, driver name, username and password.
				See the <strong>Data Source description</strong> for more details.
			</property>
			<property name="queryFileEncoding" type="string" required="false">
				Encoding of the query file if such a file is used.
			</property>
			<property name="queryFileName" type="string" required="false">
				When defined, it represents the name of the file that contains the query to execute.
				When this attribute is filled in, the attribute <code>Query String</code> must not contain
				any value, otherwise a query conflict error is reported.
			</property>
			<property name="queryString" type="string" required="true">
				SQL query to execute on the data source to obtain input data records. Only selection operations are supported.
			</property>
			<property name="s3ResourceName" type="string" required="true">
				Reference to Amazon S3 Resource in <strong>runtime configuration</strong>.
				If this property is set, the step will use <a href="https://aws.amazon.com/s3/" target="_blank">Amazon S3</a>
				to UNLOAD the data when running on cluster.
			</property>
			<property name="temporaryFolder" type="string" required="true">
				The temporary folder - folder on S3 - relatively to the resource address.
				It is the folder where the UNLOADed data should be stored.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.redshift.writer.RedshiftWriter">
    <introduction>Writes data to a Redshift (database) data source.</introduction>
    <description>
			<p align="justify">
			The standard output for this step are data records written to a database table.
			Saving to the database is done utilizing the SQL INSERT command. All data is written in
			batches to speed up the process.
			</p>
			<p align="justify">
				For better error management, the parameter <code>Error Handler</code> handles
				error situations when writing to the DB. If this property is defined then the
				step has one mandatory output, <code>err_out</code>. Otherwise it has no
				output.
			</p>
			<p align="justify">
				If the parameter <code>Distributed</code> is checked, this step saves data to
				<a href="https://aws.amazon.com/s3/" target="_blank">Amazon S3</a> when running on cluster
				and then calls COPY command to copy the saved data to Redshift database.
			</p>
			<p align="justify">
			Important notes:
			</p>
			<ul>
				<li>
					  When the <code>Error Handler</code> property is defined, the step tries to handle
					  writing problems with the database. When it is not possible to handle them (for
					  example, when the driver used does not support all required functionality) it falls
					  back to processing as without <code>Error Handler</code> defined. This usually
					  ends up with the exception in case of writing problems, while data written to
					  the database depends on the error strategy used. Consult the
					  <code>Error Handler</code> property description for more detail on this.
				</li>
				<li>
					The ROLLBACK and ROLLBACK_AND_STOP strategies should be used only with
					<code>Commit Size</code> set	to 0 to ensure data integrity. In that case are all
					data are rolled back (since all data comes in a single commit) when an error occurs or
					all data are written to the database when no error has occurred.
				</li>
				<li>
					If there are many invalid entries in the input and <code>Error Handler</code>
					is defined, writing may take significantly more time (although it is heavily dependent on the database used).
					When writing data without errors to the DB, there should not be a significant time difference between errorHandler-defined and
       				errorHandler-disabled configurations.
				</li>
			</ul>
		</description>
    <properties>
			<property name="afterScript" type="string" required="false">
				SQL instructions representing the script to be executed in the database after writing is done.
			</property>
			<property name="batchSize" type="integer" required="true">
			    Number of elements to be used in the batch. The minimum size for a batch is 0 (no batching).
				The maximum batch size is currently limited to 3000 rows. When the commit size is smaller
				than <code>Batch Size</code> then <code>Batch Size</code> is set to the value of
				<code>Commit Size</code>.
			</property>
			<property name="beforeScript" type="string" required="false">
				SQL instructions representing the script to be executed in the database before writing.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
				A list of columns to be written to the database. Note that column names should be defined
				in an &quot;unquoted&quot; form, even if they contain special characters or represents SQL reserved word.
				Contrary to the <code>Table Name</code> property, the column names are quoted automatically
				as needed.
			</property>
			<property name="commitSize" type="integer" required="true">
				Gives the number of elements after which the commit should be performed. The currently opened
				batch is executed and the whole current transaction is committed. The commit size is
				not limited. When set to 0, the whole writing process will be sent as single-commit
				transaction.
			</property>
			<property name="dataSourceName" type="string" required="true">
				Name of the DataSource. The DataSource groups together information regarding
				access to the database, such as: URL, driver name, username and password.
				See the <strong>Data Source description</strong> for more details.
			</property>
			<property name="errorHandler" type="com.ataccama.dqc.io.jdbc.writer.ErrorHandler" required="false">
			   Error handler which defines the behavior of the step in case of writing problems.
			   When this property is set the step has one mandatory output, <code>out_err</code>,
			   where the invalid rows are sent to. The format of this output is the same as that of the input with one
			   additional textual column named as specified by the property <code>errorFieldName</code>, where
			   the cause of problem as reported by the database are written.
			</property>
			<property name="tableName" type="string" required="true">
				Name of the table to write data to. This table must exist in the given database and must
				be writable for the given user.<br/>
				<strong>Note</strong> that it is necessary to enclose individual table name parts with quotes when:<br/>
				- given part contains special character(s) (according to the SQL specification)<br/>
				- given part matches SQL reserved word (according to the SQL specification)<br/>
				It&#39;s because table name can represent structured value following the catalog.schema.table
				pattern and therefore it&#39;s on the user to specify and quote individual parts when needed.<br/>
				<strong>Example:</strong> having catalog &#39;test:catalog&#39; with schema &#39;User&#39; and table &#39;table.1&#39;, the correct
				value is <code>&quot;test:catalog&quot;.&quot;User&quot;.&quot;table.1&quot;</code> (because both &#39;table.1&#39; and &#39;test:catalog&#39;
				contains special characters and &#39;User&#39; is an SQL reserved word).<br/>
				<strong>Warning:</strong> quoted parts should exactly represent DB object name since many DB&#39;s are case sensitive
				when dealing with quoted names.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				Specifies whether to write out all columns as defined in the input format. This
				attribute is exclusive to column definitions. If this value is set to on, then there
				must be no columns defined in the columns element, otherwise an error is reported.
			</property>
			<property name="s3ResourceName" type="string" required="true">
				Reference to Amazon S3 Resource in <strong>runtime configuration</strong>.
				If this property is set, the step will use <a href="https://aws.amazon.com/s3/" target="_blank">Amazon S3</a>
				to COPY the data from when running on cluster.
			</property>
			<property name="temporaryFolder" type="string" required="true">
				The temporary folder - folder on S3 - relatively to the resource address.
				It is the folder where the data from COPY command should be stored.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.rjoin.RefMatchRule">
    <description>
			Rule specifying whether input and reference records are matched.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of this rule. This can be stored into output record by using special
				dot field <code>result.ruleName</code>.
			</property>
			<property name="expression" type="string" required="true">
				Boolean expression telling whether reference record is successfully matched with input record.
				The expression uses dot-sources <code>ref</code>, <code>measures</code>, <code>query</code> and
				unnamed input source.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.rjoin.RefOutputColumn">
    <description>
			Defines output column.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of the column.
			</property>
			<property name="expression" type="string" required="true">
				Column value expression. Can be aggregating and uses several record dot-sources: input record as
				default unnamed source, matched reference record as <code>ref</code> source, matching measures <code>measures</code>
				source and special <code>result</code> source. All of them can be aggregated for all matched reference records.
			</property>
			<property name="noMatchExpression" type="string" required="false">
				Expression used when no reference record is matched.
				<br/>Default: <code>Expression</code> is used with &quot;fake&quot; empty reference record.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.rjoin.RefSourceConfig">
    <introduction>
			Specifies where the reference data is stored.
		</introduction>
  </class>
  <class name="com.ataccama.dqc.addresses.commons.model.etalon.ReferenceDataDefinition">
    <properties>
	        <property name="components" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponent[]" required="false">
	        	Set of components this reference data is configured with.
	        </property>
	        <property name="folder" type="string" required="true">
	        	Name of the folder where the reference data should be written. If the folder doesn&#39;t exist, 
	        	the generator can create it.
	        </property>
      		<property name="supportingVectors" type="com.ataccama.dqc.addresses.commons.model.SupportingVectorDefinition[]" required="false">
      			Definition of all supporting vectors to use or generate.
      		</property>
      		<property name="primaryKeyComponentId" type="string" required="true">
      			Id of the component holding primary key.
      		</property>
      		<property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.abp.parser.ITokenizerConfig" required="true">
      			Definition of tokenization input text to words in order to get appropriate word boundaries.<br/>
      			Default value: tokens are defined as groups of either letters or digits.
      		</property>
      		<property name="matchingValue" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="true">
      			Default definition of matching value for this reference data components.
      		</property>
      		<property name="createWordLookups" type="boolean" required="true">
      		    Indicates to create lookups used by 
      		    <strong>Word-aware method</strong>
      		</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.rjoin.RefJoin">
    <introduction>
			Matches records with reference data. Similar to Lookup step, but uses more complex search criteria.
		</introduction>
    <description>
			<p align="justify">
			The reference source contains records indexed by several keys. The definition of keys (name, components, condition)
			is stored in source metadata.
			This step uses key definition for generating values searched in index. Each key value is calculated
			exactly as specified in metadata using mapping from input columns to columns used in key components.
			</p>
			<p align="justify">
			Each input records and its search keys can fetch several records from reference source. All records having at least one
			key from set are fetched. These records are accessed through dot-source named <code>ref</code> in configured expressions.
			Fetching reference records can be limited by specifying maximal number of appropriate records found by each key. <em>For example
			for searching based on personal name it would be accepted max. 50 records to eliminate huge (and actually unusable)
			load caused by too common names as &quot;John&quot;.</em>
			</p>
			<p align="justify">
			Each pair of the input record and fetched reference record is then tested using specified matching rules. Records satisfying
			at least one rule are accepted for output. Again, maximal number of output records for one input can be specified and only
			the best records (based on selection criterion) are accepted.
			</p>
			<p align="justify">
			Fetched, matched and selected reference records form output group of records calculated by output expressions.
			The expressions can use input record, reference record or some metadata values accessed by <code>result</code> dot-source
			and can aggregate values in group.
			</p>
			<p align="justify">
			There are two special dot-sources used in expressions:
				<table border="1">
					<tr>
            <td nowrap="nowrap">
              <term>query</term>
            </td>
            <td>
              <definition>
							Applicable in matching and selection rules, i.e. during selection from all fetched records. 
							Contains columns:
							<br/>
                <code>pk</code> - reference record&#39;s primary key 
							<br/>
                <code>ruleName</code> - name of satisfied matching rule
							<br/>
                <code>count</code> - number of all fetched reference records 
						</definition>
            </td>
          </tr>
					<tr>
            <td nowrap="nowrap">
              <term>result</term>
            </td>
            <td>
              <definition>
							Applicable in final generating of output records, in outputColumn expression.
							Contains columns:
							<br/>
                <code>pk</code> - reference record&#39;s primary key 
							<br/>
                <code>ruleName</code> - name of satisfied matching rule
							<br/>
                <code>count</code> - number of matched reference records 
							<br/>
                <code>order</code> - record&#39;s order in matched group
							<br/>
                <code>recordDescriptor</code> - record descriptor  
						</definition>
            </td>
          </tr>
				</table>
			</p>
		</description>
    <properties>
			<property name="refSource" type="com.ataccama.dqc.rjoin.RefSourceConfig" required="true">
				Specifies where the reference data is stored.
			</property>
			<property name="matchKeys" type="com.ataccama.dqc.rjoin.RefJoin$MatchKey[]" required="true">
				List of keys used for fetching of records from reference data.
			</property>
			<property name="keyColumnMappings" type="com.ataccama.dqc.rjoin.RefJoin$KeyColumnMapping[]" required="true">
				List of expressions assigned to reference data columns.
			</property>
			<property name="matchingRules" type="com.ataccama.dqc.rjoin.RefMatchRule[]" required="false">
				List of matching rules used by selecting records fetched from reference data.
			</property>
			<property name="maximumMatched" type="integer" required="false">
				Maximal number of records selected for one input record.
				When used, <code>Selection Rules</code> must be configured to determine how select best records.
				<br/>When not specified or &lt;= 0 (default), all matched records are valid.
			</property>
			<property name="selectionRules" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines order and comparator of selected records. The expressions in item uses dot-sources <code>ref</code>, <code>measures</code> and <code>query</code> 
			</property>
			<property name="matchingMeasures" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingMeasure[]" required="false">
				List of Matching Measures.
			</property>
			<property name="outputColumns" type="com.ataccama.dqc.rjoin.RefOutputColumn[]" required="true">
				List of output columns.
			</property>
			<property name="outputUnmatched" type="boolean" required="true">
				Specifies whether input records for which no reference record is matched have to be send to output.
				Then output columns are calculated using <code>No Match Expression</code> (if specified)
				and &quot;fake&quot; reference record with all columns null.
				<br/>Default = true. 
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.rjoin.RefJoinBuilder">
    <introduction>
			Generates reference data used by <strong/> step.
		</introduction>
    <description>
		</description>
    <properties>
			<property name="keys" type="com.ataccama.dqc.rjoin.SourceKey[]" required="true">
				Definitions of reference keys.
			</property>
			<property name="refSource" type="com.ataccama.dqc.rjoin.StaticRefSourceConfig" required="true">
				Specifies where the reference data will be stored.
			</property>
			<property name="incremental" type="boolean" required="true">
				Incremental build. Input records will be merged with existing reference records.
				<br/>Default: false (whole reference data will be rebuilt)
			</property>
			<property name="primaryKeyColumn" type="string" required="false">
				String expression for record&#39;s primary key. Mandatory when incremental build.
			</property>
			<property name="deleteFlagColumn" type="string" required="false">
				Boolean expression specifies whether the record have to be deleted. Meaningful when incremental build.
			</property>
			<property name="mapAllColumns" type="boolean" required="true">
				All input columns will be used as reference record.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
				List of columns of reference record.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.RegExpression">
    <properties>
			<property name="name" type="string" required="true">
				Name of the regular expression definition.
			</property>
			<property name="pattern" type="string" required="true">
				Regular expression used for matching.
			</property>
			<property name="ignoreCase" type="boolean" required="true">
				Determines whether the regular expression matching ignores case. <br/>
				Default value: <code>false</code> (i.e., case-sensitive matching)
			</property>
			<property name="partialMatch" type="boolean" required="true">
				Determines whether the whole input value must be matched with the regular expression.<br/>
				Example: Consider the following <code>regExpression</code>:	&quot;<code>([^,]*), tel. ([0-9]+), ([^,]*)</code>&quot;
				and the following input data: &quot;<code>Michael Volny, tel. 603454501, Praha, 186 00</code>&quot;, then with
				the property <code>Partial Match</code> set to <code>false</code> no match is found, because this
				part of the input: <code>, 186 00</code> isn&#39;t matched by any part of the regular expression. No substitution
				will be made and the processing of the record ends.<br/>
				Deafult value: <code>false</code>
			</property>
			<property name="resultColumns" type="com.ataccama.dqc.tasks.clean.RegexOutputColumn[]" required="false">
				Defines the output columns.
			</property>
			<property name="multiplicative" type="boolean" required="true">
				Indicates that all matches of this expression will be put into output (as separate records).
				This property is effective only when used in 
				<strong>Multiplicative Regex Matching</strong> step.
				<br/>
				Default value: false.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.RegexMatchingAlgorithm">
    <introduction>Parses and extracts values in the input string using defined patterns of Regular expressions.</introduction>
    <description>
			<p align="justify">This step extracts values from the input expression and tries to apply them to regular
			expressions in order to extract values to output columns.
			It works according to the following steps:</p>
			<ul>
				<li>The step evaluates the input expression and tries to &quot;match&quot; the
				result value with one of the defined regular expressions.</li>
				<li>Matching against regular expressions is done one by one in the same order as it
				is defined in the configuration. Matching stops when the first match is found.</li>
				<li>If a match is found, then the <strong>first possible</strong> match of the regular
				expression with the input value is evaluated and the divided data is sent to the
				predefined output columns. Format of the output data is given by the
				properties of the step.</li>
				<li>If no match is found, i.e., the value from the input column doesn&#39;t match the
				regular expression (the value can&#39;t correctly be divided into output columns),
				a scoring flag is set and processing of the current	record is stopped</li>
			</ul>
			For information about regular expressions see the <strong>Regular expressions section</strong> on Expressions page.

		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="expression" type="string" required="true">
				Expression applied to the input to get the input string, which will be matched with
				regular expressions.
			</property>
			<property name="regexNameColumn" type="string" required="false">
				Name of the column where the name of the regular expression which has
				been matched to the input string will be stored. Column type must be string.
			</property>
			<property name="appendRegexNameColumn" type="boolean" required="true">
			If set to true then the name of the regular expression is appended to the
			value in the <code>Regex Name Column</code> otherwise the value in the <code>Regex Name Column</code>
			is rewritten.
	        </property>
			<property name="appendRegexNameColumnSeparator" type="string" required="false">
			If the <code>Append Regex Name</code> is set to true and then this property
			is used to separate the old value in the <code>Regex Name Column</code> and the
			name of the regular expression.
	        </property>
			<property name="regExpressions" type="com.ataccama.dqc.tasks.clean.RegExpression[]" required="false">
				Contains definitions of regular expressions.
			</property>
			<property name="noMatchColumns" type="com.ataccama.dqc.tasks.common.column.ColumnAssign[]" required="false">
				Contains a list of expressions and target columns, which should be assigned when no match is found.
				There are two cases when this element is used.
				<ul>
					<li>If the input is NULL, then the column specified in these elements will be
					filled with the NULL value (regardless of the expression).</li>
					<li>The input is not NULL, but it did not match to any of the regular expressions.
					In this case values of expressions defined in this element will be sent to the output.</li>
				</ul>
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
            <scoringKey name="STN_MATCHED">
                Inidcates that a match was found with the input data (including restrictions imposed
                by <code>ignoreCase</code> and <code>partialMatch</code>) and appropriate data was
                sent to the output.
            </scoringKey>
            <scoringKey name="STN_NULL">
                Indicates that the input value was empty.
            </scoringKey>
            <scoringKey name="STN_NOT_MATCHED">
                Indicates that no match was found. The values from the <code>No Match Columns</code>
                element are sent to the output.
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.RegexOutputColumn">
    <properties>
			<property name="name" type="string" required="true">
				Output column name. Column type must be string.
			</property>
			<property name="substitution" type="string" required="true">
				String sent to the output when a match is found.
				May contain a back-reference (see <strong>Regular expressions</strong>).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.text.RegexSplitter">
    <introduction>Splits inputs using one or more regular expressions.</introduction>
    <description>
      		This step splits the input into separate words using one or more regular expressions. New record is created for each part of the original input.
      		If the regular expression pattern doesn&#39;t match, original input is returned.
      		The <code>All Sentence Column</code> property is an input expression for the splitting. The <code>One Word Column</code> property
      		is an output column for the split words. <code>Regular Expressions</code> is the array of regular expressions for splitting the input. 
      		Regular expressions are applied in the same order as they are inserted.
      		</description>
    <properties>
          	<property name="id" type="string" required="false">
			Step identification string.
			</property>
          	<property name="allSentenceColumn" type="string" required="true">
          	Column containing the input string to be split.
          	</property>
          	<property name="oneWordColumn" type="string" required="true">
          	Column containing split output words.
          	</property>
          	<property name="recordDescriptorColumn" type="string" required="false">
          	Name of the column of type string to store the identification of record in group. The identifier
			has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
	      	</property>
          	<property name="regularExpressions" type="com.ataccama.dqc.tasks.nlp.RegexValue[]" required="false">
          	List of regular expression patterns for splitting the input.
          	</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.text.RegexValue">
    <introduction>Regular expressions that will be used for splitting words.</introduction>
    <description>Regular expressions that will be used for splitting words.</description>
    <properties>
        	<property name="ignoreCase" type="boolean" required="true">
        		Defines whether matching regular expression ignores case sensitivity.<br/>
        		Default value: <code>false</code>
        	</property>
          	<property name="name" type="string" required="false">
          		Name of the regular expression.
          	</property>
          	<property name="pattern" type="string" required="true">
          		Defines regular expression for splitting the input.
          	</property>
			<property name="comment" type="string" required="false">
          		Comment
          	</property>
        </properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.addresses.commons.model.components.EntityComponent" name="com.ataccama.dqc.addresses.commons.model.components.RegexpEntityComponent">
    <description>
    		Component that accepts the text by regular expression parsing.
    	</description>
    <properties>
    		<property name="pattern" type="string" required="true">
    			Regular expression.
    		</property>
    	<property name="id" type="string" required="true">
	        	Identifier of the component.
	        </property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.supervised.regression.LinearRegressionClassifierConfig">
    <introduction>Predicts a target value from previously trained regression model.</introduction>
    <description>
            <p align="justify">
                Based on specified features, this step predicts value based on previously trained model. All features must be the same
                as when training the model. Transformations used in model training are applied automatically before making prediction.
            </p>
            <p align="justify">
                <strong>Note:</strong>
                Transformations are done in memory.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.supervised.columns.ClassifyingFeatureConfig[]" required="true">
                Configuration of features used to predict the value.
            </property>
            <property name="outRegressionColumn" type="string" required="true">
                Column, that is used to output the predicted value.
            </property>
            <property name="outVectorColumn" type="string" required="false">
                Column, that is used to output the final feature vector created from features after all transformations. This vector is used for prediction.
            </property>
            <property name="modelFile" type="string" required="true">
                File, that contains previously trained model.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.supervised.regression.LinearRegressionTrainerStepConfig">
    <introduction>Trains regression model.</introduction>
    <description>
            <p align="justify">
                Based on specified features (measurable properties), this step trains regression model and saves trained model to the specified file.
                Each feature can have some transformations defined. Order of the features is not important, after all transformations,
                the features are ordered alphabetically.
                The model can be than used in Regression step to do predictions.
                We can for example train model to predict house value based on it&#39;s longitude, latitude, distance from coast, and density
                of housing in the area.
            </p>
            <p align="justify">
                <strong>Note:</strong>
                Everything (transformations and training) is done in memory.
            </p>
        </description>
    <properties>
            <property name="trainerConfiguration" type="com.ataccama.dqc.tasks.ai.supervised.regression.LinearRegressionTrainerConfig" required="true">
                Type of regression model.
            </property>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.supervised.columns.TrainingFeatureConfig[]" required="true">
                Configuration of features used to fit the regression model.
            </property>
            <property name="targetColumn" type="string" required="true">
                Column, that contains target used to fit the regression model.
            </property>
            <property name="outVectorColumn" type="string" required="false">
                Column, that is used to output the final feature vector created from features after all transformations. This vector is used to train the model.
            </property>
            <property name="outputModelFile" type="string" required="true">
                File, that is used to output the fitted regression model.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.unify.config.IOperationConfig" name="com.ataccama.dqc.unify.config.RegroupOperation">
    <introduction>
			Adds new grouping level. The new level is named by ID of this operation.
		</introduction>
    <description>
		</description>
    <properties>
			<property name="id" type="string" required="true">
				Unique operation id.
			</property>
			<property name="groupByColumn" type="string" required="true">
				Grouping level generated by some previous operation, which is used in this operation.
			</property>
			<property name="groupBy" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
				Specifies value by which new subgroups are generated.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.relation.RelationAnalysis">
    <introduction>
			Finds relations between two entities based on a given key expression.
		</introduction>
    <description>
			<p align="justify">
			Analyzes two sets of keys coming from two input data flows and
			calculates occurences of several relation types. The types of relations
			are:
			<ul>
				<li>
            <code>1:1</code> - keys unique in both inputs</li>
				<li>
            <code>1:M</code> - keys unique in left input</li>
				<li>
            <code>N:1</code> - keys unique in right input</li>
				<li>
            <code>N:M</code> - keys not unique</li>
				<li>
            <code>1:0</code> - keys unique in left but not present in right</li>
				<li>
            <code>N:0</code> - keys not present in right</li>
				<li>
            <code>0:1</code> - keys unique in right but not present in left</li>
				<li>
            <code>0:M</code> - keys not present in left</li>
				<li>
            <code>null</code> - null keys in left or right</li>
			</ul>
			One record for each of these relations is send to the <code>out</code>
			endpoint. The record contains the number of corresponding distinct keys
			and number of corresponding records in the left and right.
			</p>
			<p align="justify">
			Optionally, the output records sent to <code>out_left/out_right</code> can
			store appropriate counts of records with the same key in the left and/or right
			data flow.
			</p>
		</description>
    <properties>
			<property name="key" type="com.ataccama.dqc.tasks.analysis.relation.RelationKeyComponent[]" required="true">
				Components of key on which the entities are joined.
			</property>
			<property name="left" type="com.ataccama.dqc.tasks.analysis.relation.EntityInput" required="true">
				Specifications of left entity data flow.
			</property>
			<property name="right" type="com.ataccama.dqc.tasks.analysis.relation.EntityInput" required="true">
				Specifications of right entity data flow.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.relation.RelationKeyComponent">
    <properties>
			<property name="left" type="string" required="true">
				The expression evaluating component value of left entity.
			</property>
			<property name="right" type="string" required="true">
				The expression evaluating component value of right entity.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.dqc.tasks.EwfReloadVfsTask">
    <introduction>Reloads the &quot;versioned filesystem&quot; for lookups.</introduction>
    <description>Reloads the &quot;versioned filesystem&quot; for lookups (lookup refresh), including service restart.</description>
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.RemapTool$RemapColumn">
    <description>
		Single column to be re-mapped.
		</description>
    <properties>
			<property name="name" type="string" required="true">
			Name of column to be re-mapped.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.RemapTool">
    <introduction>Sorts all records by primary key and renumbers group numbers.</introduction>
    <description>
			This step sorts data by primary keys and inserts group numbers (IDs) to specified fields, which preserves
			the assignment of groups and their IDs.

			This step is suitable for functional tests where it is necessary to &quot;normalize&quot;
			candidate/client groups independent of IDs assigned by the unification step.
		</description>
    <properties>
		    <property name="primaryKeyColumn" type="string" required="true">
		    Definition of primary key by column.
		    </property>
			<property name="idColumns" type="com.ataccama.dqc.tasks.experimental.RemapTool$RemapColumn[]" required="false">
			List of columns (client ID column, candidate ID column) to be re-mapped.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property> 
		</properties>
  </class>
  <class name="com.ataccama.server.component.hadoop.RemoteAccessComponent">
    <introduction>Remote Access Component exposes WebHCat-like REST API interface for browsing Hive Metastore. It enables browsing Hadoop and Databricks Hive Metastore from IDE.</introduction>
    <description>Remote Access Component exposes WebHCat-like REST API interface for browsing Hive Metastore. It enables browsing Hadoop and Databricks Hive Metastore from IDE.</description>
    <properties>
			<property name="cluster" type="string" required="true"> </property>
			<property name="disabled" type="boolean" required="true">Specify whether component should be disabled.</property>
			<property name="impersonate" type="boolean" required="true"> </property>
			<property name="prefix" type="string" required="true"> </property>
			<property name="services" type="com.ataccama.server.component.hadoop.IHadoopService[]" required="true"> </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.executor.RemoteExecutorComponent">
    <introduction>REST API service for Ataccama jobs. Used for starting remote jobs from any Ataccama Server, Ataccama IDE and ONE web application.</introduction>
    <description>REST API service for Ataccama jobs. Used for starting remote jobs from any Ataccama Server, Ataccama IDE and ONE web application.</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specify whether component should be disabled.</property>
			<property name="localRootFolder" type="string" required="true">Folder to store temporary files required for the processing.</property>
			<property name="prefix" type="string" required="true">The prefix under which ONE Server will listen to REST API requests and accept jobs.</property>
			<property name="maxRunningJobs" type="string" required="true">Maximum number of simultaneously running jobs. Any additional jobs will be queued. <code>0</code> means there is no limit.</property>
			<property name="enableEditProperties" type="boolean" required="false">Enables editing <code>executor.properties</code>, <code>hadoop.properties</code> and <code>dbricks.properties</code> via Admin Center.</property>
			<property name="propertiesFile" type="string" required="true">Specify path to <code>executor.properties</code> the main configuration file for executor processes.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.uiradr.Replacement">
    <properties>
			<property name="addressComponent" type="string" required="true">
				Address component name. Valid names are: &#39;DISTRICT&#39;, &#39;CITY&#39;,
				&#39;CITY_DICTRICT&#39;, &#39;POST_OFFICE&#39;, &#39;STREET&#39;, &#39;ZIP&#39; and &#39;CITY_PART&#39;.
			</property>
			<property name="fullReplacements" type="string" required="true">
				Name of the file with full replacement dictionary.
			</property>
			<property name="partialReplacements" type="string" required="true">
				Name of the file with partial replacement dictionary.
			</property>
			<property name="tokenizer" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Tokenizer definition used for partial replacement.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.server.http.ServletFilter" name="com.ataccama.dqc.web.filters.ReplyWithHeadersFilter">
    <introduction>Filter that adds (copies) specified headers from incoming requests into outcoming responses.</introduction>
    <description>Filter that adds (copies) specified headers from incoming requests into outcoming responses.</description>
    <properties>
			<property name="headers" type="string[]" required="false">Headers which will be added to outcoming responses.</property>
			<property name="name" type="string" required="false">Name of your filter.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.dqi.ReportedColumn">
    <description>
	A name of an input column which is copied to rows on the report end point.
	</description>
    <properties>
			<property name="name" type="string" required="true">
			Name of a input column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.repository.convert.RepositoryKeyConverter">
    <introduction>Converts repository keys from older repository versions to new versions.</introduction>
    <description>
			This step generates keys based on unification constraints so that
			the output can be used by the <strong>Repository Writer</strong> to build the new repository applicable to incremental <strong>Unification</strong>.
			<br/>
      <br/>
			Also, this step can generate the &quot;merge survivor&quot; data record property based on the input
			unification role.
			<br/>
      <br/>
			Lastly, it is mostly used in converting repository keys from one version of a repository (older) to
			another (newer).
		</description>
    <properties>
			<property name="groups" type="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod[]" required="false">
				List of unification methods. Must be the same as the Unification step configuration
				for which the repository is generated.
				<br/>
        <br/>
				NOTE: For conversion purposes, it is not necessary to specify matching and/or pivot selection rules
				for definition of matching groups,
			</property>
			<property name="keyColumn" type="string" required="true">
				Column used to store generated unification keys.
			</property>
			<property name="mergeSurvivorRoleColumn" type="string" required="false">
				Column used to store the &quot;merge survivor role&quot; specification for candidate and/or matching groups.
				Relevant only when the parameter <code>Use Pivot As Survivor</code> is set to &quot;false&quot;.			
			</property>
			<property name="unificationRoleColumn" type="string" required="false">
				Input column containing unification role codes/values.
				Relevant only when the parameter <code>Use Pivot As Survivor</code> is set to &quot;false&quot; and
				&quot;merge survivor role&quot; is generated.
			</property>
			<property name="usePivotAsSurvivor" type="boolean" required="true">
				This property is counterpart of the same property in the target unification process.<br/>
				When true, unification role itself will determine &quot;Merge survivor&quot; records.
				When false, merge survivor role will be generated into <code>Merge Survivor Role Column</code> based on input unification role.
				See <strong>ID Stability</strong>
				<br/>Default value: false.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
  			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.repository.RepositoryProperties">
    <description>
			Defines the repository location and handling rules (e.g. readOnly access).
			<br/>
			If the repository is stored in a database, only the properties
			<code>Data Source</code> and <code>Name</code> are used and required.
		</description>
    <properties>
			<property name="directUpdate" type="boolean" required="true">
				<p align="justify">
				This property specifies whether the file repository should be updated directly, bypassing the transaction log and leading to high performance and shorter transaction times.
				The downside of updating the repository directly is that repository consistency cannot be guaranteed in case of software and/or hardware failure.
				For database repository, this specifies whether updates will be divided into more smaller transaction instead one big transaction. 
				This operation mode is recommended only for full loads, a repository initialization with a large number of records.
				In case the <code>Save Logs</code> property is set to true, a transaction log is created and can be used for mirroring, however rollback ability
				is still lost.
				</p>
				Default value: <code>false</code>
			</property>
			<property name="dirtyRead" type="boolean" required="true">
				<p align="justify">
				Indicates that access to the repository will not be hindered by runtime synchronization in a parallel updates scenario. This mode is useful only with the <code>Read Only</code> property.
				</p>
				Used for file repository only.
				<br/>
				Default value: <code>false</code>
			</property>
			<property name="folder" type="string" required="false">
				Directory that contains the repository.
				<br/>
				Applicable and required for file repositories only.
				The property <code>Data Source</code> must not be specified.
			</property>
			<property name="logFolder" type="string" required="false">
				<p align="justify">
				Directory that contains the transaction log. Can be used for mirroring if <code>readOnly=true</code> and the logFolder points to the source repository
				directory.
				</p>
				Used for file repository only.
				<br/>
				Default value: directory stated in the <code>Folder</code> property.
			</property>
			<property name="readOnly" type="boolean" required="true">
				This property specifies that the repository cannot be updated during operation.
				<br/>
				Default value: <code>false</code>
			</property>
			<property name="saveLogs" type="boolean" required="true">
				<p align="justify">
				This property specifies that logs are saved even after the end of the transaction. Can be used for mirroring of this repository.
				</p>
				Used for file repository only.
				<br/>
				Default value: <code>false</code>
			</property>
			<property name="dataSource" type="string" required="false">
				Name of the data source for connection to the database repository.
				<br/>
				Applicable and required for database repositories only.<br/>
				The property <code>Folder</code> must not be specified.
			</property>
			<property name="name" type="string" required="false">
				Name of repository determining table names in the database repository.
				<br/>
				Applicable and required for database repositories only.
				The property <code>Folder</code> must not be specified.
				Applicable and required for database repositories only.
				<strong>It is not allowed to have multiple <code>Unification</code> steps with same repository within the same
				plan or to execute multiple jobs using the same Unification repository.</strong>
        <br/>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.repository.read.RepositoryReader">
    <introduction>Reads data from repository files.</introduction>
    <description>
			This step reads all valid items from a specified file representing a local repository storing
			incremental changes for database identification keys. This file is located in the repository&#39;s directory and is named
			&quot;repos_data.cif&quot; (or &quot;data.cif&quot; for [branding:product.name.abbreviation] version 2 (then known as Purity)). The output column <code>Key Column</code>
			contains the pairing-key values that were assigned when the repository was created.<br/>
			By using classes <code>com.ataccama.dqc.tasks.identify.[ver].repository.read.RepositoryReader</code>
			it is possible to read the repository format of previous [branding:product.name.abbreviation] versions {v2, v3, v35, etc.}.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="pkColumn" type="string" required="false">
				Column name that stores the primary key value.
			</property>
			<property name="keyColumn" type="string" required="false">
				Column name that stores the pairing-key value.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="false">
				Contains a set of column definitions that are read from the repository. These must match the 
				repository column definitions. In the directory where the repository is located, the &quot;repository.xml&quot;
				file defines the repository&#39;s internal structure. It is recommended to
				inspect the elements in the repository.xml file to ensure format consistency with the repository reader. 
			</property>
			<property name="repository" type="com.ataccama.dqc.tasks.identify.repository.RepositoryProperties" required="true">
				Repository specification.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.repository.write.RepositoryWriter">
    <introduction>Writes data into repository files or a JDBC data source (for relational repositories).</introduction>
    <description>
			This step write all valid items from a specified source to a local repository storing incremental changes for
			database identification keys.
			For each repository file, the write step creates a data file and an index file.
		</description>
    <properties>
			<property name="keyColumn" type="string" required="true">
				Column or expression containing the pairing key.
			</property>
			<property name="pkColumn" type="string" required="true">
				Name of the column that contains the primary key of entries.
			</property>
			<property name="candidateIdColumn" type="string" required="true">
				Name of the column that contains the candidate group.
			</property>
			<property name="matchingIdColumn" type="string" required="true">
				Name of the column that contains the ID of the matching group.
			</property>
			<property name="unificationRoleColumn" type="string" required="true">
				Name of the column that contains the instance unification role.
			</property>
			<property name="mergeSurvivorRoleColumn" type="string" required="false">
				Name of the column that contains the encoded MSR roles.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnExprDef[]" required="false">
				Contains a list of columns to be written to the repository file. This element is not
				required and, if not specified, all columns will be written out.
			</property>
			<property name="repository" type="com.ataccama.dqc.tasks.identify.repository.RepositoryProperties" required="true">
				Repository specification.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				Specifies whether to write out all columns as defined in the input format. This attribute is exclusive
				to column definitions. If this value is set to on, then there must be no columns defined
				in the columns element, otherwise an error is reported.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.bob.RepresentativeCreator">
    <introduction>Computes a representative record for a specified group of records according to given criteria.</introduction>
    <description>
			This step computes a set of representative records from source data utilizing a process where
			records are classified by a specified rule and grouped by an appropriate key.
			<br/>
			The records are sorted for each group, and the best records are selected for each group.
			The new representative record is collected from a specific data record or from aggregated
			values of a group of records. New values can be also stored in the original records.
		</description>
    <properties>
			<property name="defaultLocale" type="string" required="false">
				Defines the locale for parsing non-numerical data (for example, abbreviated months in dates -
				e.g., Sep 18, 1999). This value is the same as the value of the corresponding locale in Java. 
				For more detail see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html" target="_blank">Java locales</a>.
				<br/>Default value: System locale.
			</property>
			<property name="groupingStrategy" type="com.ataccama.dqc.tasks.common.group.AbstractGroupingStrategy" required="true">
				Specifies how groups are defined. There are two strategies.<br/>
				1. groups are defined by one or more keys as in GROUP BY.<br/>
				2. groups are defined by <code>record descriptors</code>.
			</property>
			<property name="rules" type="com.ataccama.dqc.tasks.identify.bob.Rule[]" required="false">
				Set of rules for record selection. The rule defines record grouping and the process of selecting record attributes (column values).
				Each record is processed by the first rule satisfying the <code>When</code> condition.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.unify.config.IOperationConfig" name="com.ataccama.dqc.unify.config.RepresentativeCreatorOperation">
    <introduction>
			Computes a representative record for a specified group of records by a given criteria. For additional information, 
			see <strong>Representative Creator</strong>.
		</introduction>
    <description>
			This step computes a set of representative records from source data utilizing a process where
			records are classified by a specified rule and grouped by an appropriate key.
			<br/>
			The records are sorted by each group, and best records are selected for each group.
			The new representative record is collected from a specific data record or from aggregated
			values of group of records. New values can be also stored in the original records.
		</description>
    <properties>
			<property name="id" type="string" required="true">
				Unique operation id.
			</property>
			<property name="groupByColumn" type="string" required="true">
				Grouping level generated by some previous operation, which is used in this operation.
			</property>
			<property name="defaultLocale" type="string" required="false">
				Defines the locale for parsing non-numerical data (for example, abbreviated months in dates -
				e.g., Sep 18, 1999). This value is the same as the value of the corresponding locale in Java. 
				For more detail see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html" target="_blank">Java locales</a>.
				<br/>Default value: System locale.
			</property>
			<property name="rules" type="com.ataccama.dqc.tasks.identify.bob.Rule[]" required="false">
				Set of rules for record selection. The rule defines record grouping and the process of selecting record attributes (column values).
				Each record is processed by the first rule satisfying the <code>When</code> condition.
			</property>		
		</properties>
  </class>
  <class name="com.ataccama.server.http.conditions.RequestHeaderCondition">
    <introduction>Tests if the request header specified by <strong>Header Name</strong> parameter matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</introduction>
    <description>Tests if the request header specified by <strong>Header Name</strong> parameter matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</description>
    <properties>
			<property name="headerName" type="string" required="false">Fill in header name</property>
			<property name="negativeTest" type="boolean" required="true">If true, then filters are applied only if <strong>Header Name</strong> matches neither <strong>Regexp</strong> nor <strong>Value</strong> parameter.</property>
			<property name="regexp" type="string" required="false">Fill in <strong>Regexp</strong> that should be matched by filter</property>
			<property name="value" type="string" required="false">Fill in <strong>Value</strong> that should be matched by filter</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.web.IMappingTest" name="com.ataccama.dqc.web.mappingtests.RequestHeaderTest">
    <introduction>Tests if the request header specified by <strong>Header Name</strong> parameter matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</introduction>
    <description>Tests if the request header specified by <strong>Header Name</strong> parameter matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</description>
    <properties>
			<property name="headerName" type="string" required="false">Fill in header name.</property>
			<property name="negativeTest" type="boolean" required="true">If true, then filters are applied only if <strong>Header Name</strong> matches neither <strong>Regexp</strong> nor <strong>Value</strong> parameter.</property>
			<property name="regexp" type="string" required="false">Fill in <strong>Regexp</strong> that should be matched by condition.</property>
			<property name="value" type="string" required="false">Fill in <strong>Value</strong> that should be matched by condition.</property>
		</properties>
  </class>
  <class name="com.ataccama.server.http.conditions.RequestParamCondition">
    <introduction>Tests if the parameter specified by <strong>Param Name</strong> parameter matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</introduction>
    <description>Tests if the parameter specified by <strong>Param Name</strong> parameter matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</description>
    <properties>
			<property name="negativeTest" type="boolean" required="true">If true, then filters are applied only if <strong>Param Name</strong> matches neither <strong>Regexp</strong> nor <strong>Value</strong> parameter.</property>
			<property name="paramName" type="string" required="false">Fill in paramater name</property>
			<property name="regexp" type="string" required="false">Fill in <strong>Regexp</strong> that should be matched by filter</property>
			<property name="value" type="string" required="false">Fill in <strong>Value</strong> that should be matched by filter</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.web.IMappingTest" name="com.ataccama.dqc.web.mappingtests.RequestParamTest">
    <introduction>Tests if the parameter specified by <strong>Param Name</strong> parameter matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</introduction>
    <description>Tests if the parameter specified by <strong>Param Name</strong> parameter matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</description>
    <properties>
			<property name="negativeTest" type="boolean" required="true">If true, then filters are applied only if <strong>Param Name</strong> matches neither <strong>Regexp</strong> nor <strong>Value</strong> parameter.</property>
			<property name="paramName" type="string" required="false">Fill in <strong>Parameter</strong> name.</property>
			<property name="regexp" type="string" required="false">Fill in <strong>Regexp</strong> that should be matched by condition.</property>
			<property name="value" type="string" required="false">Fill in <strong>Value</strong> that should be matched by condition.</property>
		</properties>
  </class>
  <class super="com.ataccama.server.http.ServletFilter" name="com.ataccama.dqc.web.filters.RequestResponseTimeLogger">
    <introduction>Filter used to log the time that has been spent to handle the incoming request to a standardly configured logger.</introduction>
    <description>Filter used to log the time that has been spent to handle the incoming request to a standardly configured logger.</description>
    <properties>
			<property name="appendClientInfo" type="boolean" required="true">If true, the message will include client IP address and port.
			<br/>Default value: false</property>
			<property name="headers" type="string[]" required="false">List of sub-elements, each containing HTTP header name that will be printed together with the log message.</property>
			<property name="level" type="com.ataccama.dqc.commons.logging.appenders.Level" required="false">Severity level used for Request Response Time Logger messages.
			<br/>Default value: DEBUG</property>
			<property name="name" type="string" required="false">Name of the logger. The name is displayed in square brackets in the log.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.workflow.dpm.ResourceMapping">
    <description>Mapping path -&gt; resource for <strong>DPM job tak</strong>.
			It allows to configure location of the resource at the remote side. <code>path</code> defines either
			absolute path or path relative to <code>Working Dir</code>.
			The workflow task uses this mapping to upload the resource to the defined path at remote side.
		</description>
    <properties>
			<property name="path" type="string" required="true">Path to the resource at remote side. It is either absolute path
			or path relative to working dir.</property>
			<property name="resource" type="string" required="true">Resource path.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.soap.ResponseColumnBinding">
    <properties>
			<property name="name" type="string" required="true">
				Name of column
				in the format.
			</property>
			<property name="xpath" type="string" required="true">
				The XPATH to a XML element text value of this element will be used as a value for column in a row.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				See
				<code>Data Format Parameters</code>
				at the root level of the configuration.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.server.http.ServletFilter" name="com.ataccama.server.http.filters.ResponseHeadersFilter">
    <introduction>Adds specified headers to server responses that are processed with this filter.</introduction>
    <description>Adds specified headers to server responses that are processed with this filter.</description>
    <properties>
			<property name="headers" type="com.ataccama.server.http.filters.ResponseHeadersFilter$Header[]" required="false">Adds specified headers to server responses that are processed with this filter.</property>
			<property name="name" type="string" required="false">Fill in header name.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.select.Result">
    <description>
		</description>
    <properties>
			<property name="selections" type="com.ataccama.dqc.tasks.experimental.select.Selection[]" required="true">
				List of selection criteria definitions.
			</property>
			<property name="sorting" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Sort column and direction criteria. Records in each group will be sorted by this value
				and will be applied in the selection parameter <code>Selections</code>.
				<br/>If at least one of selection method used in <code>Selections</code>
				is order-sensitive (min, max, median and proportional), the sorting must be specified.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.base.Mapping$ResultSetMapping">
    <description>Defines a set of the output parameters to be read from the query&#39;s result set. Applicable when running SQL queries. </description>
    <properties>
			<property name="index" type="integer" required="true">Defines index of the value in the result set. Indexed from 1 (index of the first available column is 1).<br/>
			The value will be read from the first row of the first available result set.</property>
			<property name="name" type="string" required="true">Defines the name of the mapping. Value read from the mapping will be available under this name in the condition and saved in the task&#39;s variables.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.addressdoctor.ResultStatusName">
    <description>
            List of result codes that can be queried. For more information, see documentation for
            Address Doctor©.
        </description>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.ILdapRoleResolver" name="com.ataccama.dqc.communication.auth.server.ReverseMemberAttributeResolver">
    <introduction>Tests if the group identified by the <strong>Group Path</strong> attribute contains the authenticated user&#39;s distinguished name in the attribute defined by <strong>Attribute</strong>. If the test is successful, the name of the group (role) will be the value from the most specific key-value pair of the group&#39;s distinguished name (i.e. <strong>Group Path</strong>).</introduction>
    <description>Tests if the group identified by the <strong>Group Path</strong> attribute contains the authenticated user&#39;s distinguished name in the attribute defined by <strong>Attribute</strong>. If the test is successful, the name of the group (role) will be the value from the most specific key-value pair of the group&#39;s distinguished name (i.e. <strong>Group Path</strong>).</description>
    <properties>
			<property name="attribute" type="string" required="false">Attribute of the <code>member</code> group that contains a list of all group memmbers (their distinguished names).</property>
			<property name="groupPath" type="string" required="false">LDAP path to the node that represents the tested group.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.communication.auth.server.IRoleMappingProvider">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.RollUp">
    <introduction>
		Defines a grouping key for one level of rollup hierarchy.
		</introduction>
    <properties>
			<property name="name" type="string" required="false">
			Descriptive name of the rollup level.
			</property>
			<property name="expression" type="string" required="true">
			Grouping key value.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.global.flow.NestedFlowParams" name="com.ataccama.one.profiling.linear.simple.params.global.flow.RollUpParams">
    <introduction>Parameters that will be used for Roll Up Implementation (Compute for Root, Expression).</introduction>
    <properties>
			<property name="computeForRoot" type="boolean" required="true">Expression is evaluated for all cases. If the condition is true and also if the condition is false.</property>
			<property name="expression" type="string" required="false">Expression condition (<code>Boolean</code>).</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.io.json.stream.RootJsonStreamConfig">
    <description>A single stream of data with one output.</description>
    <properties>
      <property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="name" type="string" required="true">
				The name of this stream and its associated output.
			</property>
      <property name="path" type="string" required="true">
				The JSON path to the elements that are to be read by this stream. If this is a substream of another stream, then
				the path is relative to the path of the parent stream. Path containing dot character (&quot;.&quot;) must be surrounded with
				quotation marks (e.g.: &quot;sub.stream&quot;). You can also use <code>@</code> in the <strong>Path</strong> attribute to handle JSON arrays. Including <code>$.@</code> for a top level array. 
			</property>
      <property name="parentIdColumn" type="string" required="false">
				Expression evaluating unique id of the superior record. The id is used as a part of <code>Record Descriptor</code>
				assigned to group of records generated by this output and belonging to that parent record. Name of the parent output is used
				as a dot-source name referring to parent record columns. Records from top level data stream are referenced as in.column_name.
				Useless at the top level output of Json Reader step.
			</property>
      <property name="recordDescriptor" type="string" required="false">
				Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
				only when <code>Parent Id Column</code> is defined.
			</property>
      <property name="minOneRecord" type="boolean" required="false">
				Guarantees at least one record in the output data stream. If no record is found in the response, it returns an empty record scored WLA_NOT_FOUND.
			</property>
      <property name="maxOneRecord" type="boolean" required="false">
				Allows at most one record in the output data stream. If multiple records are found in the response, it returns an empty record scored WLA_MULTIPLE.
			</property>
      <property name="dataStreams" type="com.ataccama.dqc.tasks.io.json.stream.ChildJsonStreamConfig[]" required="false">
				The substreams of this stream. They will produce records that are logically children of the records of this parent stream.
			</property>
      <property name="attributes" type="com.ataccama.dqc.tasks.io.json.stream.Attribute[]" required="true">
				The attributes of this stream - columns of the associated output mapped to JSON fields.
			</property>
      <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
      <property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Data formats for parsing string JSON fields into DQC data types. Overrides the data format parameters defined on any
				parent object. For details refer to the
				<strong>DataFormatParameters</strong> section.
			</property>
    </properties>
    <scoring>
			<scoringKey name="WLA_NOT_FOUND">
				Indicates no record in the response when <code>Min One Record</code> is enabled.
			</scoringKey>
			<scoringKey name="WLA_MULTIPLE">
				Indicates multiple records in the response when <code>Max One Record</code> is enabled.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.dqi.Rule">
    <properties>
			<property name="name" type="string" required="true">
				Rule name.
			</property>
			<property name="code" type="string" required="true">
				Code of rule.
			</property>
			<property name="shortDescription" type="string" required="false">
				Short description of rule.
			</property>
			<property name="description" type="string" required="false">
				Description of rule.
			</property>
			<property name="type" type="string" required="false">
				Type. Values are taken from list of values.
			</property>
			<property name="category" type="string" required="false">
				Category. This is only for reporting purposes and doesn&#39;t affect the behavior of the step.
			</property>
			<property name="targetValue" type="integer" required="true">
				Target value. This is only for reporting purposes and doesn&#39;t affect the behavior of the step.
			</property>
			<property name="criticalValue" type="integer" required="true">
				Critical value. This is only for reporting purposes and doesn&#39;t affect the behavior of the step.
			</property>
			<property name="expression" type="string" required="true">
				Boolean expression indicating valid record for this rule.
			</property>
			<property name="procedureName" type="string" required="false">
				Procedure name. This is only for reporting purposes and doesn&#39;t affect the behavior of the step.
			</property>
			<property name="errorAssignments" type="com.ataccama.dqc.tasks.experimental.dqi.ErrorAssignment[]" required="false">
				Error assignments to be performed when the record is not valid for this rule. 
				These assignments are performed in addition to the default ones (thus DON&#39;T override).
			</property>
			<property name="tableName" type="string" required="false">
				Table name. This is only for reporting purposes and doesn&#39;t affect the behavior of the step.
			</property>
			<property name="when" type="string" required="true">
				Condition indicating when to check the record against this rule. 
			</property>
			<property name="exposureValueExpression" type="string" required="false">
				Exposure value expression.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.bob.Rule">
    <properties>
			<property name="attributeSets" type="com.ataccama.dqc.tasks.identify.bob.AttributeSetCfg[]" required="true">
				List of attribute definitions and selection rules for the best group record.
			</property>
			<property name="when" type="string" required="false">
				Condition for applying this rule to a record. Only the first rule in the specified order that meets
				the condition is used.
				<br/>Default value: <code>true</code>.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.workflow.dpm.EwfDpmJobTask">
    <introduction>Runs a DQC plan or component at remote DPM/DPE instance.</introduction>
    <description>Runs a DQC plan or component at remote DPM/DPE instance: it is configurable to wait until the process finishes.<br/>
			Logs of the process are stored in the task resources folder.<br/>

			Supported runtime.properties values to tune connections:<br/>
			<code>_name_</code> is either &quot;sfs&quot; indicating connection to Shared file system or keycloak for connection to Keycloak server.
			<ul>
				<li>ataccama.client.connection._name_.http.properties.connectTimeout</li>
				<li>ataccama.client.connection._name_.http.properties.readTimeout</li>
				<li>ataccama.client.connection._name_.http.properties.writeTimeout</li>
				<li>ataccama.client.grpc.properties.max-message-size</li>
			</ul>

		</description>
    <properties>
			<property name="arguments" type="com.ataccama.adt.task.base.KeyValueMapping.Parameter[]" required="false">Arguments for DQC processing</property>
			<property name="async" type="boolean" required="false">Indicates whether to run the DPM job asynchronously or wait for its completion (default value: false)</property>
			<property name="forceClusterLaunch" type="" required="false">Indicates that this job is intended to be running on a cluster</property>
			<property name="clusterName" type="string" required="false">Name of the cluster to run the job at.</property>
			<property name="clusterPassword" type="string" required="false">Password for cluster authentication</property>
			<property name="clusterPasswordFile" type="string" required="false">File with password for cluster authentication</property>
			<property name="clusterUser" type="string" required="false">User name for cluster authentication</property>
			<property name="files" type="com.ataccama.adt.workflow.dpm.ResourceMapping[]" required="false">Files necessary for processing</property>
			<property name="links" type="com.ataccama.adt.workflow.dpm.ResourceMapping[]" required="false">Links to content necessary for processing</property>
			<property name="mainPlan" type="string" required="true">Main DQC plan or component</property>
			<property name="mainPlanPath" type="string" required="false">Path to the main plan at remote side</property>
			<property name="mountDrivers" type="string[]" required="false">Drivers to mount at remote side</property>
			<property name="onePlatform" type="string" required="true">Name of Ataccama ONE platform - this references the remote processing side</property>
			<property name="pathVars" type="com.ataccama.adt.task.exec.EwfDqcTask.PathVariableBean[]" required="false">Path variables</property>
			<property name="priority" type="int" required="false">Job priority</property>
			<property name="rootDir" type="string" required="false">Root directory</property>
			<property name="runtimeConfiguration" type="string" required="false">Optional runtime configuration. If not defined, runtime configuration from the environment is used</property>
			<property name="workingDir" type="string" required="false">Working directory of the job. By default it is the </property>
			<property name="zip" type="boolean" required="false">Indicates whether to download results in packed format</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfDqcTask">
    <introduction>Runs a DQC plan or component.</introduction>
    <description>Runs a DQC plan or component. The plan is validated before: if the plan is invalid, the task will fail with FINISHED_FAILURE state and log details into a log.
			<br/>Former versions of this task had the runtimeFile parameter, this attribute has been removed. Runtime Configuration is now an argument of the &lt;DQC_HOME&gt;/bin/runewf.[bat|sh] script (for batch jobs). When workflows are started from Admin Center, runtime configuration is read from Server Configuration.
		</description>
    <properties>
			<property name="parameters" type="com.ataccama.adt.task.base.KeyValueMapping$Parameter[]" required="false">Set of parameters to pass to the DQC component.</property>
			<property name="pathVariables" type="com.ataccama.adt.task.exec.EwfDqcTask$PathVariableBean[]" required="false">Set of local path variables to use with the current task.</property>
			<property name="planFile" type="string" required="true">Relative (to the workflow file) or absolute path to the plan or component to run.</property>
			<property name="parallelismLevel" type="int" required="false">Parallelism level for this DQC execution. Default value: 1.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfRunBDEPlanTask">
    <introduction>Runs a DQC plan or component on a cluster in a new Java process: the task waits until the process finishes.</introduction>
    <description>Starts a MapReduce or Spark processing on a cluster. Runs a DQC plan or component on a cluster in a new Java process: the task waits until the process finishes. This allows to use specific Java version and runtime parameters (such as memory settings etc.). The plan is validated before: if the plan is invalid, the task will fail with FINISHED_FAILURE state and log details into a log.
			<br/>Logs of the process are stored in the task resources folder. The stdout log also contains a copy of the process command.
			<br/>This task currently demands drivers of all database connections existing in the IDE to be placed in &lt;DQC_home&gt;/runtime/lib/.
			<br/>Note: The task can start a processing on a cluster that interacts with BDE via native Hadoop Java API. To trigger a processing on a cluster via REST API, run the <code>runbde.sh</code> script with the Run Shell Script task.
		</description>
    <properties>
		<property name="parameters" type="com.ataccama.adt.task.base.KeyValueMapping$Parameter[]" required="false">Set of parameters to pass to the DQC component.</property>
			<property name="pathVariables" type="com.ataccama.adt.task.exec.EwfDqcTask$PathVariableBean[]" required="false">Set of local path variables to use with the current task.</property>
			<property name="hadoopSource" type="string" required="true">Name of an existing cluster connection.</property>
			<property name="executionEngine" type="com.ataccama.adt.task.exec.ExecutionEngine" required="true">Selects the data processing engine (MapReduce or Spark) to run plans on a cluster.</property>
			<property name="javaDir" type="string" required="false">Defines the path of the Java JRE or JDK directory to use. The defined directory must contain either <code>bin/java</code> or <code>bin/java.exe</code> executable. 
				<br/>If this attribute is not specified, the JRE is autodetected using Java&#39;s <code>java.home</code> property of the current Java process. If this value cannot be resolved, the OS property <code>JAVA_HOME</code> is used instead. If none of the properties is defined, the task fails during validation.
			</property>
			<property name="javaOptions" type="string" required="false">Space separated Java options to pass to the Java Virtual Machine.</property>
			<property name="planPath" type="string" required="true">Relative (to the workflow file) or absolute path to the plan or component to run on a cluster.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfDqcAsProcessTask">
    <introduction>Runs a DQC plan or component in a new Java process: the task waits until the process finishes.</introduction>
    <description>Runs a DQC plan or component in a new Java process: the task waits until the process finishes. This allows to use specific Java version and runtime parameters (such as memory settings etc.). The plan is validated before the run: if the plan is invalid, the task will fail with FINISHED_FAILURE state and log details into a log.
			<br/>Logs of the process are stored in the task resources folder. The stdout log also contains a copy of the process command. 
			<br/>Note: This task requires the DQC_HOME system or user environment variable to be properly set, otherwise the task may fail. Ensure that DQC_HOME is set for the user running the online server (especially when the server is started as a Windows service).	
		</description>
    <properties>
			<property name="javaDir" type="string" required="false">Defines the path of the Java JRE or JDK directory to use. The defined directory must contain either <code>bin/java</code> or <code>bin/java.exe</code> executable. 
				<br/>If this attribute is not specified, the JRE is autodetected using Java&#39;s <code>java.home</code> property of the current Java process. If this value cannot be resolved, the OS property <code>JAVA_HOME</code> is used instead. If none of the properties is defined, the task fails during validation.
			</property>
			<property name="javaOptions" type="string" required="false">Space separated Java options to pass to the Java Virtual Machine.</property>
			<property name="parameters" type="com.ataccama.adt.task.base.KeyValueMapping$Parameter[]" required="false">Set of parameters to pass to the DQC component.</property>
			<property name="pathVariables" type="com.ataccama.adt.task.exec.EwfDqcTask$PathVariableBean[]" required="false">Set of local path variables to use with the current task.</property>
			<property name="planFile" type="string" required="true">Relative (to the workflow file) or absolute path to the plan or component to run.</property>
			<property name="parallelismLevel" type="int" required="false">Parallelism level for this DQC execution. Default value: 1.</property>
		</properties>
  </class>
  <class name="com.ataccama.nme.ext.workflow.RunNmeBatchExport">
    <introduction>Starts an MDC export operation.</introduction>
    <description>Starts an MDC export operation.</description>
    <properties>
            <property name="operationName" type="string" required="true">Comma-separated list of operation IDs to be invoked. Workflow fails at runtime if any of the operations is unknown. Trailing space is allowed (operation names are trimmed),
                empty operation names are discarded. If the expression evaluates to an empty list, the task succeeds as well.
            </property>
            <property name="parameters" type="com.ataccama.nme.ext.workflow.ParameterDef[]" required="false">Set of parameters to pass to the batch operations. These can be used as component parameters, path variable definitions, or elements in more
                complex parameter definitions.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.nme.ext.workflow.RunNmeBatchLoad">
    <introduction>Starts a batch load for a connected system.</introduction>
    <description>Starts a batch load for a connected system.</description>
    <properties>
            <property name="operationName" type="string" required="true">ID of the operation to be invoked. Workflow fails to load if the operation is not known.</property>
            <property name="parameters" type="com.ataccama.nme.ext.workflow.ParameterDef[]" required="false">Set of parameters to pass to the batch operations. These can be used as component parameters, path variable definitions, or elements in more
                complex parameter definitions.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.nme.ext.workflow.RunNmeMultiLoad">
    <introduction>Starts a batch load for one or more connected systems.</introduction>
    <description>Starts a batch load for one or more connected systems. Grouping of multiple batch operations can increase processing throughput.</description>
    <properties>
            <property name="operationNames" type="string" required="true">ID of the operation to be invoked. Workflow fails to load if the operation is not known.</property>
            <property name="parameters" type="com.ataccama.nme.ext.workflow.ParameterDef[]" required="false">Set of parameters to pass to the batch operations. These can be used as component parameters, path variable definitions, or elements in more
                complex parameter definitions.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.adt.scheduler.persister.IRunResultPersister">
    <properties/>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfShellScriptTask">
    <introduction>Runs linux-like shell command.</introduction>
    <description>Runs linux-like shell command: use it specifically for unix-like OS tasks.
			<br/>Warning: To prevent collisions between unix shell variables format and workflow expression format, this task uses a different expression markup: $%expression()% instead of the regular ${expression()} markup.
		</description>
    <properties>
			<property name="command" type="string" required="true">Command or file name to execute.	Processing of the command: 1. The possible variable mapping replacements are performed. 2. Whole command value is copied to the temporary script file (located in task&#39;s resources directory). 3. Temporary script file is executed using specified interpreter. 4. Read return value is returned.</property>
			<property name="expectedReturnCodes" type="string" required="false">Comma separated list of integer values representing valid return codes of the command.</property>
			<property name="interpreter" type="string" required="false">Defines interpreter to use to process the command value. Default: /bin/sh.</property>
			<property name="logStartStop" type="boolean" required="true">If set to true, the task writes start/stop marks to the standard output log (stdout).</property>
			<property name="waitFor" type="boolean" required="true">Defines whether the task should wait until the job finishes. Wait for modes:
					<ul>
						<li>waitFor=true:Task waits until the run command is done. Returned code is then compared against Expected Return Codes. If expected codes do not contain the returned code, the task fails.</li>
						<li>waitFor=false:Task only starts up the command and then terminates immediately. That means that there is no valuable return code to compare against Expected Return Codes, therefore this comparison is skipped. Task finishes in OK state and the result of the task is set to -1 (&quot;unknown&quot; value).</li>
					</ul>
				</property>
			<property name="workingDir" type="string" required="false">Working directory.  Default value: current java-process directory (usually value of &quot;usr.dir&quot; property).</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfWinCmdTask">
    <introduction>Executes a Windows command.</introduction>
    <description>Executes a Windows command: use it only for Windows operations. For Linux operations, use Run Shell Script.</description>
    <properties>
			<property name="command" type="string" required="true">Command to execute. Processing of the command: 1. The possible variable mapping replacements are performed. 2. EXIT %ERRORLEVEL% instruction is added to the end of the command. 3. Whole command value is copied to the temporary script file. 4. Temporary script file is executed using cmd.exe (you can find the temporary script in the task&#39;s resources directory). Utilizing intermediate temporary script file allows the user to define more sophisticated interpreter-related logic.
				<br/>Note: When you call other scripts from your command, please remember to invoke them using call syntax (e.g. call somescript.bat). Otherwise the called script will not return control to the caller once it is done and will not store return value to the OS ERRORLEVEL property. Both of these situations prevent correct result code setup.
			</property>
			<property name="expectedReturnCodes" type="string" required="false">Comma separated list of integer values representing valid return codes of the command.</property>
			<property name="logStartStop" type="boolean" required="true">If set to true the task writes start/stop marks to the standard output log (stdout).</property>
			<property name="waitFor" type="boolean" required="true">Defines whether the task should wait until the job finishes. Wait for modes:
					<ul>
						<li>waitFor=true:Task waits until the run command is done. Returned code is then compared against <strong>Expected Return Codes</strong>. If expected codes do not contain the returned code, the task fails.</li>
						<li>waitFor=false:Task starts up the command and then terminates immediately. This means that there is no valuable return code to compare against <strong>Expected Return Codes</strong>, therefore this comparison is skipped. Task finishes in OK state and the result of the task is set to -1 (&quot;unknown&quot; value).</li>
					</ul>
				</property>
			<property name="workingDir" type="string" required="false">Working directory. Default value: current java-process directory (usually value of &quot;usr.dir&quot; property)</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.s3.services.S3HealthStateProvider">
    <introduction>Adds sensor to the Server Health Status section of the Admin Center. Sensor reports health status of the Amazon S3 server connections.</introduction>
    <description>Adds sensor to the Server Health Status section of the Admin Center. Sensor reports health status of the Amazon S3 server connections.</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="dataSourceRefreshRate" type="integer" required="true">Frequency of the database connections health state refresh.</property>
		</properties>
  </class>
  <class name="com.ataccama.extension.saprfc.dqc.io.SapRfcExecute">
    <introduction>Allows users to execute SAP functions on SAP RFC data.</introduction>
    <description>Modifies SAP RFC data using a preconfigured SAP function and writes its output results. The availability of function modules depends on the connected SAP system. The results are outputted to a suitable format, for example, a database or an XML file.</description>
    <properties>
			<property name="columns" type="com.ataccama.extension.saprfc.dqc.io.SapRfcExecuteColumn[]" required="false">Definition of SAP RFC columns. These correspond to the SAP function parameters.</property>
			<property name="functionName" type="string" required="true">Name of the SAP function that will be executed on the data.</property>
			<property name="functionParameters" type="com.ataccama.extension.saprfc.dqc.io.SapRfcExecuteColumn[]" required="false">Definition of the SAP function parameters. The necessary parameters are automatically loaded after the function is selected.</property>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="server" type="string" required="true">Name of the SAP RFC server to be used.</property>
			<property name="writeAllColumns" type="boolean" required="true">Specifies whether to write out all columns as defined in the input format. This attribute is exclusive to column definitions. If this option is enabled, then there must be no columns defined in the Columns element, otherwise an error is reported.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.extension.saprfc.dqc.io.SapRfcReader">
    <introduction>Reads data from user&#39;s SAP RFC system.</introduction>
    <description>
		<p align="justify">SAP RFC Reader allows users to connect to an SAP RFC server. The Remote Function Call (RFC) interface enables communication between remote SAP systems. The data retrieved can then be profiled and documented.</p>
		<p align="justify">The step can only be used if ONE Desktop is connected to an SAP RFC server. It is possible to select which table is loaded from SAP RFC, as well restrict the maximum number of records read.</p>
	</description>
    <properties>
		<property name="columns" type="com.ataccama.extension.saprfc.dqc.io.SapRfcColumn[]" required="true">Definition of columns which will be read from the SAP RFC table.</property>
		<property name="id" type="string" required="false">Step identification string.</property>
		<property name="numberOfRows" type="integer" required="true">The maximum number of rows that will be read from the selected table.</property>
		<property name="server" type="string" required="true">Connection details for connecting to the SAP RFC server (File Explorer &gt; Servers).</property>
		<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result of <strong>Default Expression</strong>.</property>
		<property name="tableName" type="string" required="true">You will be provided with a <strong>Choose Item</strong> dialog where you choose an SAP RFC table (available tables are listed here). Once you make your selection, the identification of that table will be stored in this property.</property>
	</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.adt.task.exec.SCPDownloadFile">
    <introduction>Downloads a remote file from a specified host via the SCP protocol.</introduction>
    <description>Downloads a remote file from a specified host via the SCP protocol.</description>
    <properties>
			<property name="file" type="string" required="true">Remote path to the file/directory for download. A directory is downloaded into the Target Directory including its files (without recursion).</property>
			<property name="knownHostsPath" type="string" required="false">Local path to the known hosts file.</property>
			<property name="privateKeyPath" type="string" required="false">Local path to the private key for SSH authentication.</property>
            <property name="sessionParameters" type="com.ataccama.adt.task.base.JschSessionParameter[]" required="false">Set of parameters to customize a JSch session.<br/>
                <strong>Note:</strong> When connecting to server that still uses deprecated <em>ssh-rsa</em> algorithm, session parameter <em>server_host_key</em> must be set to <em>ssh-rsa</em>.</property>
            <property name="targetDirectory" type="string" required="true">Path to the destination directory. The directory can be local, on Amazon S3 server and on HDFS (if your product package contains Big Data Engine).</property>
			<property name="urlResource" type="string" required="true">Name of the URL resource to be used.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.SCPUploadFile">
    <introduction>Uploads a local file to a specified host via the SCP protocol.</introduction>
    <description>Uploads a local file to a specified host via the SCP protocol.</description>
    <properties>
			<property name="file" type="string" required="true">Path to the file or directory to upload. The file/directory can be local, on Amazon S3 server and on HDFS (if your product package contains Big Data Engine).
				<p align="justify">A directory is uploaded into the Target Directory including its files (without recursion).</p>
      </property>
			<property name="knownHostsPath" type="string" required="false">Local path to the known hosts file.</property>
			<property name="privateKeyPath" type="string" required="false">Local path to the private key for SSH authentication.</property>
            <property name="sessionParameters" type="com.ataccama.adt.task.base.JschSessionParameter[]" required="false">Set of parameters to customize a JSch session.<br/>
                <strong>Note:</strong> When connecting to server that still uses deprecated <em>ssh-rsa</em> algorithm, session parameter <em>server_host_key</em> must be set to <em>ssh-rsa</em>.</property>
            <property name="targetDirectory" type="string" required="true">Remote path to the destination directory.</property>
			<property name="urlResource" type="string" required="true">Name of the URL resource to be used.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.SFTPDownloadFile">
    <introduction>Downloads a remote file from a specified host via the SFTP protocol.</introduction>
    <description>Downloads a remote file from a specified host via the SFTP protocol.</description>
    <properties>
			<property name="file" type="string" required="true">Remote path to the file/directory for download. A directory is downloaded into the Target Directory including its files (without recursion).</property>
			<property name="knownHostsPath" type="string" required="false">Local path to the known hosts file.</property>
			<property name="privateKeyPath" type="string" required="false">Local path to the private key for SSH authentication.</property>
			<property name="sessionParameters" type="com.ataccama.adt.task.base.JschSessionParameter[]" required="false">Set of parameters to customize a JSch session.<br/>
                <strong>Note:</strong> When connecting to server that still uses deprecated <em>ssh-rsa</em> algorithm, session parameter <em>server_host_key</em> must be set to <em>ssh-rsa</em>.</property>
			<property name="targetDirectory" type="string" required="true">Path to the destination directory. The directory can be local, on Amazon S3 server and on HDFS (if your product package contains Big Data Engine).</property>
			<property name="urlResource" type="string" required="true">Name of the URL resource to be used.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.SFTPUploadFile">
    <introduction>Uploads a local file to a specified host via the SFTP protocol.</introduction>
    <description>Uploads a local file to a specified host via the SFTP protocol.</description>
    <properties>
			<property name="file" type="string" required="true">Path to the file or directory to upload. The file/directory can be local, on Amazon S3 server and on HDFS (if your product package contains Big Data Engine).
				<p align="justify">A directory is uploaded into the Target Directory including its files (without recursion).</p>
      </property>
			<property name="knownHostsPath" type="string" required="false">Local path to the known hosts file.</property>
			<property name="privateKeyPath" type="string" required="false">Local path to the private key for SSH authentication.</property>
            <property name="sessionParameters" type="com.ataccama.adt.task.base.JschSessionParameter[]" required="false">Set of parameters to customize a JSch session.<br/>
                <strong>Note:</strong> When connecting to server that still uses deprecated <em>ssh-rsa</em> algorithm, session parameter <em>server_host_key</em> must be set to <em>ssh-rsa</em>.</property>
            <property name="targetDirectory" type="string" required="true">Remote path to the destination directory.</property>
			<property name="urlResource" type="string" required="true">Name of the URL resource to be used.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ca.SINValidatorAlgorithm">
    <introduction>Validates Canadian Social Insurance Number.</introduction>
    <description>
			Tests the input string as a SIN (Social Insurance Number - Canadian personal ID) and verifies its validity.
			A valid SIN is a 9-digit number which fulfills a specific check sum. All non-digit characters that appear in the input string
			are removed before the actual validation - only digits are processed.
		</description>
    <properties>
	     	<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    	  	<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="omitInvalidSIN" type="boolean" required="true">
			Flag that determines whether invalid SIN numbers should be replaced in the output binding <code>Sin Out</code>
			by an empty string (flag set to <code>true</code>) or written to the output (flag set to <code>false</code>).
			<br/>Default value: <code>False</code>
			</property>
			<property name="preserveInputValue" type="boolean" required="true">
			Flag that determines whether the original SIN value is written to the the output binding <code>Sin Out</code>
			(flag set to <code>true</code>) or the corrected SIN value is written to the output (flag set to <code>false</code>).
			<br/>
			Default value: <code>False</code>
        <br/>
			</property>
			<property name="sin" type="string" required="true">
				Column that contains SIN numbers to be verified.
			</property>
			<property name="sinOut" type="string" required="true">
				Column that stores processed SIN numbers.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="SV_SIN_MISSING">
			A scoring flag indicating that the input string contained either no valid data
			or no data at all.
			</scoringKey>
			<scoringKey name="SV_INVALID_LENGTH">
			A scoring flag indicating that the number of digits in the input string was a number other than 9.
			</scoringKey>
			<scoringKey name="SV_INVALID_CHECK">
			A scoring flag indicating that the input SIN did not pass the validity tests (i.e. it is an invalid SIN).
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.jdbc.execute.SQLAfterFailStrategyEnum">
    <description>Defines how to go on after failure when processing an sql command.</description>
  </class>
  <class name="com.ataccama.dqc.tasks.jdbc.execute.SQLErrorHandler">
    <description/>
    <properties>
			<property name="errorColumn" type="string" required="true">
			   If this property is filled then a column named by this property is created on
			   the err end point and if an erroneous row is sent to the err end point then the
			   description of the error is written to the error column.
			</property>
			<property name="afterFailStrategy" type="com.ataccama.dqc.tasks.jdbc.execute.SQLAfterFailStrategyEnum" required="true">
			   Type of the strategy to handle failures.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.jdbc.execute.SQLExecute">
    <introduction>
			Executes a SQL command with parameters read from a row in the data flow.
		</introduction>
    <description>
		    Executes a defined SQL command/procedure call over the input data and writes its output values.
			This step performs some write-like SQL commands for each input row. It provides attributes
			to affect batch size and commit size.<br/>
      <br/>
			<strong>Usage notes</strong>
			<ul>
				<li>This step is suitable for write-like operations only (must NOT return a result set). 
					  When there is a result set as the result of query execution, an error is thrown. 
					  This is considered a configuration problem that should be be fixed. For read-like 
					  operations use the <strong>SQL Select</strong> 
					  step.</li>
				<li>Because it is not possible now to analyze a SQL command without being run, some 
					problems are reported after the first result set is obtained (validation of the 
					result of the SQL query). Note that when an error is thrown at this moment, then 
					the state is as follows: 1) possible <code>beforeScript</code> is executed and 
					commited 2) query is commited only if connection enforces autocommit mode 
					3) afterScript is not executed.</li>
				<li>The step requires one input and has an optional output. If no output is specified the SQL 
					command	is performed without writing data to the output.</li>
				<li>Placeholders can be inserted in any part of the SQL query and are replaced before the query executed. This allows you to define custom schema or table names, etc.</li>
				<li>A warning is shown if a placeholder is provided in the query but not defined in the table. Specifying two placeholders with the same name results in an error. </li>
				<li>Placeholders can only be used in non-batching strategies. Therefore, when placeholders are specified, the batch size is automatically set to 0.</li> 					
			</ul> 
			<br/>
      <br/>
			<strong>Parameter processing</strong>
      <br/>
			The SQL command uses a special form for parameter definition. The general syntax is:
			 <code>$[direction]{columnName}</code> where <code>direction</code> is one of following:
			 <ul>
			 	<li>empty string - defines the INPUT parameter</li>
			 	<li>&#39;+&#39; - defines the OUTPUT parameter</li>
			 	<li>&#39;*&#39; - defines the INOUT parameter (of the procedure)</li>
			 </ul> 
			The name of an input column must be given as <code>columnName</code>, otherwise the 
			step will report an error.
			<br/>
      <br/>

			<strong>SQL query notes:</strong>
      <br/>
			<ul>
				<li>Parameter cannot stand for the column or variable names. Also constructs such as <code>create function</code>
				must not be used as parameters since all of those constructs modify the structure of the query and therefore
				the query execution itself (in DB engine). When there&#39;s need to use parameters in these places - for example
				you need to use something like this: <br/>
				<code>select ${column_name} as my_out from some_table</code>
          <br/>
				then you must use <strong>Dynamic SQL</strong>. Dynamic SQL is the way how to execute dynamically created queries 
				in the runtime. Note that dynamic SQL is DB dependent and some DB engines support it (Oracle, MS SQL, PostgreSQL...) 
				while some others don&#39;t (mySQL for example). To find out how to write Dynamic SQL query, please consult your DB engine
				documentation.<br/>
          <br/>
				</li>
				<li>
				it is not recommended to put comments and other unnecessary parts in the SQL command since it may become unparsable 
				for JDBC drivers (they may not support these items).
				</li>
			</ul>

			<strong>Parameter types</strong>
      <br/>		
			When a parameter is defined as an input, then the value from the associated column is read and put to the command as it&#39;s 
			parameter before command execution. Similarly the output parameter&#39;s assigned column is filled with values taken 
			from the SQL command after the command&#39;s execution. <code>INOUT</code> parameters do both of 
			read and write operations.
			<br/>
      <br/>
			
			<strong>Execution mode</strong>
      <br/>
			This step may perform SQL execution in two modes: traditional SQL query mode and procedure 
			call query mode. The decision what mode to use is done automatically and is based on the 
			parameters defined in the query. If there&#39;s some <code>OUTPUT</code> or <code>INOUT</code> 
			parameter defined, then the procedure call mode is used	(because it is the only mode that 
			supports <code>OUT</code> parameters).
			<br/>
      <br/>
			
			When there are no parameters or all of parameters are INPUT ones then the traditional 
			querying mode is used. Nevertheless, it is possible to &quot;force&quot; the step to use procedure 
			call mode even for input-only parameter queries by using a &quot;procedure-call 
			scheme&quot;. It has the following format for procedure call:<br/>
				<code>{ call procedureName(attributes,...) } </code> <br/>
			and similarly the following format for the function call:<br/>
				<code>{ result = call functionName(attributes,...) } </code> <br/>
			<br/>
				
			To identify the query as the procedure call query, the query&#39;s first non-blank character must 
			be <code>&#39;{&#39;</code>	and the last non-blank character must be <code>&#39;}&#39;</code>.
			<br/>
      <br/>
			
			<strong>Batching and commiting</strong>
      <br/>
			This step supports various <code>batchSize</code> and <code>commitSize</code> settings 
			(see the parameters&#39; descriptions) with the following effects:
			<ul>
			   	<li>
          <code>commitSize=1</code> emulates &quot;autocommit&quot; mode</li>
			   	<li>
          <code>batchSize=0</code> enforces &quot;no batching&quot; mode - this prevents algorithm to use 
			   	      JDBC batching mechanism (addBatch) - classical statement.execute is used instead</li>
			    <li>
          <code>batchSize</code> is ignored when the SQL command is a procedure call or 
			    contains OUT or INOUT parameters. In that case the command is executed as 
			    non-batched to allow reading of possible output parameters of each statement.</li>
			</ul>
			
			<br/>
      <br/>
			<strong>Note:</strong> the possibility of using this step effectively depends heavily on the
			JDBC driver&#39;s abilities. As of now, the jTDS, MS SQL, DB2, Oracle and mySQL 
			drivers were tested and only the DB2 and Oracle drivers seem to have support for complex 
			usage (usage of INPUT/OUTPUT parameters together in a traditional (nonprocedural) 
			SQL query). The other ones seems to support OUTPUT parameters only if the 
			&quot;procedure-call scheme&quot; query is used.
			<br/>
			Values read/written to the database depends on the <strong>JDBC 
			types conversion</strong>.	
		</description>
    <properties>
			<property name="id" type="string" required="false">Step identification string. </property>
			
			<property name="afterScript" type="string" required="false">SQL script to execute after step processing is done.</property>
			<property name="batchSize" type="integer" required="true">Determines the size of the batch to use when updating the database. Note that batch size is used only if the query is not a procedure call. Default value: 0 (non batching mode). Reasonable values start at about 1000.</property>
			<property name="beforeScript" type="string" required="false">SQL script to execute before the step is run.</property>
			<property name="dataSourceName" type="string" required="true">Data source definition to use.</property>
			<property name="query" type="string" required="true">SQL query to execute. See the detailed step description for information how to define query parameters.</property>
			<property name="commitSize" type="integer" required="true">Defines after how many statements commit should be invoked. A value of 1 means autocommit. </property>
			<property name="errorHandler" type="com.ataccama.dqc.tasks.jdbc.execute.SQLErrorHandler" required="false">Defines behavior when some exceptions happen during processing the query.</property>
			<property name="placeholders" type="com.ataccama.dqc.tasks.placeholders.SQLPlaceholder[]" required="false">Placeholders</property>
			<property name="placeholderBeginMark" type="string" required="false">The string marking the beginning of column placeholder.</property>
			<property name="placeholderEndMark" type="string" required="false">The string marking the end of column placeholder.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.placeholders.SQLPlaceholder">
    <description> </description>
    <properties>
			<property name="name" type="string" required="true">The name of the placeholder. Must not use white-spaces, question marks, and #cursor# substring.</property>
			<property name="value" type="string" required="true">The value with which the placeholder is replaced. Using expressions is allowed. </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.jdbc.execute.SQLSelect">
    <introduction>Reads additional data from a database and puts it into the output data flow.</introduction>
    <description>
			This step reads some data from a database using a SQL command that may be parameterized with
			some data from the input row. For every entry of the SQL command&#39;s result set it creates a copy of the
			processed input row with data from the result set row added according to the given
			mappings.
			<br/>
      <br/> 
			In another words, if the SQL command returns <code>n</code> rows in the result set, then 
			there are <code>n</code> copies of the input row in the output, with data from the 
			respective result set row added.
			<br/>
      <br/>
			If there is an input row for which the SQL command does not return any entry in the result set, 
			there is no entry for such row in the output data flow as well. This means that such 
			input row is &quot;dropped&quot; from the data flow. This behavior may be overridden by setting
			<code>Include Empty</code> to true (default value). This will cause &quot;empty&quot; input 
			rows to be written to the output as well (result set mapped columns will be empty then).
			<br/>
      <br/>
			<strong>Usage notes</strong>
      <br/>
			<ul>
				<li>This step is suitable for read-like operations only (must return a result set). 
				For write-like operations use the <strong>SQL Execute</strong> 
			    step.</li>
				<li>When there is no result set as the result of the query execution, an error is thrown. This
				is considered a configuration problem that needs to be fixed.</li>
				<li>Because it is not possible now to analyze a SQL command without being run, some
				problems are reported after the first result set is obtained. Those are validations of 
				mapped result set columns, whether the query returns a result set, etc. Note
				that when error is thrown at this moment, the state is as follows: 
				1) possible <code>Before Script</code> 
				is executed and committed 2) statement for the first row is not committed 
				3) <code>After Script</code> is not executed</li>
			<li>Placeholders can be inserted in any part of the SQL query and are replaced before the query executed. This allows you to define custom schema or table names, etc.</li>
			<li>A warning is shown if a placeholder is provided in the query but not defined in the table. Specifying two placeholders with the same name results in an error.</li> 
			</ul>
			<br/>
			<strong>Processing parameters</strong>
      <br/>
			For a detailed description of how to define input and output parameters of the SQL query see
			the description of the <strong>SQL Execute</strong> 
			step. This step uses parameters the same way.
			<br/>
      <br/>
			<strong>ORACLE cursors:</strong>
      <br/>
      <br/>
			Step supports reading data returned by Oracle&#39;s stored procedures using cursors. To read from 
			a cursor use the following syntax:<br/>
      <br/>
			<code>{ call ${#cursor#} := sp_procedure_name(${parameter},...) }</code>
      <br/>
      <br/>
			Cursor value is identified by the special variable-keyword <strong>#cursor#</strong> - this
			will cause reading result set data from the variable rather than from the statement&#39;s result
			set.<br/> 
			<strong>Take care of proper spacing</strong>: same spacing as the one in the example
			should be used, otherwise Oracle may reject the query.
			<br/>
      <br/>
			<strong>Mapping result set values</strong>
      <br/>
			To map values from the result set to the data rows, mappings must be provided.
			To determine SQL output column names reliably, it is strongly recommended to name output 
			columns in the query using SQL&#39;s <code>AS</code> operator. In some cases this is necessary, such as 
			when, for example, the SQL query returns an unnamed column, then it is not possible to 
			access it via mappings unless it is named with the AS operator to something nonempty (because
			the mapping&#39;s <code>sqlColumn</code> value is required and it cannot be empty).
			<br/>
      <br/>
			<strong>NOTE:</strong> Some database drivers (for example Oracle, ApacheDerby and possibly 
			some others) return names of the result set columns in uppercase (even for column names 
			defined with the <code>AS</code> operator). If this is the case, then uppercase names
			must also be used in result set column mappings, since name matching is case sensitive
			there. The same problem may occur with diacritics. Again, the same form must be used either
			in the SQL query and result set mapping.
			<br/>
      <br/>
			To convert SQL values to data flow values the <strong>JDBC data 
			conversion</strong> is used.		
			<br/>
      <br/>		
		</description>
    <properties>
			<property name="id" type="string" required="false">Step identification string. </property>
			<property name="afterScript" type="string" required="false">SQL script to execute after step processing is done.</property>
			<property name="beforeScript" type="string" required="false">SQL script to execute before the step is run.</property>
			<property name="dataSourceName" type="string" required="true">Data source definition to use.</property>
			<property name="includeEmpty" type="boolean" required="true">If false, only input records that yield records in the SQL result set are sent to the output. If set to true, then the processed input row is sent to the output even if there are no entries in the result set. Default value: true.</property>			
			<property name="query" type="string" required="true">Select-like SQL query to execute.</property>
			<property name="mappings" type="com.ataccama.dqc.tasks.jdbc.execute.ColumnMapping[]" required="true">Mappings that define where to map values read from the result set.</property>
			<property name="errorHandler" type="com.ataccama.dqc.tasks.jdbc.execute.SQLErrorHandler" required="false">Defines behavior when some exceptions happen during processing the query.</property>
			<property name="autocommit" type="boolean" required="true">Defines whether the statement should be committed after each row.</property>
			
			<property name="placeholderBeginMark" type="string" required="false">The string marking the beginning of column placeholder.</property>
			<property name="placeholderEndMark" type="string" required="false">The string marking the end of column placeholder.</property>
		</properties>
  </class>
  <class name="com.ataccama.extension.salesforce.dqc.io.SalesforceColumn">
    <description>This element is used to define SObject columns that should be present in the output. </description>
    <properties>
			<property name="name" type="string" required="true">Specifies the name of the SObject column to be written to the output.</property>
			<property name="type" type="com.ataccama.dqc.commons.type.DataType" required="true">Data type of the specific column.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.extension.salesforce.dqc.io.SalesforceReader">
    <introduction>Reads data from user&#39;s Salesforce application.</introduction>
    <description>
			<p align="justify">Salesforce Reader allows users to connect to the backend of all Salesforce systems. The data retrieved can then be profiled and documented.</p>
			<p align="justify">The step can only be used if ONE Desktop is connected to a Salesforce server. It is possible to select which SObject is loaded from Salesforce, as well restrict the maximum number of records read.</p>
			</description>
    <properties>
			<property name="SObject" type="string" required="true">You will be provided with a <strong>Choose Item</strong> dialog where you select an SObject (available SObjects are listed here). Once you make your choice, the identification of that SObject will be stored in this property.</property>
			<property name="columns" type="com.ataccama.extension.salesforce.dqc.io.SalesforceColumn[]" required="true">Definition of columns which will be read from the SObject.</property>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="limit" type="integer" required="true">The maximum number of rows that will be read from the selected SObject.</property>
			<property name="server" type="string" required="true">Connection details for connecting to the Salesforce server (File Explorer &gt; Servers).</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">The <strong>Shadow Columns</strong> are used by steps to define new columns of a specific type in the output format. The created columns can contain initial data as a result of <strong>Default Expression</strong>.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.extension.salesforce.dqc.io.SalesforceWriter">
    <introduction>Allows users to update or delete data in Salesforce SObjects.</introduction>
    <description>
			<p align="justify">This step is used for modifying data in SObjects using one of the following operations:</p>
			<ul>
				<li>
					<code>INSERT</code>
					: Creates a new column.
				</li>
				<li>
					<code>UPDATE</code>
					: Updates a column. In this case, the SObject ID field  or external ID column must be specified in the Columns element.
				</li>
				<li>
					<code>UPSERT</code>
					: Creates a new column or updates an existing one, depending on whether a column with the same name is already present in the SObject or not.
				</li>
				<li>
					<code>DELETE</code>
					: Moves a column to the Salesforce Recycle Bin. In this case, the SObject ID field must be specified in the Columns element.
				</li>
				<li>
					<code>HARD_DELETE</code>
					: Deletes a column permanently. In this case, the SObject ID field or external ID column must be specified in the Columns element.
				</li>
			</ul>
		</description>
    <properties>
			<property name="SObject" type="string" required="true">Name of the target SObject.</property>
			<property name="columns" type="com.ataccama.extension.salesforce.dqc.io.SalesforceWriterColumn[]" required="false">Definition of SObject columns.</property>
			<property name="externalIdName" type="string" required="false">
				Name of the column to be modified. Must match an existing column in the SObject. If the selected operation type is
				<code>INSERT</code>
				, a column with this name will be created.
			</property>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="operation" type="com.ataccama.extension.salesforce.dqc.io.SalesforceWriter$Operation" required="true">Type of operation that will be performed on the selected SObject.</property>
			<property name="server" type="string" required="true">Name of the Salesforce server to be used.</property>
			<property name="writeAllColumns" type="boolean" required="true">Specifies whether to write out all columns as defined in the input format. This attribute is exclusive to column definitions. If this option is enabled, then there must be no columns defined in the Columns element, otherwise an error is reported.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.extension.salesforce.dqc.io.SalesforceWriterColumn">
    <description/>
    <properties>
			<property name="expression" type="string" required="false">If set, it specifies the expression to execute in order to get the value that will be written to the column. If no expression is defined, the value corresponding to the value of the input column with the same name as the <code>Name</code> attribute will be written to the table.</property>
			<property name="name" type="string" required="true">Specifies the name of the destination column to be written. When the <code>Expression</code> property is not set, it also specifies the name of the source column.</property>
			<property name="type" type="com.ataccama.dqc.commons.type.DataType" required="false">Data type of the output column.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.global.sampling.SamplingParams">
    <properties/>
  </class>
  <class name="com.ataccama.extension.saprfc.dqc.io.SapRfcColumn">
    <description>This element is used to define SAP RFC table columns that should be present in the output.</description>
    <properties>
		<property name="name" type="string" required="true">Specifies the name of the SAP RFC table column to be written to the output.</property>
		<property name="type" type="com.ataccama.dqc.commons.type.DataType" required="true">Data type of the specific column.</property>
	</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.extension.saprfc.dqc.io.SapRfcExecuteColumn">
    <description> </description>
    <properties>
			<property name="expression" type="string" required="false">Expression which is evaluated for the SAP input data. The expression might include definitions and operations on input columns.</property>
			<property name="name" type="string" required="true">SAP RFC input column name.</property>
			<property name="type" type="com.ataccama.dqc.commons.type.DataType" required="false">Data type of the SAP RFC input column.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.hadoop.io.spark.ISparkWriterSaveOptions" name="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriterSaveOptions">
    <properties>
			<property name="savePath" type="string" required="false">Path to the file/folder which should be read by Spark Reader step. By default, it is reading the data from cluster file system, e.g. HDFS. If you need to read the data from Google Cloud Storage, Azure Data Lake Storage or S3, you can use resources.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.hadoop.io.spark.ISparkWriterSaveOptions" name="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriterSaveAsTableOptions">
    <properties>
			<property name="tableName" type="string" required="true">Name of the table where the content of the DataFrame will be saved.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.adt.scheduler.server.SchedulerServerComponent">
    <introduction>
			Adds Scheduler page to Admin Center and enables scheduling and running generic jobs.
		</introduction>
    <description>
			Adds Scheduler page to Admin Center and enables scheduling and running generic jobs. Scheduler component can be used only together with a <strong>Workflow Server Component</strong>.
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="resourcesFolder" type="string" required="true">Relative (to the server configuration file) or absolute location where scheduler stores its supporting files such as generator state-file, id mapper etc. It is also the location where job execution state files are stored (if the filesystem persister is used).</property> 
			<property name="resultPersister" type="com.ataccama.adt.scheduler.persister.IRunResultPersister" required="true">Defines which backend should be used for storing the job execution states. Currently, there are two storage provider implementations: DB persister and filesystem persister.</property>
			<property name="sources" type="com.ataccama.adt.web.SourceConfigBean[]" required="false">Defines a set of sources which will be used for reading the schedules.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.discovery.schema.SchemaDiscovery">
    <introduction>Finds possible primary and foreign key pairs across all provided tables.</introduction>
    <description>
			Relationships between two tables and their columns are represented by primary and foreign key pairs.
			The discovery of these pairs is based on a simple fact that a set of distinct foreign key values is	always
			a subset of a set of primary key values. While this condition is essential for the pair of a primary
			and a foreign key, it is not determinative. Many of the inclusion pairs may be false positives.
			
			The step computes so called inclusion dependencies. An inclusion dependency is a relation between a referenced
			column (a potential primary key) and a dependent column (a potential foreign key) that holds if distinct values
			of dependent column are all included in values of referenced column.
			
			The step returns all inclusion dependencies where the referenced columns are unique.
			
			A leeway can be defined so that not all of the distinct values of a dependent column must be present in the referenced
			column. This aims e.g. for cases with failed or missing cascading operations on tables. Note that specifying this value
			may lead to an increase of the computation time.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="inputs" type="com.ataccama.dqc.tasks.discovery.schema.config.TableInput[]" required="true">
			List of input sources on which the discovery is performed. Each element needs an 
			appropriate input endpoint.
			</property>
			<property name="defaultInclusionLeeway" type="float" required="false">
				Maximum percent of values of a dependent column that may not be included
				in the values of a referenced columns. It&#39;s computed against the number of
				distinct values of the dependent column.
			</property>
			<property name="maxKeyLength" type="integer" required="false">
				Maximum length of a column value for the column to be considered as a key. If a value of a column exceeds this bound,
				the column will be eliminated from the computation. 
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.model.evaluation.Scoring">
    <description>
    		Scoring configuration is done with the help of pseudo inputs
    		that are to be used in any of the expressions that the Scoring provides.
    		The pseudo inputs are as follows:
    		
    		<ul>
    			<li>ia – Input entity</li>
    			<li>pa - Proposed entity</li>
    			<li>expl – Entity explanation</li>
    			<li>unexpl - Unexplained parts</li>
    			<li>const – Constants for explanation. This represents a constant 
    				record with the fixed values: <code>missing</code>, <code>found</code>, <code>approx</code>
    				and <code>not_defined</code>.
    				Its sole purpose is to compare with values in the <code>expl</code> pseudo input</li>
    			<li>e – Count of different characters during approximate searching</li>
    		</ul>
    		
    		The following pseudo inputs are available only when expert settings 
    		allows advanced scoring:
    		<ul>
    			<li>z – Count of missing characters during truncation of a word. The truncation is triggered either by a dot character
    				or a space or end of input. If it was triggered by a dot, this dot is not considered as unexplained text.</li>
    			<li>d – Count of characters with a missing diacritic</li>
    			<li>x - Count of letters occurring in the input text in addition 
    				to the dictionary value. An example of this case is the street B. Nemcove, 
    				which might be expanded to Bozeny Nemcove, and in such case the value
    				of the input for the street is 5. The expansion might occur more
    				than once, such as in: Jaromerice n. R. -&gt; Jaromerice nad Rokytnou, where
    				the value is 9.
    				This expansion is available only for dictionary values that contain dot(s).
    			</li>
    		</ul>

			Each pseudo-input except the <code>const</code> input includes address components,
			which are defined in the reference data configuration.<br/>
			<code>Unexpl</code> pseudo-input contains column with unexplained text for each input element and also 
			an aggregated concatenation of all these parts in a column <code>total</code>. Note
			that a pipe character (<code>|</code>) is used as a separator. 
    	</description>
    <properties>
    		<property name="when" type="string" required="true">
    			Determines when score and explanation values are written into the resulting score.
    			Default value: None.
    		</property>
      		<property name="score" type="string" required="true">
      			Integer expression whose result is added to the score column after accomplishing the <code>When</code> condition.
      			<em>Caution:</em> if the scoring for the input address evaluates to null, the overall scoring is also null.
      			Default value: None.
      		</property>
      		<property name="explanation" type="string" required="true">
      			String expression whose result is appended to the explanation column after accomplishing the <code>When</code> condition.
      			Unlike the score property, this expression may evaluate to null in which cases the &quot;null&quot; string is appended
      			to the result to emphasize that such scoring was effective.
      			Default value: None. 
      		</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.scoring.ScoringEngineStep">
    <introduction>Scores and flags input records according to defined rules.</introduction>
    <description>
		This step analyzes input data according to given rules. The rule is
		actually an expression and some intervals against the expression value are checked.
		The rules can be nested. This means that if some expression value falls into an interval
		then it can be checked against a nested rule if there is one defined. Each interval can increment the score.
		The scoring and explanation output columns can be defined at the step level.
		If a finer scoring output is required, scoring columns can be defined for each interval.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
		  <property name="rules" type="com.ataccama.dqc.tasks.scoring.ScoringEngineNode[]" required="true">
		  A set of rules. There can be multiple rules.
		  </property>
		  <property name="defaultExplainColumn" type="string" required="false">
		  		The default explanation column. The explanation values are appended and are separated
		  		by a space. This value will be overridden if explanationColumn is filled in.
		  </property>
		  <property name="defaultScoreColumn" type="string" required="false">
		  		The default scoring column. The scoring values are incremented.
		  		This value will be overridden if scoreColumn is filled in.
		  </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.scoring.ScoringCase">
    <properties>
			<property name="condition" type="string" required="true">
				The condition that the result of Scoring Simple depends on.
			</property>
			<property name="description" type="string" required="false">
			A description of this case.
			</property>
			<property name="explanation" type="string" required="false">
				The explanation text which is appended to the value in explanation column.
			</property>
			<property name="explanationColumn" type="string" required="false">
				The column where the explanation is stored. This value overrides the default column.
			</property>
			<property name="score" type="string" required="true">
			Expression returning the score (plus correction property) value which is incremented to
			the whole score.
			</property>
			<property name="scoreColumn" type="string" required="false">
				The column where the score is stored. This value overrides the default column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.scoring.ScoringEngineCase">
    <properties>
			<property name="value" type="string" required="false">
			A comma separated list of items. An item is either an interval, a value or the literal &quot;NULL&quot; (without quotes).
			The interval has a mathematical
			syntax: (|&lt;&quot;literal&quot;;&quot;literal&quot;&gt;|). The value symbols can be separated by
			white spaces. The literals can be written without double quotes if they don&#39;t
			contain commas or double quotes. If they contain such letters then they must be
			surrounded by double quotes. To match a double quote, use two double quotes (&quot;&quot;). When this
			property is set to &quot;NULL&quot; (without quotes), it matches attributes with a value of
			null. This value is required when the defaultCase property is set to false.
			</property>
			<property name="score" type="string" required="true">
			The score (plus correction property) value which is added to the whole score.
			</property>
			<property name="correction" type="string" required="true">
			The correction is simply added to the score property.
			</property>
			<property name="defaultCase" type="boolean" required="true">
			This case will be chosen if no other cases are chosen. Only one
			case under one node can be marked as default. A default case is not required.
			</property>
			<property name="explanation" type="string" required="false">
			The explanation text which is appended to the value in the explanation column.
			</property>
			<property name="scoreColumn" type="string" required="false">
			The column where the score is stored. This value overrides the default column.
			</property>
			<property name="explanationColumn" type="string" required="false">
			The column where the explanation is stored. This value overrides the default column.
			</property>
			<property name="description" type="string" required="false">
			A description of the case.
			</property>
			<property name="childRule" type="com.ataccama.dqc.tasks.scoring.ScoringEngineNode" required="false">
			If the process falls into this case then it is scored according to
			this case and then continues processing to its childRule.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.scoring.ScoringEngineNode">
    <properties>
			<property name="condition" type="string" required="true">
			An expression evaluating a value which is compared to the cases.
			</property>
			<property name="cases" type="com.ataccama.dqc.tasks.scoring.ScoringEngineCase[]" required="false">
			Cases that the expression values are compared against.
			</property>
			<property name="name" type="string" required="false">
				The rule name.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.nme.dqc.steps.MdcRead$SearchExpression">
    <properties>
            <property name="entityColumn" type="string" required="true">
                Column in MDM model.
            </property>
            <property name="operator" type="string" required="true">
                Condition relational operator.
                For LIKE operator, use * in search expression to indicate wildcard, e.g. LIKE &quot;Ja*&quot; will match &quot;Jane&quot; and &quot;Jack&quot;.
            </property>
            <property name="expression" type="string" required="true">
                An expression whose result is used as condition value.
                For a list of all available expressions and their definitions, refer to <strong>Expressions</strong>.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ISearchMethodDefinition">
    <introduction>
	       Definition of component search method.  
	   </introduction>
    <properties>
		  <property name="inputComponents" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference[]" required="true">
		      List of input components to be searched for.
		  </property>
		  
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.timeseries.settings.ModelSettings" name="com.ataccama.dqc.tasks.ai.timeseries.settings.SeasonalNaiveModelSettings">
    <introduction>
            Naive model that uses values from previous periods for predictions.
        </introduction>
    <description>
            <p align="justify">
                Model that uses corresponding values from the previous <code>Max Number Of Periods</code>
                (or less, if there is not enough past periods). For each pair of values in consecutive periods,
                diff or ratio are computed for additive or multiplicative models, respectively.
                Last period value is increased or multiplied by the average of previously computed values.
                If <code>Max Number Of Periods</code> = <code>1</code>,
                only the corresponding value in the last period is used as a prediction.
            </p>
            <p align="justify">
                <strong>Additive model</strong>
                <br/>
                if maxNumberOfPeriods = 1
                <br/>
                then prediction: F(t+m) = x(xLength - period + (m mod period))
                <br/>
                if maxNumberOfPeriods &gt; 1
                <br/>
                then prediction: F(t+m) = x(xLength - period + (m mod period)) + diffAvg
                <br/>
                where diffAvg = sum(i from=1 to=maxNumberOfPeriods - 1)(x(xLength - period * i) - x(xLength - period * (i + 1))) / (maxNumberOfPeriods - 1)
            </p>
            <p align="justify">
                <strong>Multiplicative model</strong>
                <br/>
                if maxNumberOfPeriods = 1
                <br/>
                then prediction: F(t+m) = x(xLength - period + (m mod period))
                <br/>
                if maxNumberOfPeriods &gt; 1
                <br/>
                then prediction: F(t+m) = x(xLength - period + (m mod period)) * ratioAvg
                <br/>
                where ratioAvg = sum(i from=1 to=maxNumberOfPeriods - 1)(x(xLength - period * i) / x(xLength - period * (i + 1))) / (maxNumberOfPeriods - 1)
            </p>
        </description>
    <properties>
            <property name="periods" type="string" required="true">
                Different periods to try in the grid search. Comma separated values.
                <br/>
                Default value = <code>4,7,12</code>.
            </property>
            <property name="maxNumberOfPeriods" type="integer" required="true">
                Maximum number of periods for historical values.
                <br/>
                Default value = <code>2</code>.
            </property>
            <property name="additive" type="boolean" required="false">
                If additive seasonal naive model should be tried in the grid search.
                <br/>
                Default value = <code>true</code>.
            </property>
            <property name="multiplicative" type="boolean" required="false">
                If multiplicative seasonal naive model should be tried in the grid search.
                <br/>
                Default value = <code>true</code>.
            </property>
        <property name="active" type="boolean" required="true">
                If this model should be used in the grid search.
            </property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.IServerAuthenticationMethod" name="com.ataccama.dqc.communication.auth.server.SecretServerMethod">
    <introduction>Provides basic security; can be used only for internal communication.</introduction>
    <description>Provides basic security; can be used only for internal communication, i.e., secret method cannot be used to protect access to deployed web services. The method defines one passphrase (in the <strong>Secret</strong> property) which must be provided. If the passphrase is correct, the request will be assigned the identity defined in the <strong>Identity</strong> element. Possible implementations: Standard Identity, Trust Identity.</description>
    <properties>
			<property name="identity" type="com.ataccama.dqc.commons.security.IIdentity" required="false">Identity definition: identity name and assigned roles. Possible implementations: Standard Identity, Trust Identity.</property>
			<property name="secret" type="string" required="false">Passphrase.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.SeedTable">
    <introduction>Replaces the value in the <em>replacement</em> column of current record with the value in the first encountered record with the same value in the <em>value</em> column.</introduction>
    <description>
			<p align="justify">This step transforms the values in the <em>replacement</em> column.
			</p>
			<p align="justify">When a first record with a certain <em>value</em> comes, this step stores this <em>value</em>-<em>replacement</em> pair and
			for all following records with the same <em>value</em>, the <em>replacement</em> is overwritten with the stored one. The storing
			only occurs if both the value and replacement are non-empty. The pairs are stored in the database and therefore
			persisted.</p>
			<p align="justify">
				The scorer values are as follows:
				<ul>
		 			<li>
            <code>ST_NULL</code> - the <em>value</em> was empty</li>
		 			<li>
            <code>ST_FOUND</code> - the previously stored pair was found and therefore the replacement occurred</li>
		 			<li>
            <code>ST_INSERTED</code> - the pair was not found and therefore the current one was stored for further replacements</li>
		 			<li>
            <code>ST_NOT_FOUND</code> - the pair was not found, but couldn&#39;t be stored because the <em>replacement</em> was empty</li>
		 		</ul>
			</p>
			<p align="justify">
			Only a single Seed Table step should be running over a single table at any given moment. For two or more concurrent steps over a single
			table it is absolutely necessary to set <em>Batch Size</em> and <em>Commit Size</em> to 1. Note that this will cause significant performance drop.
			The alternative of this is to ensure that the <em>value</em> sets for each of the concurrent steps are disjoint, i.e. there is no <em>value</em>
			which occurs in the data sets for more than one of these concurrent steps.
			</p>
			<p align="justify">
			The name of the table that will be used for persisting the value-replacement tuples is derived from a global prefix &quot;ST&quot; and Domain Prefix
			and Table Name properties. The table will be created if it doesn&#39;t exist. If it does exist, it has to have the proper format -
			it has to contain a column named <em>value</em> and a column named <em>replacement</em>, both of a correct type to store strings 
			(char/varchar/varchar2) with the maximum length equal to the step property <em>Maximum String Length</em> value. Index on the column
			<em>value</em> is not needed, but highly recommended.
			</p>
		</description>
    <properties>
			<property name="value" type="string" required="true">
				The <em>value</em> column containing the keys for the transformation.
			</property>
			<property name="replacement" type="string" required="true">
				The <em>replacement</em> column containing the values that will be replaced or used as a replacement value for next records.
			</property>
			<property name="dataSourceName" type="string" required="true">
				Name of the data source.
			</property>
			<property name="domainPrefix" type="string" required="true">
				The name of the table that will be used for persisting the value-replacement tuples is derived from a global prefix &quot;ST&quot; and Domain Prefix
				and Table Name properties. The table will be created if it doesn&#39;t exist. If it does exist, it has to have the proper format (see step description).
			</property>
			<property name="tableName" type="string" required="true">
				The name of the table that will be used for persisting the value-replacement tuples is derived from a global prefix &quot;ST&quot; and Domain Prefix
				and Table Name properties. The table will be created if it doesn&#39;t exist. If it does exist, it has to have the proper format (see step description).
			</property>
			<property name="batchSize" type="integer" required="true">
				The size of the batches in which the transformation is done. For transformation of a single record at a time, this has to be
				set to 1 to avoid unnecessary waiting for following records. For transformation of a large number of records at once, setting this
				to a larger number will improve performance.
			</property>
			<property name="commitSize" type="integer" required="true">
				The number of inserts to database after which a commit is done.
			</property>
			<property name="maximumStringLength" type="integer" required="true">
				The maximum length of both the <em>value</em> and <em>replacement</em> string (each separately, not together). May depend on the
				target database charset.
			</property>
			<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="false">
				Element which stores basic scoring settings.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.select.Selection">
    <description>
		A set and/or subset of data based on some selection rules/criteria.
		</description>
    <properties>
			<property name="count" type="integer" required="true">
			Selection results count.
			</property>
			<property name="method" type="com.ataccama.dqc.tasks.experimental.select.SelectionMethod" required="true">
			Selection criteria/method.
			</property>
			<property name="name" type="string" required="false">
			Selection name referenced in the output.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.select.SelectionMethod">
    <description>
			Defines which records are selected from each group.
			See <strong>description</strong>.
		</description>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.SelectiveTransliterateAlgorithm">
    <introduction>Translates characters.</introduction>
    <description>

                Transforms a specified set of characters from the input column &quot;in&quot; to another character set,
                and sends the result text to the output column &quot;out&quot;.

                The transformation is applied to words. A new word starts either at the beginning of the whole input
                text or after a switch between a sequence of digits+letters and a sequence of special symbols (or vice versa) was detected.
                A word is defined as a successive sequence of digits+letters or as a successive sequence of special symbols.

                Transformation replaces characters occurring in the &quot;from&quot; string by characters at the corresponding positions
                in the &quot;to&quot; string.

                The words which are either shorter than the &quot;minWordLength&quot; parameter value or where transformation would break conditions
                defined by &quot;maxChangeRatio&quot; and &quot;maxConsecutiveChanges&quot;, stay unchanged.
                </description>
    <properties>
                        <property name="from" type="string" required="true">
                        A string defining input characters of the transformation.
                        </property>
                		<property name="in" type="string" required="true">
						Column providing input data.
						</property>
                        <property name="maxChangeRatio" type="double" required="true">
                        Maximum ratio of the replacement count to the input word length. Default value is 0.5.
                        </property>
                        <property name="maxConsecutiveChanges" type="integer" required="true">
                        Maximum count of successive replacements in one word. Default value is 2.
                        </property>
                        <property name="minWordLength" type="integer" required="true">
                        Minimum input word length. Default value is 3.
                        </property>
                   		<property name="out" type="string" required="true">
						Column consuming output data.
						</property>
                        <property name="to" type="string" required="true">
                        A string defining output characters of the transformation. The length must be the same as it is in the &quot;from&quot; parameter value.
                        </property>
                        <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property> 
  						<property name="id" type="string" required="false">
			Step identification string.
			</property> 
                 <property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
                        <scoringKey name="STL_CHANGED">
                         A situation indicating that at least one replacement has been applied (input and output words are different).
                        </scoringKey>
                </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.Selector">
    <introduction>Selects the best record from each group generated by a multiplicative step.</introduction>
    <description/>
    <properties>
			<property name="recordDescriptorColumn" type="string" required="true">
				Name of string input column in which special recordDescriptor is stored.
				The descriptor contains group id, group size and record number in group as
				three numbers separated by colon. For example <code>4152:3:2</code>.
			</property>
			<property name="selectionRules" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="true">
				List of comparisons for select the best (first) record.
			</property>
			<property name="assignments" type="com.ataccama.dqc.tasks.flow.Selector$Assignment[]" required="false">
				List of assignments that will be performed on selected record.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfSendMailTask">
    <introduction>Sends an email to multiple email addresses.</introduction>
    <description>The task sends an email to multiple email addresses. It can also send local attachments (e.g., log files).
			<br/>Note: Result state of this task indicates only that the email was sent successfully to a mail server. It does not indicate whether the email was received by recipients.
			<br/>If you are planning to send emails when a previous task fails, make sure to set the <strong>Continue on Failure</strong> global property to true. For detailed information, see Global Workflow Properties.
			</description>
    <properties>
			<property name="attachFiles" type="com.ataccama.adt.task.exec.EwfSendMailTask$EwfSendMailTaskAttach[]" required="false">Path to the attachment relative to the workflow file.</property>
			<property name="body" type="string" required="true">Text message of the email.</property>
			<property name="charset" type="string" required="false">Encoding of the message. Default value = utf8.</property>
			<property name="emailSubject" type="string" required="true">Subject of the email.</property>
			<property name="from" type="string" required="false">Email address of the sender.</property>
			<property name="mailType" type="com.ataccama.adt.task.exec.EwfSendMailTask$MailType" required="true">Format of the email (plain text or HTML).</property>
			<property name="smtpServer" type="string" required="true">Name of a previously defined SMTP server. See Creating a New Server Connection.</property>
			<property name="to" type="com.ataccama.adt.task.exec.EwfSendMailTask$EwfSendMailTaskRecipient[]" required="true">Recipient of the email: a valid email address.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.sendmail.SendmailAlgorithm">
    <introduction>
			Sends e-mail based on template and input data.
		</introduction>
    <properties>
			<property name="templates" type="com.ataccama.dqc.tasks.experimental.sendmail.SendmailAlgorithm$MailTemplate[]" required="true">
				List of templates. Each template can have condition when will be sent.
			</property>
			<property name="maxSent" type="integer" required="true">
				Maximal number of sent mails.
				<br/>Default = 100.
			</property>
			<property name="smtpServer" type="string" required="true">
				Name of the SMTP server (defined under Servers in File Explorer). For server deployments and command line usage, the server connection name should be present in Runtime Configuration. 
			<br/>
			Note: To enable sending emails from a server secured with TLS/SSL, run the plan with the <code>-Dmail.smtp.auth=true</code> JVM parameter.
			</property>
			<property name="from" type="string" required="false">
				Default source e-mail address.
			</property>
			<property name="charset" type="string" required="false">
				Specifies encoding of national characters and will be used
				(if necessary) in coding to, from and subject headers and body of mail.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.nlp.SentenceTokenizer">
    <introduction>Splits input to sentences.</introduction>
    <description>
            <p align="justify">Step creates a new record for each sentence in the input string.</p>
            <p align="justify">OpenNLP model files are necessary for this step. Model files can be trained with the
                <strong>SentenceTokenizerTrainer</strong>
                step.</p>
        </description>
    <properties>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="inputColumn" type="string" required="true">Column containing input sentences.</property>
            <property name="modelFile" type="string" required="true">OpenNLP SentenceDetectorModel file.</property>
            <property name="outputColumn" type="string" required="true">Column for output tokens.</property>
            <property name="recordDescriptorColumn" type="string" required="false">Record descriptor column.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.nlp.SentenceTokenizerTrainer">
    <introduction>Trains the model for
                        <strong>SentenceTokenizer</strong>
            .</introduction>
    <description>
            <p align="justify">Step creates the model for
                <strong>SentenceTokenizer</strong>
                .</p>
            <p align="justify">Proper training input format is one sentence per record. End of document is signalized by an empty record. If document boundary is unknown, it is recommended to use an empty record every 10 sentences.</p>
        </description>
    <properties>
            <property name="abbreviations" type="string" required="false">Known abbreviations column.</property>
            <property name="cutoff" type="integer" required="true">The minimal number of times a feature must be seen, otherwise it is ignored.</property>
            <property name="eosCharacters" type="character[]" required="true">End of sentence characters.</property>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="inputValues" type="string" required="true">Training input column.</property>
            <property name="iterations" type="integer" required="true">Number of training iterations.</property>
            <property name="modelFile" type="string" required="true">Output model file.</property>
            <property name="useTokenEnd" type="boolean" required="true">If checked, sentences are not split in the middle of tokens. E.g. &quot;correct answers here,but there&quot; would be split as &quot;correct answers here,but&lt;SPLIT&gt;there&quot;, not &quot;correct answers here,&lt;SPLIT&gt;but there&quot;.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.text.SeparatorConfig">
    <properties>
			<property name="digits" type="boolean" required="true">
				Defines whether digits should serve as delimiters.<br/>Default value: <code>false</code>
			</property>
			<property name="lowerCaseLetters" type="boolean" required="true">
				Defines whether lowercase letters should serve as delimiters.<br/>Default value: <code>false</code>
			</property>
			<property name="upperCaseLetters" type="boolean" required="true">
				Defines whether uppercase letters should serve as delimiters.<br/>Default value: <code>false</code>
			</property>
			<property name="includeSeparators" type="string" required="false">
				Defines characters (exceptions) that should serve as separators irrespective of the value of the
				properties <code>Digits</code>, <code>Lower Case Letters</code> and <code>Upper Case Letters</code>.
			</property>
			<property name="excludeSeparators" type="string" required="false">
				Defines characters (exceptions) that should not serve as separators irrespective of the value of the
				properties <code>Digits</code>, <code>Lower Case Letters</code> and <code>Upper Case Letters</code>.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.SequenceGenerator">
    <introduction>Assigns sequence of numbers to a column.</introduction>
    <description>
			Step generates sequence of numbers, using several strategies for restarting
			and sharing.
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="column" type="string" required="true">
				Column of <code>INTEGER</code> or <code>LONG</code> type that stores the sequence number.
			</property>
			<property name="start" type="integer" required="false">
				First assigned number.<br/>
				Default = 0.
			</property>
			<property name="step" type="integer" required="false">
				Difference between numbers.<br/>
				Default = 1.
			</property>
			<property name="strategy" type="com.ataccama.dqc.tasks.flow.SequenceGenerator$Stg" required="true">
				Strategy for sharing/restaring of sequence.
			</property>
			<property name="name" type="string" required="false">
				Sequence name. Used in <code>GLOBAL</code> or <code>REQUEST</code> strategy only
				to distinguish or share sequences on several places of plan.
				Each sequence use is identified by unique start/step/name. 
			</property>
			<property name="whenCondition" type="string" required="false"/>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.communication.auth.server.IServerAuthenticationMethod">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.server.config.IServerComponent">
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.server.config.ServerConfigBean">
    <introduction>Server configuration parameters.</introduction>
    <description>Server configuration parameters.</description>
    <properties>
			<property name="port" type="integer" required="true">Port to run.</property>
			<property name="runtimeConfiguration" type="string" required="false">Path to a runtime configuration file.</property>
			<property name="serverComponents" type="com.ataccama.dqc.server.config.IServerComponent[]" required="false">List of server components.</property>
			<property name="tempFolders" type="com.ataccama.dqc.server.interfaces.to.Folder[]" required="false">List of temporary folders.</property>
		<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.server.services.ServerFilesystemServiceComponent">
    <introduction>Enables access to a server filesystem from the GUI.</introduction>
    <description>
			Enables access to a remote (server) filesystem from the GUI and defines root folders for the remote filesystem (at least one root must be defined).
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="roots" type="string[]" required="true">Defines root folders for the remote filesystem.
				<p align="justify">
				Defined paths:
				<ul>
					<li>
						are not restricted any way (e.g. you can refer to <code>c:/</code>)
					</li>
					<li>
						are either absolute or relative (to the server configuration file) paths
					</li>
					<li>
						support path variables from the runtime configuration.
					</li>
				</ul>
			</p>
      </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.metrics.ServerMetricsWebConsole">
    <introduction>Adds Server Metrics section to the Admin Center.</introduction>
    <description>Adds Server Metrics section to the Admin Center.</description>
    <properties>
			<property name="configFile" type="string" required="true">Relative (to the server configuration file) or absolute path to the configuration file.</property>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
		</properties>
  </class>
  <class name="com.ataccama.server.http.ServletFilter">
    <properties/>
  </class>
  <class super="com.ataccama.adt.task.iterators.ITaskIterator" name="com.ataccama.adt.task.iterators.SetIterator">
    <introduction>Runs child workflows for all items defined in the <strong>Set</strong>.</introduction>
    <description>Runs child workflows for all items defined in the <strong>Set</strong>. When <strong>Iteration Type</strong> is set to SERIAL, the task iterates in the order corresponding to the specified order of items defined in <strong>Set</strong>.</description>
    <properties>
			<property name="iterableItem" type="string" required="true">Name of the variable that is passed to the child workflow (i.e., a variable with the same name should be defined in the child workflow as an input variable). The value of the variable is taken from the Set in each iteration. For example, if you define Set as <code>a 1,b 2</code> and the Separator as <code>,</code> the task will iterate 2 times and will pass the following values to the child workflow: <code>a 1</code> and <code>b 2</code>. </property>
			<property name="parameterMapping" type="com.ataccama.adt.task.base.KeyValueMapping$Mapper" required="false">Set of user defined parameters to pass to the workflow as global variable values.</property>
			<property name="separator" type="string" required="true">Value of separator that is used.</property>
			<property name="set" type="string" required="true">Set to be used for iteration.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.column.ShadowColumnDef">
    <description>
			This element is used by steps to define a new column of a specific type in the
			output format. The created column can contain initial data as a result
			of <code>Default Expression</code>.
		</description>
    <properties>
			<property name="defaultExpression" type="string" required="false">
				String that contains the expression which is evaluated for input data.
				The expression might include definitions and operations on input columns.
			</property>
			<property name="name" type="string" required="true">
				Assigned column name.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
				Data type of created column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.simpledatasampler.SimpleDataSamplerAlgorithm">
    <introduction>Creates a simple data sample from input records.</introduction>
    <description>
    	Simple version of Data Sampler step.<br/>
    	Using this step it is possible to define a size of the final data sample. Data sampling is made based on selected mode:
	    	<ul>
				<li>FIRST - selection of first <code>Count</code> records from input</li>
				<li>RANDOM - random selection of <code>Count</code> records from input</li>
			</ul>
	    </description>
    <properties>
			<property name="mode" type="com.ataccama.dqc.tasks.experimental.simpledatasampler.ESimpleDataSampler" required="true">
				Mode of data sampling. Random or sequential sampling.
			</property>
			<property name="count" type="integer" required="true">
				Number of records in the data sample.
			</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.timeseries.settings.ModelSettings" name="com.ataccama.dqc.tasks.ai.timeseries.settings.SimpleExponentialSmoothingSettings">
    <introduction>
            Simple exponential smoothing.
        </introduction>
    <description>
            s(t) = alpha * x(t) + (1 - alpha) * s(t-1)
            <br/>
            prediction: F(t+m) = s(t)
        </description>
    <properties>
            <property name="settings" type="com.ataccama.dqc.tasks.ai.timeseries.settings.ExponentialSmoothingSingleParameterSettings[]" required="true">
                <strong>Alpha</strong> - Alpha values to try in the grid search.
            </property>
        <property name="active" type="boolean" required="true">
                If this model should be used in the grid search.
            </property>
    </properties>
  </class>
  <class super="com.ataccama.ai.commons.steps.column.FeatureColumn" name="com.ataccama.ai.commons.steps.column.SimpleFeatureColumn">
    <introduction>Feature is created by expression.</introduction>
    <properties>
            <property name="expression" type="string" required="true">
                Expression, that is used to create the feature.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.groupClassification.SimpleGroupClassifier">
    <introduction>Classifies groups of records with roles representing overall data quality of the groups.</introduction>
    <description>
			<p align="justify">
			This step works with groups of records usually acquired from the Unification process. Utilizing predefined rules, which compare members of the same group,
			the overall group quality can be evaluated.
			Groups are defined by the value in <code>Group Id Column</code>. If this value is empty (<code>null</code>), the record in question defines its own single member group
			with a group role of &#39;C&#39;.
			</p>
			The following group qualities are defined:
			<ul>
			<li>U - single member group of A quality.</li>
			<li>A - best quality group (records can be automatically assigned to single entity).</li>
			<li>M - minor differences in group (recommended for manual control).</li>
			<li>C - major differences in group or empty group id (recommended for manual control and correction).</li>
			</ul>
		</description>
    <properties>
			<property name="defaultLocale" type="string" required="false">Default locale to be used.</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="groupIdColumn" type="string" required="true">
				Column or expression that contains group identifiers (groupId) for each record.
			</property>
			<property name="roleColumn" type="string" required="true">
				Column that stores group quality.
			</property>
			<property name="columnSets" type="com.ataccama.dqc.tasks.identify.groupClassification.ColumnSet[]" required="false">
				Rule list for group evaluation. Group quality is evaluated by the first columnSet member with a satisfying condition (&quot;when&quot; property).
			</property>
			<property name="alreadyGrouped" type="boolean" required="true">
				Informs the process that the input record flow is already grouped by a used groupId and so it&#39;s unnecessary to group it again.
				This switch is usable in the common case that the group classifier follows a unification step and its groupId corresponds to 
				this unification&#39;s candidate or matching group ids.
				<br/>Default = false.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.unify.config.IOperationConfig" name="com.ataccama.dqc.unify.config.SimpleGroupClassifyOperation">
    <introduction>
			Classifies groups of records with roles representing overall data quality of the groups. For additional information,
			see <strong>Simple Group Classifier</strong>.
		</introduction>
    <description>
			<p align="justify">
			This step works with groups of records usually acquired from the Unification process. Utilizing predefined rules, which compare members of the same group,
			the overall group quality can be evaluated.
			Groups are defined by the value in groupIdColumn. If this value is empty (<code>null</code>), the record in question defines its own single member group
			with a group role of &#39;C&#39;.
			</p>
			The following group qualities are defined:
			<ul>
			<li>U - single member group of A quality.</li>
			<li>A - best quality group (records can be automatically assigned to a single entity).</li>
			<li>M - minor differences in group (recommended for manual control).</li>
			<li>C - major differences in group or empty group id (recommended for manual control and correction).</li>
			</ul>
		</description>
    <properties>
			<property name="id" type="string" required="true">
				Unique operation id.
			</property>
			<property name="groupByColumn" type="string" required="true">
				Grouping level generated by some previous operation, which is used in this operation.
			</property>
			<property name="roleColumn" type="string" required="true">
				Column that stores group quality.
			</property>
			<property name="columnSets" type="com.ataccama.dqc.tasks.identify.groupClassification.ColumnSet[]" required="false">
				Rule list for group evaluation. Group quality is evaluated by the first columnSet member with a satisfying condition (the &quot;when&quot; property).
			</property>
			<property name="defaultLocale" type="string" required="false">
			    Default locale to be used for ordering.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod" name="com.ataccama.dqc.tasks.identify.grouping.SimpleKey">
    <introduction>
        	Unification method where candidate groups are based on one flat key.
        </introduction>
    <properties>
	        <property name="components" type="com.ataccama.dqc.tasks.common.components.KeyComponent[]" required="true">
	        	Set of components of the key.
	        </property>
        <property name="when" type="string" required="false">
				Boolean condition for using the current grouping method.<br/>
				Default value: true.
			</property>
      <property name="pivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting the &quot;Pivot record&quot; from a set of candidates.
				A matching group is constituted of one pivot record and candidates which
				are near to the pivot record, i.e. which satisfy one of the matching rules.
			</property>
      <property name="maxIterations" type="integer" required="false">
				Maximum number of iterations of the matching group assigning process. Consequently,
				it is maximum number of matching groups in one candidate group.
			</property>
      <property name="mergeSurvivorSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting one &quot;Merge survivor record&quot;, which must be
				assigned for each newly created group (candidate or matching). This
				criterion is used when more than one prior MSR records occurs in group.
				<br/>Ignored when <code>Use Pivot As Survivor</code> is specified.
			</property>
      <property name="matchingRules" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Set of rules used for determining when a candidate record is near the pivot record
				and belongs to its matching group.
				<br/>Note: two records named &quot;pivot&quot; and &quot;candidate&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
      <property name="matchNearest" type="boolean" required="true">
				If specified, candidate will be assigned to matched group with minimal value of <code>Match Quality Expression</code>.
				If not specified, candidate will be assigned to matched group with the best pivot (default behavior). 
			</property>
      <property name="matchQualityExpression" type="string" required="false">
				Numeric (integer, long or float) expression that can be used to evaluate match quality of candidate record with it&#39;s pivot record.
				<br/>Similarly as in <code>Expression</code>
				compared records are referred by two dot-sources <code>pivot</code> and <code>candidate</code>.
				Results of <strong>Matching Measure</strong>
				referred via dot-source <code>measures</code> are accessible, too.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.SimpleProfilingStep">
    <introduction>Computes statistics and other data analysis measures.</introduction>
    <properties>
			<property name="columns" type="com.ataccama.one.profiling.linear.simple.ProfilingColumn[]" required="true">Contains definitions of columns which will be read from the input file.</property>
			<property name="defaultLocale" type="string" required="false">Locale represents a specific geographical, political, or cultural region, with respect to data parsing and comparison as performed by the step.<br/>
					Default value: <code>en_US</code>
      </property>
			<property name="domainParams" type="com.ataccama.one.profiling.linear.simple.params.global.domain.DomainParams" required="true">Specifies which and how domain analysis will be performed.</property>
			<property name="id" type="string" required="false">Step identification string. </property>
			<property name="masks" type="com.ataccama.dqc.tasks.profiling.config.MaskCfg[]" required="false">List of mask definitions.</property>
			<property name="nestedFlowParams" type="com.ataccama.one.profiling.linear.simple.params.global.flow.NestedFlowParams" required="false">Parameters that specifies implementation used for expression evaluation to be used (Roll Up, Condition, None).</property>
			<property name="outputSourcesWithResult" type="boolean" required="true">Filename of the result file where the profile results will be stored. </property>
			<property name="paramsGraphOutputFile" type="string" required="false">Output file contains results, transformations and graphs.</property>
			<property name="paramsOutputFile" type="string" required="false">Output file contains results and profiling parameters.</property>
			<property name="resultOutputFile" type="string" required="true">File with resulting profiled data.</property>
			<property name="samplingParams" type="com.ataccama.one.profiling.linear.simple.params.global.sampling.SamplingParams" required="false">Sampling Parameters.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.scoring.SimpleScoring">
    <introduction>Scores and flags input records according to defined rules.</introduction>
    <description>
			Passes through all defined scoring cases and evaluates their conditions.
			If the condition is true it appends the explanation to the
			explanationColumn and increments the value in scoreColumn.
		</description>
    <properties>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="scoringCases" type="com.ataccama.dqc.tasks.scoring.ScoringCase[]" required="false">
				Cases that are evaluated.
			</property>
			<property name="defaultExplainColumn" type="string" required="false">
		  		The default explanation column. The explanation values are appended and are separated
		  		by a space. This value will be overridden if explanationColumn is filled in.
		  	</property>
	   	    <property name="defaultScoreColumn" type="string" required="false">
		  		The default scoring column. The scoring values are incremented.
		  		This value will be overridden if scoreColumn is filled in.
		  	</property>
		  	<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.addresses.dictionary.evaluation.IProposalEvaluatorDefinition" name="com.ataccama.dqc.tasks.addresses.dictionary.evaluation.SingleComponentElementEvaluatorDefinition">
    <introduction>
			Method that evaluates proposal so that each component is searched for in a single mapped input element. 
		</introduction>
    <properties>
          <property name="unknownTextCleaner" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="false">
    			Definition of constructing matching value for particular columns
    			of unexpl source (for each input element there is one column).
    			However the overall column existing in the pseudo-input as an addition to the input elements
    			contains concatenated orginal value with a pipe character (<code>|</code>) as a separator.<br/>
    			Default value: none - no cleaning is performed and the value is left as is.    			
    		</property>
    	</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ISearchMethodDefinition" name="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.SingleComponentElementSearchMethod">
    <introduction>
			Method that searches in elements so that each input element is mapped to exactly one component.
		</introduction>
    <properties>
		  <property name="inputComponents" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference[]" required="true">
		      List of input components to be searched for.
		  </property>
		  
		</properties>
  </class>
  <class name="com.ataccama.dqc.online.SingleOnlineServicesComponent">
    <introduction>Initializes and deploys a service which should be available for online requests.</introduction>
    <description>Initializes and deploys a service which should be available for online requests. The component is a simplified version of an <strong>Online Services Component</strong> and is used to start online services from GUI during the plan testing and debugging. Difference from <strong>Online Services Component</strong>: the component does not search a directory, instead it expects a single <code>*.online</code> file.</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="listeners" type="string" required="false">Comma-separated list of names of HTTP listeners to which all service handlers should be registered. If the attribute is missing, all services will be deployed on all listeners.</property>
			<property name="serviceConfigFileName" type="string" required="true">Relative (to the server configuration file) or absolute path to the <code>*.online</code> configuration file that contains definition of an online service.</property>
			<property name="serviceLookupFolders" type="string[]" required="true">Relative (to the server configuration file) or absolute path to the file system folder(s) which contain all necessary configuration files, i.e. the <code>*.online</code> files that contain definition of online services. All <code>*.online</code> files from the configuration folder are processed and the defined services started.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfSleepTask">
    <introduction>Waits for a specified amount of time.</introduction>
    <description>Waits for a specified amount of time.</description>
    <properties>
			<property name="sleepTime" type="string" required="true">The time to sleep (ms).</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.SmartSwapNameSurnameAlgorithm">
    <introduction>Swaps the first and the last name into relevant columns.</introduction>
    <description>
			Swaps the first name and the last name in the input (<code>First Name</code> and <code>Last Name</code>) string. The swapping
			only occurs if it is applicable according to the contents of defined dictionaries (i.e., first name string
			is found only in the last names dictionary and vice versa - for detailed settings see the example).
			
			If it is not possible to determine which is the first name and which is the last name,
			the original order is preserved.
			<strong/>
			Behavior of the step can be changed using the table of actions, which is
			defined in the element &quot;actions&quot; (see properties of the step).
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="actions" type="com.ataccama.dqc.tasks.clean.config.Action[]" required="false">
				List of output flags and actions that should be applied to the input data in defined situations.
			</property>
			<property name="firstName" type="string" required="true">
				Column that contains the input first name.
			</property>
			<property name="firstNameLookupFileName" type="string" required="true">
				Dictionary file that contains known first names.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="firstNameOut" type="string" required="true">
				Column that stores the final determined first name.
			</property>
			<property name="lastNameLookupFileName" type="string" required="true">
				Dictionary file that contains known last names.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="lastName" type="string" required="true">
				Column that contains the input last name.
			</property>
			<property name="lastNameOut" type="string" required="true">
				Column that stores the final determined last name.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="SNS_SWAP">
				A scoring flag indicating that the first name and the last name have been swapped.
			</scoringKey>
			<scoringKey name="SNS_UNDECIDABLE">
				A scoring flag indicating that it was not possible to decide which is the first name and which is the last name.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.server.http.conditions.SoapActionCondition">
    <introduction>Tests if the request is the SOAP request and <strong>Soap Action</strong> value matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</introduction>
    <description>Tests if the request is the SOAP request and <strong>Soap Action</strong> value matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</description>
    <properties>
			<property name="regexp" type="string" required="false">Fill in <strong>Regexp</strong> that should be matched by filter</property>
			<property name="value" type="string" required="false">Fill in <strong>Value</strong> that should be matched by filter</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.web.IMappingTest" name="com.ataccama.dqc.web.mappingtests.SoapActionTest">
    <introduction>Tests if the request is the SOAP request and <strong>Soap Action</strong> value matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</introduction>
    <description>Tests if the request is the SOAP request and <strong>Soap Action</strong> value matches the value in <strong>Value</strong> or <strong>Regexp</strong> parameter.</description>
    <properties>
			<property name="regexp" type="string" required="false">Fill in <strong>Regexp</strong> that should be matched by condition.</property>
			<property name="value" type="string" required="false">Fill in <strong>Value</strong> that should be matched by condition.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.soap.SoapCallStep">
    <introduction>It calls for each input record a soap service. The
			request is built using
			a template and input columns. The response is
			searched using XPATH
			expressions and found
			values are stored in the
			columns of the input record.</introduction>
    <description>
			The step calls soap service installed on the URL. The request is built using
			<code>Input Template</code>
			where column names in curly brackets are replaced by values in the
			columns. The response is expected to be in XML form and therefore the
			values can be extracted
			using XPATH expressions. First root XML
			element for further processing is
			extracted using
			<code>Root Xpath</code>
			. Then for each attribute from
			<code>Attributes</code>
			a value is extracted
			using
			<code>Xpath</code>
			and the extracted value is written into the
			corresponding column.
		</description>
    <properties>
			<!-- errorHandlingStrategy -->
			<property name="attributes" type="com.ataccama.dqc.tasks.io.soap.ResponseColumnBinding[]" required="true">
				Columns filled from the response.
			</property>
			<property name="namespaces" type="com.ataccama.dqc.tasks.io.xml.reader.PrefixNamespacePair[]" required="false">
				It defines prefixes and corresponding namespaces which can be
				used in
				the XPATH
				expressions. Implicitly soap prefix is added.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				General parameters for data formatting. This configuration is
				applied to
				all specified columns unless the column defines its own
				<code>Data Format Parameters</code>
				section.
				For more information, see
				<strong>
					DataFormatParameters</strong>
			</property>
			<property name="httpRequestHeaders" type="com.ataccama.dqc.tasks.io.soap.HttpRequestHeaderDefinition" required="false">
				Additional HTTP header fields attached to the request. All inserted
				HTTP header fields overwrite existing HTTP headers (including
				&quot;soapAction&quot;...). If the header field doesn&#39;t exist yet, it is
				appended.
				For description see
				<strong>
					HttpRequestHeaderDefinition</strong>
			</property>
			<property name="encoding" type="string" required="true">
				The request data encoding. You can use all encoding sets that supported by the target Java platform. Most commonly used encoding sets are: ISO-8859-1, ISO-8859-2, and UTF-8.
			</property>
			<property name="url" type="string" required="true">
				Name of the URL
				pointing the soap service.
			</property>
			<property name="wsdlUrl" type="string" required="false">
				URL where WSDL
				schema can be obtained for the called soap service. It
				is used
				in the
				GUI to generate request template. The step does not evaluate
				this URL
				in any way (except validation).
			</property>
			<property name="soapAction" type="string" required="false">
				The soap
				action name.
			</property>
			<property name="inputTemplate" type="string" required="true">
				The template contains full soap request. The request can contain
				columns wrapped by curly brackets. The columns are replaced by
				column values from current input record. Example:
				<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;soap:Envelope
        xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
        xmlns:ns1=&quot;http://www.example.com/ws&quot;&gt;
  &lt;soap:Body&gt;
    &lt;ns1:component&gt;
      &lt;ns1:SRC_ACCOUNT_ID&gt;{input_column_name}&lt;/ns1:SRC_ACCOUNT_ID&gt;
    &lt;/ns1:component&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</pre>
If the column used in the template contains XML, the output can be escaped as follows:
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;soap:Envelope
        xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
        xmlns:ns1=&quot;http://www.example.com/ws&quot;&gt;
  &lt;soap:Body&gt;
    &lt;ns1:component&gt;
      &lt;ns1:SRC_ACCOUNT_ID&gt;
      &lt;?javax.xml.transform.disable-output-escaping ?&gt;
      {input_column_name}
      &lt;?javax.xml.transform.enable-output-escaping ?&gt;
      &lt;/ns1:SRC_ACCOUNT_ID&gt;
    &lt;/ns1:component&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</pre>
			</property>
			<property name="rootXpath" type="string" required="true">
				XPATH
				expression which extracts the starting element in which values
				for
				columns are searched.
			</property>
			<property name="errorColumn" type="string" required="false">
				If some errors
				occurred then they can be stored into this column.
			</property>
                        <property name="errorLengthLimit" type="integer" required="false">
                                Maximum length of value stored to error column. Pass negative number to always store complete error.
                        </property>
			<property name="timeoutMs" type="long" required="true">
				If the call of the service takes longer time than the
				<code>Timeout (ms)</code>
				then
				the call is aborted.
			</property>
			<property name="delayBetweenRequestsMs" type="long" required="true">
				Sometimes when calling an outside service it is needed to make some pauses
				between requests in order not to get banned for DOS attack. The value is in milliseconds.
			</property>
			<property name="soapVersion" type="com.ataccama.dqc.io.soap.SoapVersion" required="true">
				Version of the soap service.
			</property>
			<property name="debugResponseFileName" type="string" required="false">
				The responses
				can be written into the file. If the file name contains
				percent
				character
				then it is replaced by the number of the record for which
				the response
				was generated. If
				a file with the same name exists then
				it is rewritten.
			</property>
			<property name="debugRequestFileName" type="string" required="false">
				The same like
				<code>Debug Response File Name</code>
				but for the request.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
    <scoring>
			<scoringKey name="WLA_TIMEOUT">
				Indicates timeout occurred while
				performing the call.
			</scoringKey>
			<scoringKey name="WLA_NO_ROOT_EL_FOUND">
				Indicates responses for which the Root
				XPath returns no result.
			</scoringKey>
			<scoringKey name="WLA_UNKNOWN_RESPONSE">
				Indicates unknown response (i.e. there
				has been no soap fault though error
				message has been indicated).
			</scoringKey>
			<scoringKey name="WLA_SOAP_FAULT">
				Indicates SOAP fault.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.io.soap.SoapMultiCallStep">
    <introduction>
			It calls for each input record a soap service. The
			request is built
			using a template and input
			columns. The response
			distributed to one or more output end points.
		</introduction>
    <description>
			The step calls soap service installed on the url. The request is built using
			<code>Input Template</code>
			where column names in curly brackets are replaced by values in the
			columns. The response is expected to be in XML form and therefore the
			values can be extracted
			using XPATH expressions. First root XML
			element for further processing is
			extracted using
			<code>Root Xpath</code>
			.

			It can create several output streams from each soap request where
			rows
			of one stream can be
			logically children to rows from another
			stream of rows. E. g. soap request can
			contain records
			of clients and
			each client have several addresses and then the XML file
			can be read
			as a stream of clients and for each client there can be read
			addresses
			where addresses
			are put to another stream. The streams can
			also be independent. The
			namespaces official
			specification can be a
			little tricky and therefore if they are used it is good to
			read
			<a href="http://www.w3.org/TR/2009/REC-xml-names-20091208/" target="_blank">namespace specification</a>
			.
			Each output stream can have unique record descriptor assigned in
			format
			&quot;unique_number_of_group:count_of_records_in_group:order_in_group&quot; and
			these record descriptors
			can be accessed by child output streams in
			shadows columns and therefore
			the parent and
			related children streams
			can be joined using the record descriptor columns.
			The input columns
			are also accessible in the shadow columns. If some
			soap request fails
			then
			a record describing error with added input columns is sent to
			&quot;error&quot;
			end point.
		</description>
    <properties>
			<property name="namespaces" type="com.ataccama.dqc.tasks.io.xml.reader.PrefixNamespacePair[]" required="false">
				It defines prefixes and corresponding namespaces which can be
				used in
				the XPATH
				expressions. Implicitly soap prefix is added.
			</property>
			<property name="recordsOutputs" type="com.ataccama.dqc.tasks.io.soap.RecordsOutput[]" required="true">
				Output end points defined on the root level.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
				General parameters for data formatting. This configuration is
				applied to
				all specified columns unless the column defines its own
				<code>Data Format Parameters</code>
				section.
				For more information, see
				<strong>
					DataFormatParameters</strong>
			</property>
			<property name="httpRequestHeaders" type="com.ataccama.dqc.tasks.io.soap.HttpRequestHeaderDefinition" required="false">
				Additional HTTP header fields attached to the request. All inserted
				HTTP header fields overwrite existing HTTP headers (including
				&quot;soapAction&quot;...). If the header field doesn&#39;t exist yet, it is
				appended.
				For description see
				<strong>
					HttpRequestHeaderDefinition</strong>
			</property>
			<property name="encoding" type="string" required="true">
				The request data encoding. You can use all encoding sets that are supported by the
				target Java platform. Most commonly used encoding sets are: ISO-8859-1, ISO-8859-2, and UTF-8.
			</property>
			<property name="url" type="string" required="true">
				Name of the URL
				resource pointing to the soap service.
			</property>
			<property name="wsdlUrl" type="string" required="false">
				URL where WSDL
				schema can be obtained for the called soap service. It
				is used
				in the
				GUI to generate request template. The step does not evaluate
				thisURL
				in any way (except validation).
			</property>
			<property name="soapAction" type="string" required="false">
				The soap
				action name.
			</property>
			<property name="inputTemplate" type="string" required="true">
				The template contains full soap request. The request can contain
				columns wrapped by curly brackets. The columns are replaced by
				column values from current input record. Example:
				<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;soap:Envelope
        xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
        xmlns:ns1=&quot;http://www.example.com/ws&quot;&gt;
  &lt;soap:Body&gt;
    &lt;ns1:component&gt;
      &lt;ns1:SRC_ACCOUNT_ID&gt;{input_column_name}&lt;/ns1:SRC_ACCOUNT_ID&gt;
    &lt;/ns1:component&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</pre>
If the column used in the template contains XML, the output can be escaped as follows:
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;soap:Envelope
        xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
        xmlns:ns1=&quot;http://www.example.com/ws&quot;&gt;
  &lt;soap:Body&gt;
    &lt;ns1:component&gt;
      &lt;ns1:SRC_ACCOUNT_ID&gt;
      &lt;?javax.xml.transform.disable-output-escaping ?&gt;
      {input_column_name}
      &lt;?javax.xml.transform.enable-output-escaping ?&gt;
      &lt;/ns1:SRC_ACCOUNT_ID&gt;
    &lt;/ns1:component&gt;
  &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
</pre>
			</property>
			<property name="rootXpath" type="string" required="true">
				XPATH
				expression which extracts the starting element in which values
				for
				columns are searched.
			</property>
			<property name="timeoutMs" type="long" required="true">
				If the call of the service takes longer time than the
				<code>Timeout (ms)</code>
				then
				the call is aborted.
			</property>
			<property name="delayBetweenRequestsMs" type="long" required="true">
				Sometimes when calling an outside service it is needed to make some pauses
				between requests in order not to get banned for DOS attack. The value is in milliseconds.
			</property>
			<property name="soapVersion" type="com.ataccama.dqc.io.soap.SoapVersion" required="true">
				Version of the soap service.
			</property>
			<property name="debugResponseFileName" type="string" required="false">
				The responses
				can be written into the file. If the file name contains
				percent
				character
				then it is replaced by the number of the record for which
				the response
				was generated. If
				a file with the same name exists then
				it is rewritten.
			</property>
			<property name="debugRequestFileName" type="string" required="false">
				The same like
				<code>Debug Response File Name</code>
				but for the request.
			</property>
			<property name="errorColumn" type="string" required="false">
				Name of column
				in the &quot;error&quot; end point where soap fault messages are
				written.
			</property>
                        <property name="errorLengthLimit" type="integer" required="false">
                                Maximum length of value stored to error column. Pass negative number to always store complete error.
                        </property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="WLA_TIMEOUT">
				Indicates timeout occurred while
				performing the call.
			</scoringKey>
			<scoringKey name="WLA_NO_ROOT_EL_FOUND">
				Indicates responses for which the Root
				XPATH returns no result.
			</scoringKey>
			<scoringKey name="WLA_UNKNOWN_RESPONSE">
				Indicates unknown response (i.e. there
				has been no soap fault though error
				message has been indicated).
			</scoringKey>
			<scoringKey name="WLA_SOAP_FAULT">
				Indicates SOAP fault.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.io.soap.SoapVersion">
    <description>The version of the SOAP protocol to be used.</description>
  </class>
  <class name="com.ataccama.dqc.model.services.SoapVersion">
    <description>Allowed values are <code>SOAP_1_1</code> and <code>SOAP_1_2</code>. Default: <code>SOAP1.1</code>.</description>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.sort.SortEngine">
    <introduction>Sorts all records in the data flow by a defined key.</introduction>
    <description>
		<p align="justify">
		Sorting step that will sort according to a specified key.
		</p>

		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="defaultLocale" type="string" required="false">
			Locale definition represents a specific geographical, political, or cultural region, with respect to data parsing and comparison as performed by the step.
			</property>
			<property name="sort" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
			Sort column/key definition; column list in <code>orderBy</code>.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.web.SourceConfigBean">
    <description>Defines named sources of the workflow configurations.</description>
    <properties>
			<property name="id" type="string" required="false">Defines the name for the source. Workflows (in case of Workflow Server Component) or scheduled jobs (Scheduler Server Component) in the source with Id are accessible via notation, e.g. <code>&lt;sourceId&gt;:&lt;workflowName&gt;.ewf</code> or <code>&lt;sourceId&gt;:&lt;scheduleName&gt;.sch</code>.	One of the sources may not have a name: in such case, it is processed as an implicit source, so no <strong>Id</strong> is required to access workflows or schedules from this folder.</property>
			<property name="path" type="string" required="true">Relative (to the server configuration file) or absolute path denoting the location where the source files are stored. Component scans only selected folder (no subfolders are processed) and processes files with the <code>ewf</code> (in case of Workflow Server Component) or <code>sch</code> (Scheduler Server Component) extension.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.rjoin.SourceKey">
    <description>
			Defines search key stored in reference source.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of the key. Used in <strong>matchKeys</strong>. 
			</property>
	        <property name="components" type="com.ataccama.dqc.tasks.common.components.UnionKeyComponent[]" required="true">
	        	Set of components of the key.
	        </property>
	        <property name="noKeyCond" type="string" required="false">
	        	Condition specifying when this key is assumed to be unusable and is therefore not used as a search key.
	        </property>
	        <property name="noEmptyComponent" type="boolean" required="true">
				Specifies that all components have to be valid (non-null) to conform valid key.
				If false (default) and at least one component is non-null, the key is valid and used.
	        </property>
		</properties>
  </class>
  <class name="com.ataccama.one.profiling.linear.simple.params.global.domain.transformation.SourceTransformation">
    <description>Types of source transformation that you can apply.</description>
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.spark.SparkOption">
    <description>List of Spark data source options that can be used with specified &quot;format&quot;. Full list of supported options for specific can be found on Spark website for built-in connectors or on the web page of custom connectors.</description>
    <properties>
			<property name="name" type="string" required="true">Name of the data source option.</property>
			<property name="value" type="string" required="false">Value of the data source option. </property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.spark.SparkOptionEncrypted">
    <description>List of Spark data source encrypted options that can be used with specified &quot;format&quot;. Full list of supported options for specific can be found on Spark website for built-in connectors or on the web page of custom connectors.</description>
    <properties>
			<property name="name" type="string" required="true">Name of the encrypted data source option.</property>
			<property name="value" type="string" required="false">Value of the encrypted data source option.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.spark.steps.SparkRDDRepartition">
    <introduction>
            This is an expert level step for Spark engine. It allows you repartition an RDD inside a data flow.
        </introduction>
    <description>
            Reshuffles the data in the RDD randomly to create either more or fewer partitions and balance it across them. This always shuffles all data over the network.
        </description>
    <properties>
            <property name="partitions" type="integer" required="false">
                Target number of RDD partitions or value interpreted regarding to <code>propertyMeaning</code>.
            </property>
            <property name="propertyMeaning" type="com.ataccama.dqc.spark.steps.SparkRDDRepartition$PropType" required="true">
            	The value of <code>partitions</code> property is interpreted by this option.<br/>
				<ul>
					<li>EXACT - Value is target number of partitions.</li>
					<li>MULTIPLY - Number of partitions is multiplied by the value (may be &lt; 1).</li>
					<li>ADD - Number of partitions is increased by the value (may be negative).</li>
					<li>SIZE - The value is estimated size of target partitions (in MB). If not specified or zero, global executor&#39;s property <code>spark.ata.partSize</code>
					will be used</li>
				</ul>
            </property>
            <property name="useCoalesce" type="boolean" required="false">
                Use Coalesce instead of repartitioning. Applicable only when number of partitions is decreased.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.SparkReader">
    <introduction>
            This is an expert level step for Spark engine. It allows you to utilize Spark SQL/DataFrame API in order to use additional Spark functionality that is not provided by Ataccama Reader steps. Please read the following documentation before using this step:
            <ul>
            	<li>
          <a href="https://spark.apache.org/sql/" target="_blank">Spark SQL</a>.</li>
            	<li>
          <a href="https://spark.apache.org/docs/latest/sql-programming-guide.html" target="_blank">Spark SQL Programming Guide</a>.</li>
            	<li>
          <a href="https://spark.apache.org/docs/latest/sql-data-sources-load-save-functions.html" target="_blank">Generic Load/Save Functions</a>.</li>
			</ul>
        </introduction>
    <description>
        	Spark Reader works only in Spark mode.
        	This step represents a 1 to 1 mapping of Spark DataFrame API in order to bypass limitations of built-in Ataccama Reader steps, like JDBC Reader, Parquet Reader, etc.
        	Via this step you can bypass additional options to the Spark DataFrame Reader or utilize external Spark connectors for data sources that are not built-in in Ataccama tools. For example, you can utilize the following external 3rd-party connectors:
        	<ul>
            	<li>
          <a href="https://github.com/GoogleCloudPlatform/spark-bigquery-connector" target="_blank">Spark BigQuery Connector</a>.</li>
            	<li>
          <a href="https://docs.snowflake.net/manuals/user-guide/spark-connector.html" target="_blank">Spark Snowflake Connector</a>.</li>
            	<li>
          <a href="https://github.com/datastax/spark-cassandra-connector" target="_blank">Spark Cassandra Connector</a>.</li>
            	<li>
          <a href="https://spark.apache.org/docs/latest/sql-data-sources-jdbc.html" target="_blank">Parallel JDBC Reader for Spark engine</a>.</li>
			</ul>
			Please note, since these connectors are open-sourced and originating from 3rd-party providers, Ataccama Software is not responsible for their functionality and stability in production environments.
		</description>
    <properties>
            <property name="path" type="string" required="false">
            	Path to the file/folder to be read by Spark Reader step. By default, it resolves the relative path to user HOME folder and reads the data from cluster file system, e.g. HDFS or DBFS.
				You can also use the following path prefixes:
			<ul>
				<li>Use path with prefix &#39;/&#39; to resolve the path from root, e.g. /data/ínput/table/</li>
				<li>Use path with prefix &#39;file://&#39; to read a file on your local machine, e.g. file://data/ínput.csv</li>
				<li>Use path with prefix &#39;resource://&#39; to read the data from Google Cloud Storage, Azure Data Lake Storage or S3, e.g. resource://adls/data/table</li>
			</ul>
           	</property>
            <property name="format" type="string" required="true">
                Name of the data source format. e.g. &quot;parquet&quot;, &quot;orc&quot;, &quot;csv&quot;. It is also possible to use custom Spark connectors in order to read data from other data sources, e.g. &quot;BigQuery&quot;. Make sure that you have added proper spark connector for your datasource in classpath.
            </property>
            <property name="options" type="string" required="true">
                List of Spark data source options that can be used with specified &quot;format&quot;. Full list of supported options for specific can be found on Spark website for built-in connectors or on the web page of custom connectors.
            </property>
            <property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="true">
                Definition of table columns (corresponding by order, names and types).<br/>
            </property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
                Definition of shadow columns.
            </property>
        <property name="optionsEncrypted" type="com.ataccama.dqc.tasks.common.spark.SparkOptionEncrypted[]" required="false">List of Spark data source encrypted options that can be used with specified &quot;format&quot;. Full list of supported options for specific can be found on Spark website for built-in connectors or on the web page of custom connectors.</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.spark.steps.SparkSqlReader">
    <introduction>Reads data from a data source (Hive, Parquet, Avro) via Spark SQL.</introduction>
    <description>
			<p align="justify">
				This step reads data records from the results of a specified query executed on a specified Spark SQL data source.
				As a data source, it is using the environment which is used for running the plan.
			</p>
			<p align="justify">
			<strong>SQL Function getLatestPartition()</strong>
        <br/>
        <br/>
			This SQL function gets a value of the last partition in a Hive Databricks table.
			<example>
          <pre>getLatestPartition([database,] table [, level])</pre>
        </example>
			<ul>
					<li>
            <code>database</code>: name of the database, optional, default value is default</li>
					<li>
            <code>table</code>: name of the table for which it should return the partition</li>
					<li>
            <code>level</code>: level of table partition, default is &quot;1&quot;, i.e. the top level partition</li>
			</ul>
			<strong>How to Use</strong>
        <br/>
        <br/>
			When the partition column is a type of <code>bigint</code>.<br/>
			<example>
          <pre>CREATE TABLE customers (customer_id int,customer_name string) PARTITIONED BY (load_dt bigint);
select * from customers where load_dt = ##getLatestPartition(default, customers)## 
will be replaced by 
select * from customers where load_dt = 20190101</pre>
        </example>
			When the partition column is a type of <code>string</code>.<br/>
			<example>
          <pre>CREATE TABLE customers (customer_id int, customer_name string) PARTITIONED BY (load_dt string);
select * from customers where load_dt &gt; &quot;##getLatestPartition(default, prices_2019)##&quot;
will be replaced by 
select * from customers where load_dt = &quot;20190101&quot;</pre>
        </example>
			Two partitions<br/>
			<example>
          <pre>CREATE TABLE customers (customer_id int, customer_name string) PARTITIONED BY (load_dt string, load_hours string);
select * from customers where load_dt = &quot;##getLatestPartition(default, customers)##&quot; and load_hours = &quot;##getLatestPartition(default, customers, 2)##&quot;
will be replaced by 
select * from customers where load_dt = &quot;20190101&quot; and load_hours = &quot;0100&quot;</pre>
        </example>
	
				<strong>How to Enable</strong>
        <br/>
        <br/>
					Custom SQL query is currently considered as an experimental feature and is disabled by default. To turn on the functionality, the following property has to added to spark configuration (e.g. spark.properties file):
				<example>
          <pre>spark.ata.enableCustomSqlTemplates=true</pre>
        </example>
				</p>
			</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.io.jdbc.read.JdbcReaderColumn[]" required="true">
				Contains definitions of columns which will be constructed from the SQL query result set.
			</property>
			<property name="queryFileEncoding" type="string" required="false">
				Encoding of the query file if such a file is used.
			</property>
			<property name="queryFileName" type="string" required="false">
				When defined, it represents the name of the file that contains the query to execute.
				When this attribute is filled in, the attribute <code>Query String</code> must not contain
				any value, otherwise a query conflict error is reported.
			</property>
			<property name="queryString" type="string" required="true">
				SQL query to execute on the data source to obtain input data records. Only selection operations are supported.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriter">
    <introduction>
            This is an expert level step for Spark engine. It allows you utilize Spark SQL/DataFrame API in order to use additional Spark functionality that is not provided by Ataccama Writer steps. Please read the following documentation before using this step:
            <ul>
            	<li>
          <a href="https://spark.apache.org/sql/" target="_blank">Spark SQL</a>.</li>
            	<li>
          <a href="https://spark.apache.org/docs/latest/sql-programming-guide.html" target="_blank">Spark SQL Programming Guide</a>.</li>
            	<li>
          <a href="https://spark.apache.org/docs/latest/sql-data-sources-load-save-functions.html" target="_blank">Generic Load/Save Functions</a>.</li>
			</ul>
        </introduction>
    <description>
        	Spark Writer works only in Spark mode.
        	This step represents a 1 to 1 mapping of Spark DataFrame API in order to bypass limitations of built-in Ataccama Writer steps, like JDBC Writer, Parquet Writer, etc.
        	Via this step you can bypass additional options to the Spark DataFrame Writer or utilize external Spark connectors for data sources that are not built-in in Ataccama tools. For example, you can utilize the following external 3rd-party connectors:
        	<ul>
            	<li>
          <a href="https://github.com/GoogleCloudPlatform/spark-bigquery-connector" target="_blank">Spark BigQuery Connector</a>.</li>
            	<li>
          <a href="https://docs.snowflake.net/manuals/user-guide/spark-connector.html" target="_blank">Spark Snowflake Connector</a>.</li>
            	<li>
          <a href="https://github.com/datastax/spark-cassandra-connector" target="_blank">Spark Cassandra Connector</a>.</li>
            	<li>
          <a href="https://spark.apache.org/docs/latest/sql-data-sources-jdbc.html" target="_blank">Parallel JDBC Reader for Spark engine</a>.</li>
			</ul>
			Please note, since these connectors are open-sourced and originating from 3rd-party providers, Ataccama Software is not responsible for their functionality and stability in production environments.
		</description>
    <properties>
           <property name="dataTypeParameters" type="com.ataccama.dqc.tasks.hadoop.io.spark.DataTypeParameters" required="true">Data Type Parameters. A Decimal that must have fixed precision (the maximum number of digits) and scale (the number of digits on right side of dot).</property>
			<property name="bucketOptions" type="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriterBucketOptions" required="false">Buckets the output by the given columns. If specified, the output is laid out on the file system similar to Hive&#39;s bucketing scheme. This is applicable for all file-based data sources (e.g. Parquet, JSON) starting with Spark 2.1.0.</property>
			<property name="partitionOptions" type="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriterPartitionOptions" required="false">Partitions the output by the given columns on the file system. If specified, the output is laid out on the file system similar to Hive&#39;s partitioning scheme.</property>
			<property name="saveOptions" type="com.ataccama.dqc.tasks.hadoop.io.spark.ISparkWriterSaveOptions" required="true">Save Options is used to specify the expected behavior of saving a DataFrame to a data source.</property>
			<property name="writeAllColumns" type="boolean" required="true">Specifies whether to write out all columns as defined in the input format. This attribute is exclusive to column definitions. If this value is set to true there must be no columns defined in the columns element, otherwise an error is reported. </property>
			<property name="id" type="string" required="false">Step identification string.</property>
			<property name="savePath" type="string" required="false">Path to the file/folder which should be read by Spark Reader step. By default, it is reading the data from cluster file system, e.g. HDFS. If you need to read the data from Google Cloud Storage, Azure Data Lake Storage or S3, you can use resources.
           	</property>
           	<property name="saveMode" type="string" required="true">Spark DataFrame <strong>Save Mode</strong> that will be used for writing the data set. <br/>
					<ul>
						<li>
            <code>ERRORIFEXISTS</code>: ErrorIfExists mode means that when saving a DataFrame to a data source, if data already exists, an exception is expected to be thrown.</li>
						<li>
            <code>APPEND</code>: Append mode means that when saving a DataFrame to a data source, if data/table already exists, contents of the DataFrame are expected to be appended to existing data.</li>
						<li>
            <code>OVERWRITE</code>: Overwrite mode means that when saving a DataFrame to a data source, if data/table already exists, existing data is expected to be overwritten by the contents of the DataFrame.</li>
						<li>
            <code>IGNORE</code>: Ignore mode means that when saving a DataFrame to a data source, if data already exists, the save operation is expected to not save the contents of the DataFrame and to not change the existing data.</li>
					</ul>
			</property>
            <property name="format" type="string" required="true">Name of the data source format. e.g. &quot;parquet&quot;, &quot;orc&quot;, &quot;csv&quot;. It is also possible to use custom Spark connectors in order to read data from other data sources, e.g. &quot;BigQuery&quot;. Make sure that you have added proper spark connector for your data source in classpath.</property>
            <property name="options" type="string" required="true">List of Spark data source options that can be used with specified &quot;format&quot;. Full list of supported options for specific can be found on Spark website for built-in connectors or on the web page of custom connectors.</property>
            <property name="optionsEncrypted" type="com.ataccama.dqc.tasks.common.spark.SparkOptionEncrypted[]" required="false">List of Spark data source encrypted options that can be used with specified &quot;format&quot;. Full list of supported options for specific can be found on Spark website for built-in connectors or on the web page of custom connectors.</property>
			<property name="columns" type="com.ataccama.dqc.tasks.common.column.ColumnDef[]" required="true">Definition of table columns (corresponding by order, names and types).</property>
            <property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">Definition of shadow columns.</property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriterBucketOptions">
    <description>Buckets the output by the given columns. If specified, the output is laid out on the file system similar to Hive&#39;s bucketing scheme. This is applicable for all file-based data sources (e.g. Parquet, JSON) starting with Spark 2.1.0.</description>
    <properties>
			<property name="bucketCount" type="integer" required="true">Specifies number of buckets.</property>
			<property name="columns" type="com.ataccama.dqc.tasks.hadoop.io.spark.PartitionColumn[]" required="true">Specifies number of columns.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriterColumn">
    <properties>
			<property name="dataTypeParameters" type="com.ataccama.dqc.tasks.hadoop.io.spark.DataTypeParameters" required="false">Data Type Parameters. A Decimal that must have fixed precision (the maximum number of digits) and scale (the number of digits on right side of dot).</property>
			<property name="expression" type="string" required="false">Expression</property>
			<property name="name" type="string" required="true">Name</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriterPartitionOptions">
    <description>Partitions the output by the given columns on the file system. If specified, the output is laid out on the file system similar to Hive&#39;s partitioning scheme.</description>
    <properties>
			<property name="columns" type="com.ataccama.dqc.tasks.hadoop.io.spark.PartitionColumn[]" required="true">Specifies number of columns.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.SparkWriterSaveMode">
    <description>SaveMode is used to specify the expected behavior of saving a DataFrame to a data source.</description>
  </class>
  <class name="com.ataccama.dqc.tasks.hadoop.io.spark.ISparkWriterSaveOptions">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.domain.SpecvalDomainAnalysis">
    <description>
			Discovers some values which is more frequent than other &quot;common&quot; values. Number of
			such special values is limited (at most 9).
		</description>
    <properties>
			<property name="gradientThreshold" type="integer" required="true">
				Minimal ratio between frequency and number of special and common values.
				<br/>For example, when threshold is 100 and most frequent values are:
				&quot;N/A&quot; (26170x), &quot;Unknown&quot; (13230x), &quot;Smith&quot; (113x), &quot;Jordan&quot; (67x) etc... and
				number of all distinct values is 1230,
				then values &quot;N/A&quot; and &quot;Unknown&quot; will be assumed as special, because
				ratio between frequency of &quot;Unknown&quot; and &quot;Smith&quot; is greater than 100 and
				number of special values (2) is less than 1/100 of number of all values (1230).
				<br/>Default = 100.
			</property>
			<property name="active" type="boolean" required="true">
				Specifies whether the analysis will be performed.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.text.Splitter">
    <introduction>Creates a new record for each word in a defined expression. New records contain only single words from the original value.</introduction>
    <description>
			This step splits the input into separate words. For each of these words (created by splitting the input) it
			creates a new record. Each of these new records is an exact copy of the input record with the only difference
			being the column containing the words created by splitting the input.
			The <code>All Sentence Column</code> property is an input expression for the splitting and
			the <code>One Word Column</code> property is an output column for the split words. All other columns from the input are automatically copied to the output
			unchanged. The <code>Separator Config</code> property defines which characters should be considered delimiters.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="allSentenceColumn" type="string" required="true">
				Column containing the input string to be split.
			</property>
			<property name="oneWordColumn" type="string" required="true">
				Column containing split output words.
			</property>
			<property name="separatorConfig" type="com.ataccama.dqc.tasks.text.SeparatorConfig" required="true">
				Defines the set of characters to serve as delimiters. By default all characters except letters and digits serve as a separator.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				Name of the column of type string to store the identification of record in group. The identifier
				has the form <code>&lt;group_id&gt;:&lt;record_count&gt;:&lt;record_number&gt;</code>.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.task.iterators.ITaskIterator" name="com.ataccama.adt.task.iterators.SqlRowIterator">
    <introduction>Runs child workflows for each row returned by an SQL query.</introduction>
    <description>Runs child workflows for each row returned by an SQL query. When <strong>Iteration Type</strong> is set to SERIAL, the iteration order corresponds to the order of results returned by <strong>Query</strong> (so ORDER BY clause can be used to affect the iteration order).</description>
    <properties>
			<property name="connectionName" type="string" required="true">Connection name to use for query invocation.</property>
			<property name="mapping" type="com.ataccama.adt.task.base.SqlMapper" required="false">Set of parameters derived from result set to pass to the workflow as global variable values.</property>
			<property name="parameterMapping" type="com.ataccama.adt.task.base.KeyValueMapping$Mapper" required="false">Set of user defined parameters to pass to the workflow as global variable values.</property>
			<property name="query" type="string" required="true">Query to execute.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.commons.security.IIdentity" name="com.ataccama.dqc.communication.auth.server.StandardIdentity">
    <introduction>Identity has user-defined name and roles.</introduction>
    <description>Identity has user-defined name and roles.</description>
    <properties>
			<property name="name" type="string" required="false">Defines identity name.</property>
			<property name="roles" type="string[]" required="false">Defines identity roles.</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.transformation.normalization.definition.NormalizationFeatureTransformation" name="com.ataccama.dqc.tasks.ai.transformation.normalization.definition.StandardNormalizationTransformation">
    <introduction>Scales value based on mean and standard deviation values.</introduction>
    <description>
            Formula for computing the result:
            x = (x - mean) / standardDeviation
        </description>
  </class>
  <class name="com.ataccama.dqc.tasks.profiling.config.ProfiledData$StandardStatistics">
    <description>
			Specifies whether and how statistical results of the given value set will be counted.
		</description>
    <properties>
			<property name="calculate" type="boolean" required="true">
			Specifies whether statistical analysis should be performed.<br/>
			Default value: <code>true</code>
			</property>
			<property name="calculateAggregated" type="boolean" required="true">
			Specifies whether aggregate values (sums) should be computed for
				  average, median, standard deviation, variance, and min-max values.<br/>
			Default value: <code>true</code>
			</property>
			<property name="extremes" type="integer" required="true">
			Specifies the number of first and last values to be computed. If set
			to zero, extremes aren&#39;t counted.<br/>
			Default value: <code>5</code>.
			</property>
			<property name="quantiles" type="integer" required="true">
			Quantile count, i.e. number of divisions of the whole where quantiles should be marked.<br/>
			Default value: <code>10</code>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.runtime.state.storage.IStateStorageProvider">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.rjoin.StaticRefSourceConfig">
    <introduction>
			Specifies where the reference data is stored.
		</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.statistics.Statistic">
    <description>Properties of the statistical operation.</description>
    <properties>
			<property name="columnStatistics" type="com.ataccama.dqc.tasks.analysis.statistics.ColumnStatistic[]" required="false">
            List of statistics to be performed.
			</property>
			<property name="expression" type="string" required="true">
			The specified multi-column expression, or a single <em>column</em> expression, to evaluate for all records.
			</property>
			<property name="locale" type="string" required="false">
			Locale definition for a specified column.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.analysis.statistics.StatisticsAlgorithm">
    <introduction>Computes statistical analysis of input data.</introduction>
    <description>
				<p align="justify">
					This step is capable of multiple analytical operations
					in a single pass over multiple columns of input data.
					All data types supported by [branding:product.name.abbreviation] can be used as long as they correspond
					to the applied data operations.
					<table border="1">
						<th>
							<th>Analytical Operation</th>
							<th>FLOAT, INTEGER, LONG</th>
							<th>DAY, DATETIME</th>
							<th>BOOLEAN</th>
							<th>STRING</th>
						</th>
						<tr>
							<td>Record Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Null Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Not Null Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Distinct Value Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Unique Value Count</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Sum</td>
							<td>yes</td>
							<td>-</td>
							<td>yes</td>
							<td>-</td>
						</tr>
						<tr>
							<td>Average</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
						</tr>
						<tr>
							<td>Median</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Standard Deviation</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
							<td>-</td>
						</tr>
						<tr>
							<td>Variance</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
							<td>-</td>
						</tr>
						<tr>
							<td>Fist X values</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Last X values</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Minimum length of sequence</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Minimum length of non-empty sequence</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Average length of sequence</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Median length of sequence</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Maximum length of sequence</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Quantile Value</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
							<td>yes</td>
						</tr>
						<tr>
							<td>Approximate Quantile Value</td>
							<td>yes</td>
							<td>yes</td>
							<td>-</td>
							<td>-</td>
						</tr>
					</table>
				</p>
				<p align="justify">
					Step outputs:
					<ul>
						<li>
							<strong>out_stat</strong> - statistical output : 
							contains results of statistical operations. Its format is as follows: 
							<ul>
								<li>
									stat_name [STRING] - user defined name for the statistic
									(see <code>Column Statistics Name</code>)
								</li>
								<li>
									stat_result [STRING] - value of the statistic
								</li>
								<li>
									stat_distinction [STRING] - distinction number of the statistic&#39;s record 
									(among all the records belonging to the same statistic). Forms a row 0,1,2...
								</li>
							</ul>
						</li>
						<li>
							<strong>out_rec</strong> - data output. It has the same format as
							input data flow 
							Data Output - has the same format as Data and for both
							required fields in input and output sections they are
							referenced with the identifier <strong>out_rec</strong>.
						</li>
					</ul>
				</p>
				<p align="justify">
					For each statistic computed by [branding:product.name.abbreviation] a single row is returned, as long as
					the statistic does not have the parameter
					<em>count</em>, or an input supplied by the parameter <em>count</em>.
				</p>
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="statName" type="string" required="false">
			This column contains the name of the statistic which is added to the data output row. See <code>Column Statistics Name</code>.
			</property>
			<property name="statDistinction" type="string" required="false">
			This column of resulting statistical records contains the value of the corresponding record identifier.
			<br/>
        <br/>
			For statistics with single record output (e.g. median; average) this is always 0; for multi-record output, like quantiles, this is a sequence (&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot; and so on). 
			</property>
			<property name="defaultLocale" type="string" required="true">
			Locale definition represents a specific geographical, political, or cultural region, with respect
			to data parsing and comparison as performed by the step.
			</property>
			<property name="statistics" type="com.ataccama.dqc.tasks.analysis.statistics.Statistic[]" required="true">
			Root statistics node.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.SequenceGenerator$Stg">
    <description>
		</description>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.StopReading">
    <introduction>Instructs readers to stop reading data.</introduction>
    <description>
			<p align="justify">This step signals the readers that they should stop reading data. The signal is sent when <code>when</code> condition is true.</p>
			<strong>Usage notes</strong>
      <br/>
			<ul>
				<li>The readers will read more records than expected due to caching and batching between steps.</li>
				<li>Once stop is signalled, it cannot be cancelled, even when condition no longer holds true.</li>
			</ul>
		</description>
    <properties>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.streaming.io.reader.IKafkaInputFormat" name="com.ataccama.dqc.streaming.io.reader.StringInputFormat">
    <description>
			Input format which expects string messages in the Kafka topic. These string messages are sent to the output column.
		</description>
    <properties>
			<property name="column" type="string" required="true">
				Output column name.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.StringLengthStatistics">
    <introduction>List of supported string length statistics.<br/>
				<ul>
					<li>Max</li>
					<li>Mean</li>
					<li>Min</li>
					<li>Standard Deviation</li>
					<li>Sum</li>
					<li>Variance</li>
				</ul>
		</introduction>
    <properties>
			<property name="max" type="boolean" required="true">Maximal length of string in column.</property>
			<property name="mean" type="boolean" required="true">Mean length of string in column.</property>
			<property name="min" type="boolean" required="true">Minimal length of string in column.</property>
			<property name="standardDeviation" type="boolean" required="true">Dispersion (variation) of string length from the mean.</property>
			<property name="sum" type="boolean" required="true">Sum of lengths.</property>
			<property name="variance" type="boolean" required="true">Measures how far a set of (random) strings lengths are spread out from their average value.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.StringLookupAlgorithm">
    <introduction>Validates the existence of values in a dictionary file.</introduction>
    <description>
            Searches for the input value (from the property <em>in</em>) in the lookup file defined by the property <code>Lookup File Name</code>. If the value
            is found it is stored in the property <code>Out</code>. The search result is reported by the scoring entries <code>MCL_FOUND/MCL_NOT_FOUND</code>.
        </description>
    <properties>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
            <property name="in" type="string" required="true">
                Column that contains the input value.
            </property>
            <property name="lookupFileName" type="string" required="true">
                Lookup file name.
            </property>
            <property name="omitIfFound" type="boolean" required="true">
                <p align="justify">
                If the input value is found in the lookup file, the output value is <code>null</code>.
                </p>
                Default value: <code>false</code>
            </property>
            <property name="omitIfNotFound" type="boolean" required="true">
                <p align="justify">
                If the input value is NOT found in the lookup file, the output value is <code>null</code>.
                </p>
                Default value: <code>true</code>
            </property>
            <property name="out" type="string" required="true">
                Column that stores the output value (dependent on <em>omitIf....</em> properties).
            </property>
        <property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
            <scoringKey name="MCL_NOT_FOUND">
                A scoring entry indicating that the input value ISN&#39;T found in the lookup file.
            </scoringKey>
            <scoringKey name="MCL_FOUND">
                A scoring entry indicating that the input value IS found in the lookup file.
            </scoringKey>
            <scoringKey name="MCL_NULL">
                A scoring entry indicating that the input value is null
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.generator.beans.ColumnGeneratorPatternSetItem">
    <description>
			One possible pattern in <strong>ColumnGeneratorPatternSet</strong>,
			optionally with frequency.
		</description>
    <properties>
			<property name="value" type="string" required="true">
			Possible pattern. See description of <strong>Pattern Generator</strong>.
			</property>
			<property name="frequency" type="integer" required="false">Pattern frequency. If omitted defaults to 1.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.generator.beans.ColumnGeneratorStringSetItem">
    <description>
			One possible value in <strong>ColumnGeneratorStringSet</strong>,
			optionally with frequency.
		</description>
    <properties>
			<property name="value" type="string" required="true">Possible string value.</property>
			<property name="frequency" type="integer" required="false">String value frequency. If omitted defaults to 1.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.StripTitlesAlgorithm">
    <introduction>Removes titles (academic, social, etc.) from person names.</introduction>
    <description>
			This step removes titles (academic, social, etc.) from person names. If specified, removed titles are stored in the
			output <code>Titles Out</code> and separated by a delimiter. Known titles (title dictionary) are stored in a dictionary file
			which is defined by the <code>Title Lookup File Name</code> property.<br/>
			The algorithm is as follows: 
			<ul>
				<li>
					initialize the algorithm so that each translation from the dictionary is loaded into the memory as sequence of tokens (do once only).
				</li>
				<li>
					create matching value from the input text according to matching value generator configuration stored in the dictionary.
				</li>
				<li>
					tokenize the matching value (hence &quot;match-then-tokenize&quot; approach).
				</li>
				<li>
					iterate over all input tokens and find the best match to the token sequences from the dictionary. Use the following rules:
					<ul>
						<li>
							accept matched tokens at input
						</li>
						<li>
							when a whitespace is detected at input, ignore it but remember it for cases when expected token might be skipped
						</li>
						<li>
							for unmatched token t<sub>u</sub> at input and ignorable expected token t<sub>e</sub>: 
							<ul>
								<li>
									skip the token t<sub>u</sub> if it is ignorable
								</li>
								<li>
									virtually insert expected token t<sub>e</sub> otherwise  
								</li>
							</ul>
						</li>
					</ul>
				</li>
				<li>
					remove the matched sequences from the input and put translations into output column
				</li>
			</ul>
			Using this mechanism, characters such as dot (&#39;.&#39;), slash (&#39;/&#39;), underscore (&#39;_&#39;) but also other
			characters not covered by <code>Tokenizer</code> can be skipped/ignored when put into <code>Ignored Separators</code>
      <br/> 
			
			<br/>
			<linkTarget id="ignoredSeparators"/>
			Consider the following dictionary (the bullet characters are used to emphasize ignored characters):<br/>
			<br/>
			<table border="1">
				<th>
          <th width="20%">title (left side)</th>
          <th>translation (right side)</th>
        </th>
				<tr>
          <td>wd•</td>
          <td>stripped</td>
        </tr>
				<tr>
          <td>nd</td>
          <td>stripped</td>
        </tr>
				<tr>
          <td>A•B</td>
          <td>stripped</td>
        </tr>
				<tr>
          <td>A A•</td>
          <td>stripped</td>
        </tr>
				<tr>
          <td>abc | def</td>
          <td>stripped</td>
        </tr>
			</table>
      <br/>
			The following table clarifies the meaning of accepting unexpected tokens as described above.<br/>
			It summarizes both states of <code>Ignored Separators</code>: &quot;I&quot; ... ignored, &quot;R&quot; ... required<br/>
			Characters &#39;|&#39; and &#39;%&#39; are never ignored.<br/>
			<br/>
			<table border="1">
				<th>
          <th>input</th>    <th>output (I)</th>
          <th>translation (I)</th>
          <th>output (R)</th>
          <th>translation (R)</th>
          <th>comment</th>
        </th>
				<tr>
          <td>wd•</td>
          <td/>          <td>stripped</td>       <td/>          <td>stripped</td>       <td>found exactly</td>
        </tr>
				<tr>
          <td>wd◦</td>
          <td/>          <td>stripped</td>       <td>wd◦</td>
          <td/>       		  <td>(I) dot can be ignored</td>
        </tr>
				<tr>
          <td>wd%</td>       <td>%</td>         <td>stripped</td>       <td>wd%</td>       <td/>       		  <td>(I) dot can be ignored, % not</td>
        </tr>
				<tr>
          <td>nd</td>        <td/>          <td>stripped</td>       <td/>          <td>stripped</td>       <td>found exactly</td>
        </tr>
				<tr>
          <td>wd</td>        <td/>          <td>stripped</td>       <td>wd</td>        <td/>               <td>(R) cannot add dot</td>
        </tr>
				<tr>
          <td>nd•</td>
          <td/>          <td>stripped</td>       <td>•</td>  <td>stripped</td>       <td>(R) dot not accepted</td>
        </tr>
				
				<tr>
          <td/>
          <td/>
          <td/>
          <td/>
          <td/>
          <td/>
        </tr>
				
				<tr>
          <td>A•B</td>        <td/>                  <td>stripped</td>
          <td/>                  <td>stripped</td> <td>found exactly</td>
        </tr>
				<tr>
          <td>A B•</td>       <td>•</td>          <td>stripped</td>
          <td>A B•</td>       <td/> <td>dot not expected</td>
        </tr>
				<tr>
          <td>A A•</td>       <td/>                  <td>stripped</td>
          <td/>                  <td>stripped</td> <td>found exactly</td>
        </tr>
				<tr>
          <td>A•A•</td>
          <td>A•A•</td>
          <td/>        <td>A•A•</td>
          <td/> <td>Cannot skip inner dot</td>
        </tr>
				
				<tr>
          <td/>
          <td/>
          <td/>
          <td/>
          <td/>
          <td/>
        </tr>
				
				<tr>
          <td>◦A••B</td>        <td>◦A••B</td>
          <td/>        <td>◦A••B</td> <td/> <td>too many consecutive dots</td>
        </tr>
				<tr>
          <td>◦A•B•◦</td>
          <td>◦•◦</td>  <td>stripped</td>
          <td>◦•◦</td> <td/> <td>dots at ends remain</td>
        </tr>
				<tr>
          <td>◦A A•◦</td>       <td>◦◦</td>          <td>stripped</td>
          <td>◦◦</td> <td/> <td>dots at ends remain</td>
        </tr>
				
				<tr>
          <td/>
          <td/>
          <td/>
          <td/>
          <td/>
          <td/>
        </tr>
				
				<tr>
          <td>abc | def</td>
          <td/>
          <td>stripped</td>
          <td/>
          <td>stripped</td>
          <td>found exactly</td>
        </tr>
				<tr>
          <td>abc % def</td>
          <td>abc % def</td>
          <td/>
          <td>abc % def</td>
          <td/>
          <td>not matched, &#39;%&#39; required always</td>
        </tr>
			</table>
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="in" type="string" required="true">
			A string expression whose result is examined by the step.
			</property>
			<property name="out" type="string" required="false">
			A string column where the input with titles removed should be stored.
			</property>
			<property name="titlesOut" type="string" required="false">
			A string column where the removed titles should be stored.
			</property>


			<property name="minWordCount" type="integer" required="true">
				Minimum number of words which must remain in the output (after removing titles).
				<br/>
				Default value: <code>0</code>.
			</property>
			<property name="separator" type="string" required="false">
				A single character or sequence of characters used as string delimiters to break output data
				(titles) into words.
			</property>
			<property name="titleLookupFileName" type="string" required="true">
				Dictionary file that contains known titles.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="tokenizer" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Configuration how to split input text into tokens.
				The default tokenizer setting distinguishes words, numbers and other single characters, except
				for whitespace characters (space, tab).
			</property>
			<property name="ignoredSeparators" type="string" required="false">
				Definition of characters that might be ignored when input token
				cannot be matched to expected token in translation rule. 
				Expected token can be ignored only if it is defined as ignorable,
				with input token either being skipped when it is ignorable as well, or preserved.
				<br/>
				The set is defined by means of <strong>character set</strong>).
			</property>
            <property name="preserveUnsupportedChars" type="boolean" required="false">
                If true then unsupported characters immediately following replaced text will be copied to
                output, otherwise these characters will be removed. For detailed description of these characters,
                see <strong>Matching Value Generator Config</strong>.<br/>
                Default value: <code>true</code> 
            </property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="ST_CHANGED">
				A flag indicating that titles were removed from the given name.
			</scoringKey>
		</scoring>
  </class>
  <class super="com.ataccama.dqc.tasks.io.gdr.reader.member.StructuredMemberBase" name="com.ataccama.dqc.tasks.io.gdr.reader.member.Structure">
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.gdr.reader.member.IStructuredMember">
    <introduction>
			A single structured member - structure, iteration, choice etc. Can be drawn out as an endpoint, with all its
			fields as columns.
		</introduction>
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.io.gdr.reader.member.IStructuredMember" name="com.ataccama.dqc.tasks.io.gdr.reader.member.StructuredMemberBase">
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.transliterate.SubstitutionRule">
    <description>
			It declares a pair - a searched substring and a replacing string.
		</description>
    <properties>
			<property name="from" type="string" required="true">
			The searched substring.
			</property>
			<property name="to" type="string" required="false">
			The substitution string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.addresses.commons.model.SupportingVectorCase">
    <description>
    		Supporting vector cases are instances of supporting vectors and define
    		when the vector has to be applied. The vector is applied on values
    		returned by examination of the input string. The vector components 
    		might match examined values more than once for the single input string.
    		Let&#39;s have two entities (city, street, number): 
    		&quot;Washington, Some street, 598&quot; and &quot;New Washington, Other street, 598&quot;, 
    		input string <code>New Washington, 598</code> and vector <code>city_number</code>.
    		In this case vector&#39;s components will map to input text as follows:
            <ul>
                <li>city: <code>Washington</code>, number: <code>589</code>
        </li>
                <li>city: <code>New Washington</code>, number: <code>589</code>
        </li>
            </ul>
    	</description>
    <properties>
    		<property name="when" type="string" required="true">
    			Expression to be evaluated on the input record and  
    			<code>xa</code>/<code>xad</code> pseudo inputs.
    			The <code>xa</code> pseudo input represents the input string so that each recognized component
    			is placed into the appropriate column (column names correspond to
    			components). Moreover, the <code>xad</code> pseudo input represents 
    			the same values as <code>xa</code> but dictionary values are
    			available. Recognized components are divided into two parts:
    			<ul>
    				<li>Components matched onto this vector inputs</li>
    				<li>Remaining components so that only the longest are available</li>
    			</ul> 
    			Moreover, the number of proposals for the particular vector and values can be queried
    			by the <code>getProposalCount</code> function, which has the following
    			signature: <code>getProposalCount(vector_name, value[, value]...)</code>.
    			The number of values must match the number of components defined for that
    			vector and the name of the vector MUST be a constant expression.
    			Note, that you MUST use values from the dictionary (the 
    			<code>xad</code> pseudo input becomes useful here).
    			This condition is evaluated for each mapping of this vector.
    			Default value: True.
    		</property>
      		<property name="name" type="string" required="true">
      			Name of the referenced vector from the reference data&#39;s vector definitions.
      		</property>
			<property name="maxScoreToAccept" type="integer" required="false">
				Defines the maximum value of the score for the best proposal of the currently 
				processed supporting vector case to accept this result and stop
				further processing of vector cases.
				This value overrides the default value in the identifier.
				This check is performed on all scores returned for all mappings
				of this vector.
				Default value: 0.
			</property>
			<property name="maxProposalCount" type="integer" required="false">
				Defines the maximum count of proposals that might be potentially returned
				by this vector to continue processing this vector. This condition
				must be satisfied together with the condition in the <code>When</code>code&gt;
				property. An undefined value or -1 means an infinite number of proposals.
				This condition is evaluated on each variant of the vector.
				Default value: None.
			</property>
    	</properties>
  </class>
  <class name="com.ataccama.dqc.addresses.commons.model.SupportingVectorDefinition">
    <description>
    		Hold definition of the supporting vector.
    	</description>
    <properties>
    		<property name="inComponents" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference[]" required="true">
    			Array of references to input components.
    		</property>
      		<property name="name" type="string" required="true">
      			Name of the vector. This name is the prefix of this vector index file.
      		</property>
    	</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfSynchronizerTask">
    <introduction>Unites a groups of tasks together so that they are processed as a single item.</introduction>
    <description>In larger workflow configurations consisting of many workflow tasks, Synchronize Tasks can be used to unite several tasks so that they are processed as a single item, which can serve multiple purposes:
			<ul>
				<li>To ensure a task is not skipped if one of its dependencies fails.</li>
				<li>To help with the general workflow structure and enable easier visualization.</li>
				<li>To facilitate an easy replacement of tasks.</li>
			</ul>
		</description>
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.discovery.schema.config.TableInput">
    <properties>
			<property name="name" type="string" required="true">
			The unique name of the input, and consequently the step input endpoint.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.internal.core.model.EwfTaskElement">
    <introduction>Task</introduction>
    <description>Task</description>
    <properties>
			<property name="id" type="string" required="true">
			The unique ID of the step, which is displayed under the task on the canvas.
			</property>
			<property name="name" type="string" required="false">
			A human-readable name of the task.
			</property>
			<property name="priority" type="integer" required="true">
			Task priority. Defines the execution priority for unlinked tasks. The default value is 0. See Workflow Resource Management for more information.
			</property>
			<property name="description" type="string" required="false">
			Task description. An optional description of what exactly the task is supposed to do.
			</property>
			<property name="executable" type="string" required="true">
			Task configuration.
			</property>
			<property name="resources" type="com.ataccama.adt.internal.core.runtime.services.EwfTaskResourceRequestBean[]" required="false">
			Task resource requirements.
			</property>
			<property name="acceptMode" type="com.ataccama.adt.core.EwfTaskAcceptMode" required="true">
			Task accept mode. If there are several links leading to a task and some of them are not accepted (because the source task fails or the condition on the link is not met), the accept mode determines whether the task will be run. There are two accept modes:
				<ul>
						<li>ALL_VALID – all incoming links must be accepted.</li>
						<li>AT_LEAST_ONE – at least one incoming link must be accepted.</li>
				</ul>
				The task will not be run until all preceding tasks (and all other prerequisites) are finished. 		
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.iterators.ITaskIterator">
    <properties/>
  </class>
  <class super="com.ataccama.dqc.streaming.io.writer.IKafkaOutputFormat" name="com.ataccama.dqc.streaming.io.writer.TemplateOutputFormat">
    <description>
			The message is constructed as a string generated from template by substituting placeholders with expression values.
		</description>
    <properties>
			<property name="inputTemplate" type="string" required="true">
				Template for the message being published. Template is evaluated for each record and then published to the Kafka topic.
			</property>
			<property name="templateBeginMark" type="string" required="true">
				The char(s) used in template to mark the start of an expression. An expression enclosed between the begin and end marks will be replaced with an actual value.<br/>
				Default = &quot;%&quot;
			</property>
			<property name="templateEndMark" type="string" required="true">
				The char(s) used in template to mark the end of an expression. An expression enclosed between the begin and end marks will be replaced with an actual value.<br/>
				Default = &quot;%&quot;
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.matcher.config.Test">
    <introduction>
		Test for comparison of two values (usually strings).
		</introduction>
    <description>

			<linkTarget id="match_functions"/>
			<div>
        <strong>
          <em>
				List of comparison functions
			</em>
        </strong>
      </div>
			<table border="1">
				<tr>
          <td nowrap="nowrap">
            <term>hamming</term>
          </td>
          <td>
            <definition>
					Function returns the Hamming distance between two strings.
					The function has a relative variant where the result is divided by the length of the longer string.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>levenshtein</term>
          </td>
          <td>
            <definition>
					Function returns the Levenshtein distance between two strings.
					The function has a relative variant where the result is divided by the length of the longer string.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>editDistance</term>
          </td>
          <td>
            <definition>
					Function returns the edit distance between two strings.
					The difference between Levenshtein and Edit Distance lies in the definition
					of the distance of the two switched adjacent characters. Levenshtein considers the switch
					as two changes whereas editDistance considers the switch to be one change.
					For example editDistance(&quot;edit&quot;, &quot;edti&quot;) = 1 versus levenshtein(&quot;edit&quot;, &quot;edti&quot;) = 2.
					The function has a relative variant where the result is divided by the length of the longer string.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>symmetricDifference</term>
          </td>
          <td>
            <definition>
					Compared strings are split into two sets of words (space is used as a separator character).
					Function returns the number of words contained only in one set, e.g. cardinality of set (A \ B) U (B \ A).
					The function has a relative variant where the result is divided by the cardinality of the union of the sets.
					<br/>Example: for strings &quot;JOHN SMITH&quot; and &quot;SMITH JOHN GEORGE JOHN MARTIN&quot;
					<br/>the sets are: A={ JOHN, SMITH } B={ JOHN, SMITH, GEORGE, MARTIN }
					<br/>result = |(A \ B) U (B \ A)| = |{ GEORGE, MARTIN}| = 2
					<br/>relative result = 2 / |(A U B)| = 2 / |{ JOHN, SMITH, GEORGE, MARTIN}| = 2 / 4 = 0.5
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>symmetricDifferenceExt</term>
          </td>
          <td>
            <definition>
					The same as the symmetricDifference function, but when no word is common for both sets (A &amp; B = empty),
					the result of the function is &quot;very big number&quot; (VBN=1000000).
					The function has a relative variant.
					<br/>Example: symmetricDifferenceExt(&quot;JOHN SMITH&quot;, &quot;GEORGE MARTIN&quot;) = VBN versus symmetricDifference(&quot;JOHN SMITH&quot;, &quot;GEORGE MARTIN&quot;) = 4.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>symmetricDifferenceMultiSet</term>
          </td>
          <td>
            <definition>
					Similar to the symmetricDifference function, but repeated words in each string are assumed to be different.
					The function has a relative variant where the result is divided by the cardinality of the union of the sets (again, with respect to repeating words).
					<br/>Example: for strings &quot;JOHN SMITH&quot; and &quot;SMITH JOHN GEORGE JOHN MARTIN&quot;
					<br/>the sets are: A={ JOHN, SMITH } B={ JOHN, JOHN(second), SMITH, GEORGE, MARTIN }
					<br/>result = |(A \ B) U (B \ A)| = |{ GEORGE, MARTIN, JOHN(second) }| = 3
					<br/>relative result = 3 / |(A U B)| = 3 / |{ JOHN, JOHN(second), SMITH, GEORGE, MARTIN }| = 3 / 5 = 0.6
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>symmetricDifferenceMultiSetExt</term>
          </td>
          <td>
            <definition>
					The same as the symmetricDifferenceMultiSet function, but when no word is common for both sets (A &amp; B = empty),
					the result of the function is &quot;very big number&quot; (VBN=1000000).
					The function has a relative variant.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>notSubset</term>
          </td>
          <td>
            <definition>
						Compared strings are split into two sets of words (space is used as a separator character).
						Function returns 0 if one of the set is subset of the other one, otherwise it returns 1.
						<br/>Example: for strings &quot;JOHN SMITH&quot; and &quot;JOHN BROWN&quot; returns 1 (not subset).
						<br/>for strings &quot;JOHN SMITH&quot; and &quot;JOHN JOHN&quot; returns 0.
					</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>notSubsetMultiSet</term>
          </td>
          <td>
            <definition>
						Similar to the notSubset function, but repeated words in each string are assumed to be different.
						<br/>Example: it returns 1 for the strings &quot;JOHN SMITH&quot; and &quot;JOHN JOHN&quot; because of the two JOHN&#39;s in the second string.
					</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>numberDistance</term>
          </td>
          <td>
            <definition>
					Function returns the absolute difference between two integers, e.g. |a - b|.
					There is no relative variant for this function.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>anyIsTrue</term>
          </td>
          <td>
            <definition>
					Returns 1 if at least one boolean value is true.
					There is no relative variant for this function.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>pivotIsTrue</term>
          </td>
          <td>
            <definition>
					Returns 1 if the boolean value for the pivot record is true. The value for candidate record is ignored.
					There is no relative variant for this function.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>candidateIsTrue</term>
          </td>
          <td>
            <definition>
					Returns 1 if the boolean value for the candidate record is true. The value for pivot record is ignored.
					There is no relative variant for this function.
				</definition>
          </td>
        </tr>
				<tr>
          <td nowrap="nowrap">
            <term>bothAreNull</term>
          </td>
          <td>
            <definition>
					Returns 1 if both values are null.
					There is no relative variant for this function.
				</definition>
          </td>
        </tr>
			</table>
		</description>
    <properties>
			<property name="caseInsensitive" type="boolean" required="true">
				Case (upper/lower) of letters is ignored in comparison of two strings.
				Default value: <code>false</code>
			</property>
			<property name="diaInsensitive" type="boolean" required="true">
				Diacritics are ignored in comparison of two strings.
				<br/>Default value: <code>false</code>
			</property>
			<property name="expression" type="string" required="true">
				Expression passed as argument for the test function (usually just the name of the column).
			</property>
			<property name="function" type="string" required="true">
				Name of comparison function. See <strong>list of matching functions</strong>.
			</property>
			<property name="limits" type="string" required="false">
				Comma delimited list of numbers. Defines mapping of test results from interval to integer. This is best explained through example:
				<br/>Example:<br/>
				Limits=&quot;3,5,10&quot; defines the following intervals [0,3] (3,6] (6,10] (10,inf).. The results of the test function are mapped
				the following ways: results 0,1,2,3 are mapped to 0; results 4,5,6 are mapped to 1; results 7,8,9,10 are mapped to 2 and numbers greater then 10 are mapped
				to 3. Note that the test weight is used after this mapping.
			</property>
			<property name="relative" type="boolean" required="true">
				Relative version of test function is used (if such version exists).
				<br/>Default value: <code>false</code>
			</property>
			<property name="resultForNullArguments" type="double" required="false">
				Test result value if at least one of the arguments is null. Test evaluation ends in such cases.
			</property>
			<property name="weight" type="double" required="true">
				Weight of test by which the test result is multiplied.
				<br/>Default value: <code>1</code>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.classification.columns.TesterColumn">
    <description>
			Definition of a column values for creating classification.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be used for creating model.
				If no expression is defined, the value from the input column named (as specified by &quot;name&quot; attribute)
				is written.
			</property>
			<property name="weight" type="integer" required="true">
				Weight of column used for classification.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.classification.columns.TesterColumn" name="com.ataccama.dqc.tasks.classification.columns.TesterColumnContinuous">
    <description>
			Definition of a continuous column values for creating classification.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be used for creating model.
				If no expression is defined, the value from the input column named (as specified by &quot;name&quot; attribute)
				is written.
			</property>
			<property name="weight" type="integer" required="true">
				Weight of column used for classification.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.classification.columns.TesterColumn" name="com.ataccama.dqc.tasks.classification.columns.TesterColumnDiscrete">
    <description>
			Definition of a discrete column values for creating classification.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be used for creating model.
				If no expression is defined, the value from the input column named (as specified by &quot;name&quot; attribute)
				is written.
			</property>
			<property name="weight" type="integer" required="true">
				Weight of column used for classification.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.classification.columns.TesterColumn" name="com.ataccama.dqc.tasks.classification.columns.TesterColumnDocument">
    <description>
			Definition of a column values with text from document for creating classification.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be used for creating model.
				If no expression is defined, the value from the input column named (as specified by &quot;name&quot; attribute)
				is written.
			</property>
			<property name="weight" type="integer" required="true">
				Weight of column used for classification.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.text.read.TextFileReader">
    <introduction>Reads data from a text file (possibly compressed) with columns separated by delimiters.</introduction>
    <description>
			<p align="justify">The data source is a standard text file (or an archive containing such a file, where records are saved as rows and
			columns are separated by delimiter characters.</p>
			<p align="justify">
				The step is capable of processing compressed files using either ZIP or GZIP format.
				When processing ZIP file, it searches for a file named after the archive itself (without the extension)
				or uses the only file present in the archive (regardless of its name).
			</p>
			<p align="justify">
				Moreover, the step is capable of reading multiple files having the same format
				with names defined as template where both, ordinary text and column variables
				can appear.
				Column variable has the following format: {&lt;column_name&gt;}.
				Column variables that reference columns that are unknown are
				treated as ordinary text.
				When reading, the step scans file system for files matching the file name template.
				For each matched file and all its records it assigns corresponding
				columns the values extracted from the file&#39;s name.
			</p>
			<p align="justify">
		     This step supports encodings supported by Java, including Unicode formats (supported
		     Unicode formats are: UTF-8, UTF-16, UTF-16BE, UTF-16LE). The input is processed by
		     <code>UnicodeAwareReader</code>, which allows correct processing of files with Byte Order Mark (BOM)
		     signatures used in some Unicode formats (for their identification) and
		     therefore allows correct processing of non-Unicode formats.<br/>
      		<p align="justify">
      		The file encoding detection procedure is as follows:<br/>
      		<code>The UnicodeAwareReader</code> tries to read the BOM from the file and compares the received
      		results with the encoding entered within the step configuration (the <code>Encoding</code>
      		parameter). If both types match and this file type is supported by the version of Java being used,
      		the BOM is skipped and the file is read in the original format. If the file type in the
      		configuration is not the same as the type set by the BOM, a format discrepancy warning is
      		displayed and the file processing proceeds in the format set within the configuration (including
      		BOM bytes, which are considered to be common content).<br/>
      		If the BOM cannot be detected from the file, it is assumed that the encoding used within
      		the step configuration is valid (i.e., either Unicode format without BOM signature
      		or non-unicode format) and the file is read in the format set within the configuration.<br/>
      		If the configuration has UTF-16 as the general encoding type and it is
      		possible to get the exact sub-format from the BOM (i.e., UTF-16BE or UTF-16LE), the type from the
      		BOM is used. But if there is no BOM signature contained within the file, processing ends
      		with an error because it is not clear which format should be used.<br/>
			</p>
			<p align="justify">
			The following table shows possible file encodings and configuration values for Unicode files:
			</p>
				<table border="1">
					<th>
						<th>Real File Format</th>
            <th>Configuration Value</th>
						<th>BOM Signature</th>
            <th>Result (Used) Encoding</th>
					</th>
					<tr>
            <td>UTF-8</td>
            <td>UTF-8</td>
            <td>yes</td>
            <td>UTF-8</td>
          </tr>
					<tr>
            <td>UTF-8</td>
            <td>UTF-8</td>
            <td>no</td>
            <td>UTF-8</td>
          </tr>
					<tr>
            <td>UTF-8</td>
            <td>non/bad-unicode</td>
            <td>yes</td>
            <td>non/bad-unicode + warning</td>
          </tr>
					<tr>
            <td>UTF-8</td>
            <td>non/bad-unicode</td>
            <td>no</td>
            <td>non/bad-unicode</td>
          </tr>
					<tr/>
					<tr>
            <td>UTF-16BE/LE</td>
            <td>UTF-16BE/LE</td>
            <td>yes</td>
            <td>UTF-16BE/LE</td>
          </tr>
					<tr>
            <td>UTF-16BE/LE</td>
            <td>UTF-16BE/LE</td>
            <td>no</td>
            <td>UTF-16BE/LE</td>
          </tr>
					<tr>
            <td>UTF-16BE/LE</td>
            <td>UTF-16</td>
            <td>yes</td>
            <td>UTF-16BE/LE</td>
          </tr>
					<tr>
            <td>UTF-16BE/LE</td>
            <td>UTF-16</td>
            <td>no</td>
            <td>error</td>
          </tr>
					<tr>
            <td>UTF-16BE/LE</td>
            <td>non/bad-unicode</td>
            <td>yes</td>
            <td>non/bad-unicode + warning</td>
          </tr>
					<tr>
            <td>UTF-16BE/LE</td>
            <td>non/bad-unicode</td>
            <td>no</td>
            <td>non/bad-unicode</td>
          </tr>
					<tr/>
					<tr>
            <td>non-unicode</td>
            <td>UTF-8</td>
            <td>-</td>
            <td>UTF-8</td>
          </tr>
					<tr>
            <td>non-unicode</td>
            <td>UTF-16</td>
            <td>-</td>
            <td>error</td>
          </tr>
					<tr>
            <td>non-unicode</td>
            <td>UTF-16BE/LE</td>
            <td>-</td>
            <td>UTF-16BE/LE</td>
          </tr>
					<tr>
            <td>non-unicode</td>
            <td>other-format</td>
            <td>-</td>
            <td>other-format</td>
          </tr>
				</table>
			</p>
			<p align="justify">
     			UTF-32(LE/BE) formats are not supported. Non-Unicode formats are untouched by this
     			reader and they are read using formats entered within the configuration.
			</p>

			<p align="justify">
				Input data records are processed using parameters specified in the element
				<code>Data Format Parameters</code>. Additional details are available in
				<strong>DataFormatParameters</strong>.
				If a column does not define (override) its own format settings, a global formatting setting
				is used by default.
			</p>

			<p align="justify">
				This step may produce the following errors: <code>SHORT_LINE</code>,
				<code>INVALID_DATE</code>, <code>UNPARSABLE_FIELD</code>,
				<code>LONG_LINE</code>, <code>EXTRA_DATA</code>,
				<code>PROCESSING_ERROR</code>.<br/>
				When a <code>SHORT_LINE</code> error occurs the input value is considered to be
				<code>null</code> for further parsing.<br/>
			</p>

			<p align="justify">
				Error management is configured by the element <code>Error Handling Strategy</code>.
				Error handling strategy allows disabling of processing of the incorrect entries,
				which can be send to the &quot;rejected&quot; output endpoint. For a more detailed description of
				error handling see <strong>Error Handling Strategy</strong>.
			</p>

			<p align="justify">
			When creating a reject file, the following rules are observed:<br/>

			<ul>
				<li>The initial name for the reject file is <code>rejected.txt</code>.
				</li>

				<li>The encoding defined for the input data file is used as the encoding of the rejected file.
				</li>

				<li>The line separator defined for the input data file is used as the line separator.</li>

				<li>Every input row is written to the reject file at most once. So,
					even if there are more error fields in the same row whose instructions
					require writing to the reject file the row is written there only once.
				</li>

				<li>Empty reject files are not created. A reject file is created when
					an instruction requires writing to this file.
				</li>

			</ul>
			</p>

		</description>
    <properties>
			<!-- errorHandlingStrategy -->
			<property name="columns" type="com.ataccama.dqc.tasks.io.text.read.TextReaderColumn[]" required="true">
				Contains definitions of columns which will be read from the input file.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.io.text.read.TextReaderDataFormatParameters" required="true">
				General parameters for data formatting. This configuration is applied to
				all specified columns unless the column defines its own
				<code>dataFormaParameters</code> section.
				For more information, see <strong>
						  DataFormatParameters</strong>
			</property>
			<property name="encoding" type="string" required="true">
				File data encoding. The possible encodings are all encodings supported by the
				target Java platform. Some commonly used encodings are: ISO-8859-1,
				ISO-8859-2, and UTF-8.
			</property>
			<property name="errorHandlingStrategy" type="com.ataccama.dqc.tasks.common.io.error.ErrorHandlingStrategy" required="true">
				Definition of error handling strategies that define how to respond to every error
				state the step can recognize. For more details, see the description of
				<strong>Error Handling Strategy</strong>.
			</property>
			<property name="fieldSeparator" type="string" required="true">
				String to be recognized as a field delimiter. <strong>Escaped string property.</strong>
			</property>
			<property name="fileName" type="string" required="true">
				Name of the file containing the input data.
			</property>
			<property name="compression" type="com.ataccama.dqc.tasks.io.compression.CompressionType" required="true">
				Defines compression type of the input file.<br/>
				Default value: NONE.
			</property>
			<property name="ignoredRowRegEx" type="string" required="false">
				A regular expression that is compared to lines in the input file. If a line (read as a string) matches the
				regular expression, the line will be ignored.
			</property>
			<property name="lineMaxReadLength" type="integer" required="true">
				Specified maximum number of characters per line to be read and processed.
				If the length of the line exceeds this value, an error occurs.
			</property>
			<property name="lineSeparator" type="string" required="true">
				Specifies the string to be recognized as a line delimiter. The line delimiter
				can be any sequence of letters, although a specific symbol is often used
				which usually depends on the operating system where the file originated from.
				The special symbols are:  \r = CR, \l = LF, \n = LF. <strong>Escaped string property.</strong>
			</property>
			<property name="numberOfLinesInHeader" type="integer" required="true">
				Specifies the number of lines from the beginning of the file that will be excluded from
				processing (header lines, comments, etc).
			</property>
			<property name="numberOfLinesInFooter" type="integer" required="true">
				Specifies the number of lines from the end of the file that will be excluded from
				processing (footer lines).
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="false">
				Contains a set of columns that are not present in the input data, but should be
				created in the output (so that they are then available for further use as any
				other &quot;real&quot; column read from a file).
			</property>
			<property name="stringQualifier" type="string" required="false">
				String enclosing a text string. Not defined by default. <strong>Escaped string property.</strong>
			</property>
			<property name="stringQualifierEscape" type="string" required="false">
				Escape character escaping the <code>String Qualifier</code> in the original meaning of
				this character. Not defined by default. <strong>Escaped string property.</strong>
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.text.write.TextFileWriter">
    <introduction>Writes data into a text file with columns separated by delimiters.</introduction>
    <description>
			The data output for this step is a standard text file (possibly compressed). Data records are stored as lines consisting of
			columns that are separated using defined delimiter characters.

			<p align="justify">
				The step is capable of creating compressed files using either ZIP or GZIP format.
				When processing ZIP file, it searches for a file named after the archive itself (without the extension)
				or uses the only file present in the archive (regardless of its name).
			</p>
			<p align="justify">
				Moreover, the step is capable of creating multiple files having the same format
				with names defined as template where both, ordinary text and column variables
				can appear.
				Column variable has the following format: {&lt;column_name&gt;}.
				Column variables that reference columns that are unknow are
				treated as ordinary text. NULL value is transformed to <code>__default__</code>,
				some special characters (/\?%*:|&quot;&lt;&gt;) are converted to underscore (_).
				When writing each record, file name is determined using the file name template
				and this record&#39;s columns to produce resulting file name the record
				is to be written to.
			</p>
		</description>
    <properties>
		    <property name="generateMetadata" type="boolean" required="true">
		    	Specifies whether to generate metadata file.<br/>
		    	Set by default.
		    </property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.io.text.write.TextWriterColumn[]" required="false">
				Aggregates elements with a description of columns to be written to a file.
			</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Contains parameters needed for output data formatting.
			</property>
			<property name="encoding" type="string" required="true">
				Specifies what encoding to use when writing to a file.
			</property>
			<property name="fieldSeparator" type="string" required="true">
				Specifies the sequence to write as a field separator. <strong>Escaped string property.</strong>
			</property>
			<property name="fileName" type="string" required="true">
				Name of the file to be written to.
			</property>
			<property name="compression" type="com.ataccama.dqc.tasks.io.compression.CompressionType" required="true">
				Defines compression type of the output file.<br/>
				Default value: NONE.
			</property>
			<property name="lineSeparator" type="string" required="true">
				Specifies the string to be recognized as a line delimiter. The line delimiter
				can be any sequence of letters, although a specific symbol is often used
				which usually depends on the operating system where the file originated from.
				<strong>Escaped string property.</strong>
			</property>
			<property name="stringQualifier" type="string" required="false">
				Character to be used as a boundary for text strings in the output data.<br/>
				Default value: double quote (&quot;) <strong>Escaped string property.</strong>
			</property>
			<property name="stringQualifierEscape" type="string" required="false">
				Escape character to be used for escaping the <code>String Qualifier</code> character, used to preserve the original meaning of this
				character.<br/>
				Default value: double quote (&quot;) <strong>Escaped string property.</strong>
			</property>
			<property name="useStringQualifierOnAllColumns" type="boolean" required="true">
				Specifies whether to apply the string qualifier to all format columns.<br/>
				Not set by default.
			</property>
			<property name="writeAllColumns" type="boolean" required="true">
				Specifies whether to write out all columns as defined in the input format. This attribute is exclusive
				to column definitions. If this value is set to true there must be no columns defined
				in the columns element, otherwise an error is reported.
			</property>
			<property name="writeHeader" type="boolean" required="true">
				Specifies whether to write the column&#39;s header to the output file.<br/>
				A header line is written by default.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.text.read.TextReaderColumn">
    <description>
			Definition of a single data column to be read from the input file.
		</description>
    <properties>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.io.text.read.TextReaderDataFormatParameters" required="false">
				Local data formatting parameters that override globally defined formatting parameters.
			</property>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="ignore" type="boolean" required="true">
			    Indicates whether the column appears in the output record format. The default value is false.
			</property>
			<property name="type" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">
				Column data type.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.text.read.TextReaderDataFormatParameters">
    <introduction>
			<p align="justify">
				Data format parameters are parameters used for data formatting when an
				internal/external data format conversion is required. This task typically
				occurs when [branding:product.name.abbreviation] needs to load data from an external file or needs to store
				data to an external file. Data format parameters then describe how
				to convert data to the desired form based on the reading and writing file data formats.
			</p>
			<p align="justify">
				Processing steps supporting DataFormatParameters (DFP) can define DFP at the top level
				of a step as well as on the &quot;local&quot; level of each column. If there are no
				DFP defined on the local level, the global DFP are used. If global data format parameters
				are not defined, the default values are assumed. When a column defines its own DFP,
				this DFP must contain all attributes needed for successful parsing (those attributes
				must be assigned valid values). The only exception to this rule is
				<code>Thousands Separator</code>.
				In contrast with the rest of DFP attributes that must always have some value,
				<code>Thousands Separator</code> may remain empty (meaning that no thousands
				separator is used).
			</p>
		</introduction>
    <description>

			<strong>Information about formatting dates</strong>

				<p align="justify">
					For datetime and date types there is an existing output format defined. This format definition is given by a
					textual string that follows the convention used in the Java
					<a href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html" target="_blank">SimpleDateFormat</a>.
				</p>
				<p align="justify">
					The meanings of the most used characters in the formatting string are as follows:<br/>
					y ... year, M ... month in year, d ... day in month. By changing the number of those
					formatting characters it is possible to change the meaning of the characters. <br/>
					NOTE: the formatting string is case sensitive, so the same character has different
					meaning when used as upper or lower case.
				</p>
				<p align="justify">
					Reading a year:<br/>
					If the formatting string contains more than two characters, then the input number
					is interpreted as is, without accounting for the century.<br/>
					If the formatting string contains a shortened version (&quot;y&quot; or &quot;yy&quot;), then the input
					number is parsed against the current data where the resulting date is in the range -80, +20 years
					from the current date. It is important to note that the number of digits in the year must
					strictly comply with the number of its formatting characters. Otherwise, the year is
					read as specified in the input (for format &#39;..yy&#39; and input &#39;...765&#39; the
					resulting year is 765.
				</p>
				<p align="justify">
					Year output format:<br/>
					If the formatting string includes the &quot;yy&quot; form, then the year is transformed into 2 characters,
					otherwise it is formatted as the original number (including completion).
				</p>
				<p align="justify">
					Month output format:<br/>
					If the number of formatting characters for month is &gt;=3,
					then the output is the full month&#39;s name (for example, January), otherwise the output
					is represented by the number (so, for January, it is 1).
				</p>
				<p align="justify">
					Numerical output format: <br/>
					Numerical padding functionality dictates there must be at least as many characters representing the
					digits of the number as contained in the biggest number to be displayed. Shorter numbers
					are filled with zeroes from the left.
				</p>
				<p align="justify">
					When formatting numbers, a number is represented by a template containing the sequence
					of formatting characters. Each formatting character in the template represents one digit
					of the number. Usually it is not necessary to specify the number of digits in the
					template exactly (a number can have a different number of digits and will still be
					parsed correctly). The only exception is when there are two neighboring numbers to
					be parsed. In order to determine which character belongs to which number, the parsing
					templates are applied in their exact form (and therefore the number of characters in
					the template matters).
				</p>
				<p align="justify">
					Processing date from text:<br/>
					If at least 4 formatting characters are specified, then the
					full text form is used, otherwise the short form is used (or at least shortened -
					January/Jan, etc). For reading, the number of formatting characters does not matter
					and all forms are accepted.
				</p>
				<p align="justify">
					Example of input: &quot;yyyy-MM-dd&quot; - accepts input &quot;1970-01-01&quot; <br/>
					Example of output: &quot;d.M.yyyy&quot; - output is 1.1.1970
				</p>

			<strong>Information about parsing boolean values</strong>

				<p align="justify">
					It is possible to define an input/output format for types with the form
					&quot;true-text | false-text&quot;, where true-text (or false-text respectively) is the
					string representing <code>true</code> (or <code>false</code>) values. By default these
					values are set to &quot;true&quot; and &quot;false.&quot;
				</p>
		</description>
    <properties>
			<property name="whitespaceReplacementString" type="string" required="false">
				<p align="justify">
				If specified, the provided string will be used in place of any whitespace character seen in the input
				value of the corresponding column(s). This technique can be useful for avoiding automated whitespace
				trimming in file reader steps or for normalizing whitespace characters in the reading phase.
				</p>
				Default value: none
			</property>
		<property name="dateFormatLocale" type="string" required="false">
				<p align="justify">
				Defines the locale for parsing non-numerical data (for example short forms of months in dates -
				e.g., Sep 18, 1999). The value is the same as the value of the corresponding locale in Java
				(for detail see <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html" target="_blank">Java locales</a>).
				</p>
				Default value: <code>en_US</code> (English - United States)
			</property>
      <property name="dateTimeFormat" type="string" required="false">
				<p align="justify">
				Defines the format that should be used for processing &#39;datetime&#39; data. The template is
				based on <code>SimpleDateFormat</code>, which uses the Java convention.
				</p>
				Default value: <code>yyyy-MM-dd HH:mm:ss</code>
			</property>
      <property name="dayFormat" type="string" required="false">
				<p align="justify">
				Defines the format that should be used for processing &#39;date&#39; data. The template is based on
				<code>SimpleDateFormat</code>, which uses the Java convention.
				</p>
				Default value: <code>yyyy-MM-dd</code>
			</property>
      <property name="decimalSeparator" type="string" required="false">
				<p align="justify">
				Defines what character is used as the decimal separator.
				<strong>Escaped string property.</strong>
				</p>
				Default value: <code>.</code>
			</property>
      <property name="falseValue" type="string" required="false">
				<p align="justify">
				String value that represents a logical &#39;false&#39; value in the given data. The comparison is
				not case sensitive.
				</p>
				Default value: <code>false</code>
			</property>
      <property name="thousandsSeparator" type="string" required="false">
				<p align="justify">
				Defines the string that represents the thousands separator (used in numbers). A non-escaped
				character is expected. Numbers to be read do not need to contain this separator, but
				when the separator is present it is processed (stripped) accordingly. <strong>Escaped string property.</strong>
				</p>
				Default value: <code>,</code>
			</property>
      <property name="trueValue" type="string" required="false">
				<p align="justify">
				String value representing a logical &#39;true&#39; value in the given data. The comparison is not case
				sensitive.
				</p>
				Default value: <code>true</code>
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.experimental.sendmail.TextSubtype">
    <introduction>
			Type of e-mail body text. This determines value of <code>content-type</code> header.
		</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.tokenization.TokenizerConfig">
    <introduction>Preforms vectorization based on trained Text Vectorizer.</introduction>
    <description>
            <p align="justify">
                Uses previously created Vectorizer model to process input data.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.transformation.tokenization.columns.TokenizerFeatureConfig[]" required="true">
                Configuration of features used to preform vectorization of the data based on the model file loaded.
            </property>
            <property name="modelFile" type="string" required="true">
                Name of the file with trained model that will be used for vectorization.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.tokenization.TokenizerTrainerConfig">
    <introduction>Trains Text Vectorizer model.</introduction>
    <description>
            <p align="justify">
                Trains Text Vectoriez model based on selected parameters and input data.
                If result column is filled, use trained model to vectorize input data and output the result to output column.
            </p>
        </description>
    <properties>
            <property name="featureConfigs" type="com.ataccama.dqc.tasks.ai.transformation.tokenization.columns.TokenizerFeatureTrainerConfig[]" required="true">
                Configuration of features used to train the Text Vectorizer and vectorize the input data.
            </property>
            <property name="outputModelFile" type="string" required="true">
                Name of the model output file.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.text.write.TextWriterColumn">
    <description>
			Defines a single text file data column.
		</description>
    <properties>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">
				Local level (column) data format definition. Refer to
				<strong>DataFormatParameters</strong> for details.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be written to the
				output column. If no expression is defined, the value from the input column named
				(as specified by &quot;name&quot; attribute) is written (or an empty value if such name does not
				represent any input column).
			</property>
			<property name="name" type="string" required="true">
				Specifies the name of the column to write to the file. The name of a column does not have to be present in the
				input file format. In this case a new column with the specified name is
				created in the output file format.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.timeseries.TimeSeriesPredictorConfig">
    <introduction>Predicts next values in time series.</introduction>
    <description>
            <p align="justify">
                This steps tries several algorithms for time series prediction and uses the best to predict next values.
                All different models and their variations created from corresponding <strong>model settings</strong>
                create state space that is searched by a grid search in order to find the best model for prediction.
                Algorithms in a grid search are tried sequentially, or in parallel (if parallelism level is greater than 1).
            </p>
            <p align="justify">
                Evaluation of single model instance in a grid search:
                <ul>
                    <li>First, input data of size <em>s</em> is split by the <code>Train Ratio</code> to train data of size <em>n</em> and test data of size <em>m</em>.</li>
                    <li>Second, model is fitted with the first <em>n</em> data and predicts the next value (<em>n+1</em>).</li>
                    <li>Next, model is fitted with the first <em>n+1</em> data and predicts the next value (<em>n+2</em>).</li>
                    <li>...</li>
                    <li>Next, model is fitted with the first <em>s-1</em> data and predicts the next value (<em>s</em>).</li>
                    <li>All of these <em>m</em> predicted values are used to compute model error using selected <propert-ref>metric</propert-ref>.</li>
                </ul>
                After all models were evaluated, model with the least error is used for final prediction.
            </p>
        </description>
    <properties>
            <property name="inputColumn" type="string" required="true">
                Name of the column with time series values. The column must be of numeric type (integer, long, float).
            </property>
            <property name="groupBy" type="com.ataccama.dqc.tasks.ai.timeseries.Component[]" required="false">
                Set of definitions of grouping keys. This is used when there are multiple time series, where each time series has its own group key.
            </property>
            <property name="orderBy" type="string" required="false">
                Expression used for sorting time series values.
            </property>
            <property name="metric" type="com.ataccama.ai.algorithms.commons.Metrics$Values" required="true">
                Metric used when evaluating model performance in the grid search.
            </property>
            <property name="trainRatio" type="float" required="true">
                Lower bound of proportion of data that will be used for fitting and evaluating the model.
                <br/>
                Default value = <code>0.75</code>.
            </property>
            <property name="numberOfPredictions" type="integer" required="true">
                Number of future points to be predicted by the step.
                <br/>
                Default value = <code>1</code>.
            </property>
            <property name="modelSettings" type="com.ataccama.dqc.tasks.ai.timeseries.settings.ModelSettings[]" required="true">
                Different model definitions to be tried in the grid search.
            </property>
            <property name="recordNumberBinding" type="string" required="false">
                Column for outputting order of predicted values (sequence starting from 1).
            </property>
            <property name="modelBinding" type="string" required="false">
                Column for outputting model used for prediction.
            </property>
            <property name="metricBindings" type="com.ataccama.dqc.tasks.ai.timeseries.MetricBinding[]" required="true">
                Columns for outputting metrics computed while fitting the model that is used for prediction.
            </property>
        <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig$TokenType">
    <properties>
			<property name="tokenCharacters" type="string" required="false">
				A set of characters which are acceptable as consecutive characters within the same token
				(i.e. these character are acceptable values which can follow the beginning of the token).
			</property>
			<property name="tokenStartCharacters" type="string" required="false">
				A set of characters which, when found in the input string, represent the beginning of a new token.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.tokenization.definition.TokenizationFeatureTransformation">
    <introduction>Type of Vectorization.</introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.TokenizerAlgorithm">
    <introduction>Splits words from the input value into separate columns.</introduction>
    <description>
			This step splits content provided by the input columns into specified output columns
			using the defined tokenizer. If the tokenizer is not defined, a default one is used.
			The default tokenizer recognizes tokens comprised of numbers and text characters only;
			other characters are considered as delimiters. Default tokenizer settings are illustrated
			in the following example (i.e., the output is the same whether the tokenizer is configured
			or not):<br/>
			Tokenizer output columns are combined into a single string, and individual tokens are delimited
			with a character defined using the <code>Separator</code> property. This property can be defined
			on both global and local levels. If a separator is not defined on the global level, a default value of
			<code>&#39; &#39;</code> is used. On the local level, the <code>Separator</code> can be defined within individual <code>Columns</code>
			properties. Otherwise, the global value is used instead.
		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.clean.TokenizerColumn[]" required="true">
				This section associates individual <code>column</code> tags representing inputs/outputs.
				Individual <code>column</code> definitions are processed in sequence as they are
				defined within this configuration section.
			</property>
			<property name="separator" type="string" required="false">
				Global separator value. If not defined, a default value of <code>&#39; &#39;</code> is used.
			</property>
			<property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Configurable tokenizer Settings.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.TokenizerColumn">
    <properties>
			<property name="separator" type="string" required="false">
				A single character used as a string delimiter to separate individual tokens.
				If the delimiter is not defined, the global delimiter is used.
				If a sequence of characters is defined, only the first character is used.
			</property>
			<property name="src" type="string" required="true">
				Expression to evaluate to get the value to be tokenized.
			</property>
			<property name="target" type="string" required="true">
				Column that stores the result of the tokenization process.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.abp.parser.ITokenizerConfig">
    <introduction>
            General configuration of tokenization. 
            See <strong>ConfigurableTokenizerConfig</strong>
            for details.
        </introduction>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.tokenization.columns.TokenizerFeatureConfig">
    <introduction>Configuration of features used to preform the vectorization transformation.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be present in model file.
            </property>
            <property name="sourceColumn" type="string" required="true">
                Data input column for vectorization transformation.
            </property>
            <property name="resultColumn" type="string" required="true">
                Output column, where the result of vectorization transformation will be outputted to. Can be equal to source column.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.transformation.tokenization.columns.TokenizerFeatureTrainerConfig">
    <introduction>Configuration of features used for vectorization.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be used in classification step.
            </property>
            <property name="sourceColumn" type="string" required="true">
                Data input column for training the vectorization.
            </property>
            <property name="resultColumn" type="string" required="false">
                When filled, Text Vectorizer will do vectorization on the source column and output it into result column.
            </property>
            <property name="vectorizer" type="com.ataccama.dqc.tasks.ai.transformation.tokenization.definition.TokenizationFeatureTransformation" required="true">
                Type of Vectorization.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.classification.columns.TrainerColumn">
    <description>
			Definition of a column values for creating model.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be used for creating model.
				If no expression is defined, the value from the input column named (as specified by &quot;name&quot; attribute)
				is written.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.classification.columns.TrainerColumn" name="com.ataccama.dqc.tasks.classification.columns.TrainerColumnContinuous">
    <description>
			Definition of a continuous column values for creating model.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be used for creating model.
				If no expression is defined, the value from the input column named (as specified by &quot;name&quot; attribute)
				is written.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.classification.columns.TrainerColumn" name="com.ataccama.dqc.tasks.classification.columns.TrainerColumnDiscrete">
    <description>
			Definition of a discrete column values for creating model.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be used for creating model.
				If no expression is defined, the value from the input column named (as specified by &quot;name&quot; attribute)
				is written.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.classification.columns.TrainerColumn" name="com.ataccama.dqc.tasks.classification.columns.TrainerColumnDocument">
    <description>
			Definition of a column values with text from document for creating model.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Column name.
			</property>
			<property name="expression" type="string" required="false">
				Defines an expression to execute in order to get the value to be used for creating model.
				If no expression is defined, the value from the input column named (as specified by &quot;name&quot; attribute)
				is written.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.ai.supervised.columns.TrainingFeatureConfig">
    <introduction>Configuration of features used to fit the model.</introduction>
    <properties>
            <property name="featureName" type="string" required="true">
                Name of the feature. The same name must be used in classification step.
            </property>
            <property name="featureColumn" type="com.ataccama.ai.commons.steps.column.FeatureColumn" required="true">
                A way how to parse feature from the column.
            </property>
            <property name="transformations" type="com.ataccama.dqc.tasks.ai.supervised.columns.transformations.FeatureTransformation[]" required="false">
                Transformations, that are done on this feature before using it for fitting the model.
            </property>
            <property name="isVector" type="boolean" required="false">
                Not relevant at the moment. Leave false.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.TransformLegalFormsAlgorithm">
    <introduction>Transforms legal forms in the input string.</introduction>
    <description>
			This step transforms legal forms found in an input value (the property <code>In</code>) and generates a final translated value stored in
			the output (the property <code>Out</code>) data record.
			The transformation consists of finding all known forms (i.e., different ways how users type legal forms) within the input
			string and transforming them into the correct and official forms.<br/>
			If the output for obtained official legal forms (the property <code>In</code>) is defined, they are all stored in the specified column.
			If more than one legal form is found, they are all separated by a delimiter specified in the <code>Separator</code> property.
			If no input data is available, the scoring flag <code>TLF_NULL</code> is set. If any transformations have been performed,
			the scoring flag <code>TLF_CHANGED</code> is set.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="formOut" type="string" required="false">
				Column that stores transformed legal forms (if any).
			</property>
			<property name="in" type="string" required="true">
				Column that contains the input string to be transformed.
			</property>
			<property name="legalFormsLookupFileName" type="string" required="true">
				Dictionary file that contains known legal forms.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="out" type="string" required="true">
				Column that stores the final string with all legal forms transformed into their official versions.
			</property>
			<property name="separator" type="string" required="false">
				A single character or sequence of characters used as string delimiters to break output data
				(legal forms) into words.
			</property>
			<property name="tokenizer" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Configuration how to split input text into tokens.
				The default tokenizer setting distinguishes words, numbers and other single characters, except
				for whitespace characters (space, tab).
			</property>
			<property name="ignoredSeparators" type="string" required="false">
				Definition of characters that might be ignored when input token
				cannot be matched to expected token in translation rule. 
				Expected token can be ignored only if it is defined as ignorable,
				with input token either being skipped when it is ignorable as well, or preserved.
				<br/>
				The set is defined by means of <strong>character set</strong>).
				For a detailed description see <strong>Strip titles</strong>
				and its <strong>example</strong>.
			</property>
            <property name="preserveUnsupportedChars" type="boolean" required="false">
                If true then unsupported characters immediately following replaced text will be copied to
                output, otherwise these characters will be removed. For detailed description of these characters,
                see <strong>Matching Value Generator Config</strong>.<br/>
                Default value: <code>true</code> 
            </property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="TLF_NULL">
				A scoring flag indicating that input data is missing.
			</scoringKey>
			<scoringKey name="TLF_CHANGED">
				A scoring flag indicating that replacement of legal forms was performed.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.transliterate.TransliterateAlgorithm">
    <introduction>Transliterates a defined set of input strings to a defined set of strings.</introduction>
    <description>
         For each row it can transform value given by an expression and store it into an output
         column. There can be more input expressions and output columns. The transformation
         tries to find substrings (given by the property <code>Rules</code>) in the input expressions and
         substitutes them by string given in the matching rule. When there are two rules with the same prefix,
         the longest possible rule is always used (i.e. considered as matched) .
		</description>
    <properties>
			<property name="columns" type="com.ataccama.dqc.tasks.clean.transliterate.FromColumnToColumn[]" required="true">
			 Each row defines an input expression whose value is transformed according to the rules and stored into an output column.
			</property>
			<property name="rules" type="com.ataccama.dqc.tasks.clean.transliterate.SubstitutionRule[]" required="true">
            Each row defines one rule which consists of a searched string and a replacing string.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.Trash">
    <introduction>Ends data flow without doing anything with the data.</introduction>
    <description>
			Reads all data from the specified input and no operation is performed. Input data records are neither persisted to disk,
			nor passed along to other processing steps.<br/>
			Its behavior is similar to the <code>/dev/null</code> device in UNIX based operating systems.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfTriggerWorkflowTask">
    <introduction>Triggers invocation of the specified workflow.</introduction>
    <description>If synchronous=false, the task quits immediately after triggering (it does not wait until the invoked workflow is finished); otherwise, the task waits until the invoked workflow is finished. In the synchronous mode, task result is equal to invoked workflow result.</description>
    <properties>
			<property name="parameters" type="com.ataccama.adt.task.base.KeyValueMapping$Parameter[]" required="false">Set of parameters to pass to the workflow as global variable values.</property>
			<property name="synchronous" type="boolean" required="true">Invocation type.</property>
			<property name="workflowId" type="string" required="true">Id of a workflow to run. Workflow Id specification depends on the workflow execution context:
			<ul>
				<li>In the server context, use the <code>&lt;sourceId&gt;:&lt;workflowName&gt;.ewf</code> notation, e.g., WF02:02_03b_Executor.ewf. The <code>sourceId</code> prefix is defined in Workflow Server Component.</li>
				<li>Outside the server (from IDE or via <code>runewf.[bat|sh]</code>), you can use two mutually exclusive notations:
					<ul>
						<li>
                <code>&lt;sourceId&gt;:&lt;workflowName&gt;.ewf</code>; in this case, the <code>&lt;sourceId&gt;:</code> prefix is ignored and the specified workflow from the current folder is run. This is useful when you want to develop and test workflows locally in the IDE and deploy them to server later on.</li>
						<li>
                <code>&lt;path&gt;/&lt;workflowName&gt;.ewf</code>, e.g., ../02_Run_Plans/02_03b_Executor.ewf. The <code>path</code> is optional and is relative to the current workflow.</li>
					</ul>
				</li>
			</ul>
      </property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.timeseries.settings.ModelSettings" name="com.ataccama.dqc.tasks.ai.timeseries.settings.TripleExponentialSmoothingSettings">
    <introduction>
            Triple exponential smoothing.
        </introduction>
    <description>
            <p align="justify">
                <strong>Additive model</strong>
                <br/>
                l(t) = alpha * (x(t) - s(t-period)) + (1 - alpha) * (l(t-1) + b(t-1))
                <br/>
                b(t) = beta * (l(t) - l(t-1)) + (1 - beta) * b(t-1)
                <br/>
                s(t) = gamma * (x(t) - l(t)) + (1 - gamma) * s(t-period)
                <br/>
                prediction: F(t+m) = l(t) + (m * b(t)) + s(t-period+mMod)
                <br/>
                where mMod = floor((m - 1) mod period) + 1
            </p>
            <p align="justify">
                <strong>Multiplicative model</strong>
                <br/>
                l(t) = alpha * (x(t) / s(t-period)) + (1 - alpha) * (l(t-1) + b(t-1))
                <br/>
                b(t) = beta * (l(t) - l(t-1)) + (1 - beta) * b(t-1)
                <br/>
                s(t) = gamma * (x(t) / l(t)) + (1 - gamma) * s(t-period)
                <br/>
                prediction: F(t+m) = (l(t) + (m * b(t))) * s(t-period+mMod)
                <br/>
                where mMod = floor((m - 1) mod period) + 1
            </p>
        </description>
    <properties>
            <property name="settings" type="com.ataccama.dqc.tasks.ai.timeseries.settings.ExponentialSmoothingSingleParameterSettings[]" required="true">
                <strong>Alpha</strong> - Alpha values to try in the grid search.
                <br/>
                <strong>Beta</strong> - Beta values to try in the grid search.
                <br/>
                <strong>Gamma</strong> - Gamma values to try in the grid search.
            </property>
            <property name="periods" type="string" required="true">
                Different periods to try in the grid search. Comma separated values.
                <br/>
                Default value = <code>4,7,12</code>.
            </property>
            <property name="additive" type="boolean" required="false">
                If additive seasonal naive model should be tried in the grid search.
                <br/>
                Default value = <code>true</code>.
            </property>
            <property name="multiplicative" type="boolean" required="false">
                If multiplicative seasonal naive model should be tried in the grid search.
                <br/>
                Default value = <code>true</code>.
            </property>
        <property name="active" type="boolean" required="true">
                If this model should be used in the grid search.
            </property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.commons.security.IIdentity" name="com.ataccama.dqc.communication.auth.server.TrustIdentity">
    <introduction>The identity has all possible roles, allowing the execution of all services.</introduction>
    <description>The identity has all possible roles, allowing the execution of all services.</description>
    <properties>
			<property name="name" type="string" required="false">Defines identity name.</property>
			<property name="roles" type="string[]" required="false"> </property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.communication.auth.server.IServerAuthenticationMethod" name="com.ataccama.dqc.communication.auth.server.TrustServerMethod">
    <introduction>No authentication. If specified, all requests will be assigned the identity defined in the <strong>Identity</strong> element.</introduction>
    <description>No authentication. If specified, all requests will be assigned the identity defined in the <strong>Identity</strong> element.</description>
    <properties>
			<property name="identity" type="com.ataccama.dqc.commons.security.IIdentity" required="false">Identity definition: identity name and assigned roles. Possible implementations: Standard Identity, Trust Identity.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.match.Type">
    <description>Available types of output.</description>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.global.domain.transformation.SourceTransformation" name="com.ataccama.one.profiling.linear.simple.params.global.domain.transformation.TypeTransformation">
    <introduction>Type transformation converts data to different data type before expression evaluation.</introduction>
    <properties>
			<property name="toType" type="com.ataccama.dqc.model.elements.data.ColumnType" required="true">Data type that you would like to transform your input data (STRING, INTEGER, LONG, etc.).</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfUnzipFileOperation">
    <introduction>Extracts a source zip file to the destination folder.</introduction>
    <description>Extracts a source zip file to the destination folder.</description>
    <properties>
			<property name="overwriteFlag" type="boolean" required="true">Permission to overwrite zip file. The task fails when <strong>Overwrite Flag</strong> is false and <strong>Target File</strong> already exists. </property>
			<property name="sourceFile" type="string" required="true">Path to the source file. The task fails when the source does not exist.</property>
			<property name="targetFile" type="string" required="true">Path to the destination folder. If the target folder structure does not exist, it will be created automatically (with respect to permissions on the filesystem).</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.adt.task.base.IUrlResourceConfig" name="com.ataccama.adt.task.base.URLExpression">
    <introduction> </introduction>
    <description> </description>
    <properties>
			<property name="password" type="string" required="false">Password used for authorization; plain text or encrypted password is supported. Workflow editor encrypts password automatically.</property>
			<property name="url" type="string" required="false">URL must contain protocol identifier (HTTP and HTTPS is supported). <strong>Url</strong> property expects an expression, so you must enclose the string into quotes (e.g., &#39;http://localhost:8888/console/wfDeferred/&#39;).</property>
			<property name="userName" type="string" required="false">Username used for authorization.</property>
		</properties>
    <scoring/>
  </class>
  <class super="com.ataccama.adt.task.base.IUrlResourceConfig" name="com.ataccama.adt.task.base.URLResourceBean">
    <introduction> </introduction>
    <description> </description>
    <properties>
			<property name="urlResourceName" type="string" required="false">Name of the URL resource to be used.</property>
		</properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.UnifyEngine">
    <introduction>Unifies and groups records by the defined strategy and matching keys.</introduction>
    <description>

		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="attributes" type="com.ataccama.dqc.tasks.identify.UnifyEngineAttributes" required="true">
        		Specification of step input and output parameters.
			</property>
			<property name="ignoreOlder" type="boolean" required="true">
				When <code>Timestamp Column</code> is used and the incoming record update is older than the repository record,
				this flag specifies how this status is managed.
				<br/>false: (newer) the repository record is processed instead of the incoming one.
				<br/>true: the incoming record is fully ignored as it hasn&#39;t been contained in the input.
			</property>
			<property name="ignoreManualOverride" type="boolean" required="true">
				Do not process manual override rules even though they are contained in the repository.
				<br/>Default value: false.
			</property>
			<property name="exportChangedOnly" type="boolean" required="true">
				Send only changed records to the output. Changed records are all records
				from input, including deletions, and records from repository that have been changed during unification
				(some of id or role has changed).
				<br/>Default value: false.
			</property>
			<property name="defaultMaxIterations" type="integer" required="true">
				Default value for the <code>Max Iterations</code> parameter of grouping methods.
				<br/>Default value: 1.
			</property>
			<property name="useExternalIds" type="boolean" required="true">
				Use candidate and matching ids and roles from the input rather than from the repository.
				Used only in the special case of reunifying all records which already have some unification attributes.
				The repository must be empty.
				<br/>Default value: false.
			</property>
			<property name="defaultLocale" type="string" required="false">
				Default locale definition for string values to compare.
			</property>
			<property name="defaultMergeSurvivorSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Default <code>Merge Survivor Selection Rule</code> criterion for all grouping methods.
			</property>
			<property name="groups" type="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod[]" required="false">
				List of grouping method definitions. Each unified record belongs to the first method
				where the <code>When</code> condition evaluates to true.
			</property>
			<property name="matchingMeasures" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingMeasure[]" required="false">
				List of Matching Measures.
			</property>
			<property name="defaultMatchingRules" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Default <code>Matching Rules</code> criterion for all grouping methods.
				<br/>Note: two records named &quot;pivot&quot; and &quot;candidate&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
			<property name="usePivotAsSurvivor" type="boolean" required="true">
				Specifies if pivot records (with roles <code>M</code> and <code>I</code>)
				are used as &quot;Merge survivors&quot; of candidate or matching groups, respectively.
				<br/>Default value: false. (Special MSR records and msr-role is used).
				See <strong>ID Stability</strong>.
			</property>
			<property name="minimumIdToAssign" type="long" required="true">
				Minimal value for the newly assigned group id. Must be &gt;= 1.
				<br/>Default value: 1.
			</property>
			<property name="defaultPivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Default <code>Pivot Selection Rule</code> criterion for all grouping methods.
			</property>
			<property name="repository" type="com.ataccama.dqc.tasks.identify.repository.RepositoryProperties" required="false">
				Repository specification.
			</property>
			<property name="repositoryColumns" type="com.ataccama.dqc.tasks.common.column.ColumnRef[]" required="false">
				List of columns stored in the repository. At least all columns needed for unification
				must be present.
			</property>
			<property name="mapAllColumns" type="boolean" required="true">
				Specifies that all columns of the input record format will be stored in the repository.
				The property <code>Repository Columns</code> must be empty when true.
				<br/>Default value: true.
			</property>
			<property name="deleteMark" type="string" required="false">
				Records with this value in <code>Change Type Column</code> will
				be considered as deleting commands.
				<br/>Default value: &quot;D&quot;.
			</property>
			<property name="identify" type="boolean" required="true">
				Specifies identification mode (not unification). If set, repository access is
				read-only and primary key column is not mandatory.
				<br/>Default = false. 
			</property>
			<property name="groupIdStrategy" type="com.ataccama.dqc.tasks.identify.GroupIdStrategy" required="false">
				Defines how merge survivors will be used in some special cases. 
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.generator.multi.IRandomRecordCountGeneratorConfig" name="com.ataccama.dqc.tasks.generator.multi.UniformRecordCountGenerator">
    <description>
			Number of child records is random number from uniform distribution between <code>minRecordCount</code> and <code>maxRecordCount</code> (inclusive).
		</description>
    <properties>
			<property name="minRecordCount" type="integer" required="true">
				Minimum number of child reocrds per one parent records.
			</property>
			<property name="maxRecordCount" type="integer" required="true">
				Maximum number of child reocrds per one parent records.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.identify.UnifyEngineAttributes">
    <introduction>
        	List of output and input columns or an expression of the Unification step.
        </introduction>
    <properties>
			<property name="candidateIdColumn" type="string" required="true">
				String/integer/long column for storing the candidate id. The input value is used only when <code>Use External Ids</code> is specified.
			</property>
			<property name="matchingIdColumn" type="string" required="true">
				String/integer/long column for storing the matching id. The input value is used only when <code>Use External Ids</code> is specified.
			</property>
			<property name="unificationRoleColumn" type="string" required="true">
				String column for storing the unification role (M, I, S, R, N).
				The input value is used only when <code>Use External Ids</code> is specified and <code>Use Pivot As Survivor</code> is true.
			</property>
			<property name="ruleNameColumn" type="string" required="false">
				String column for storing the name of the matching rule used in matching group collecting.
			</property>
			<property name="matchQualityColumn" type="string" required="false">
				Float column to store results of <code>Match Quality Expression</code>.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				String column for storing identification of record in matching group. This value
				can be used in <strong>Selector</strong> or
				<strong>GroupAssigner</strong> steps.
			</property>
            <property name="candidateRecordDescriptorColumn" type="string" required="false">
                String column for storing identification of record in candidate group. This value
                can be used in <strong>Selector</strong> or
                <strong>GroupAssigner</strong> steps.
            </property>
			<property name="primaryKeyColumn" type="string" required="false">
				Column containing the unique primary key of the records. Used and required only in incremental mode.
			</property>
			<property name="changeTypeColumn" type="string" required="false">
				String column or expression containing a flag indicating whether the record has to be removed from the repository (see the parameter <code>Delete Mark</code>).
				Used only in incremental mode.
			</property>
			<property name="timestampColumn" type="string" required="false">
				Datetime column or expression containing the optional last record update time.
				Used only in incremental mode.
			</property>
			<property name="mergeSurvivorRoleColumn" type="string" required="false">
				String column for storing the merge survivor role (NN, ST, SN, NT).
				This role is used and the property is required only in incremental mode when <code>Use Pivot As Survivor</code> is false.
				The input value is used only when <code>Use External Ids</code> is specified.
				See <strong>ID Stability</strong>.
			</property>
			<property name="changedFlagColumn" type="string" required="false">
				Boolean column for storing a boolean flag indicating that the record has changed.
				Used only in incremental mode.
			</property>
			<property name="oldCandidateIdColumn" type="string" required="false">
				String/integer/long column for candidate id before the current unification.
				Used only in incremental mode.
			</property>
			<property name="oldMatchingIdColumn" type="string" required="false">
				String/integer/long column for matching id before the current unification.
				Used only in incremental mode.
			</property>
			<property name="oldUnificationRoleColumn" type="string" required="false">
				String column for unification role before the current unification.
				Used only in incremental mode.
			</property>
			<property name="overrideRoleColumn" type="string" required="false">
				String column for role in manual override processing (N, O, P, S).
				Used only in incremental mode.
			</property>
        </properties>
  </class>
  <class super="com.ataccama.dqc.unify.config.IOperationConfig" name="com.ataccama.dqc.unify.config.UnifyOperation">
    <introduction>
			Unification stage. For a detailed description of Unification see the <strong>Unification</strong> step.
		</introduction>
    <description>
		</description>
    <properties>
			<property name="id" type="string" required="true">
				Unique operation id.
			</property>
			<property name="candidateIdColumn" type="string" required="true">
				String/integer/long column for storing the candidate id.
			</property>
			<property name="matchingIdColumn" type="string" required="true">
				String/integer/long column for storing the matching group id.
			</property>
			<property name="unificationRoleColumn" type="string" required="true">
				String column for storing the unification role (M, I, S, R, N).
			</property>
			<property name="ruleNameColumn" type="string" required="false">
				String column for storing the name of the matching rule used in  group collection.
			</property>
			<property name="matchQualityColumn" type="string" required="false">
				Float column to store results of <code>Match Quality Expression</code>.
			</property>
			<property name="recordDescriptorColumn" type="string" required="false">
				String column for storing identification of record in matching group. This value
				can be used in <strong>Selector</strong> or
				<strong>GroupAssigner</strong> steps.
			</property>
			<property name="candidateRecordDescriptorColumn" type="string" required="false">
				String column for storing identification of record in candidate group. This value
				can be used in <strong>Selector</strong> or
				<strong>GroupAssigner</strong> steps.
			</property>
			<property name="mergeSurvivorRoleColumn" type="string" required="false">
				String column for storing the merge survivor role (NN, ST, SN, NT).
				This role is used and the property is required only in incremental mode when <code>Use Pivot As Survivor</code> is false.
				See <strong>ID Stability</strong>.
			</property>
			<property name="oldCandidateIdColumn" type="string" required="false">
				String/integer/long column for the candidate id before current unification.
				Used only in incremental mode.
			</property>
			<property name="oldMatchingIdColumn" type="string" required="false">
				String/integer/long column for the matching group id before current unification.
				Used only in incremental mode.
			</property>
			<property name="oldUnificationRoleColumn" type="string" required="false">
				String column for the unification role before current unification.
				Used only in incremental mode.
			</property>
			<property name="unificationChangeStatusColumn" type="string" required="false">
				Boolean column indicating that some unification attributes (candidate or matching
				group id or unification role) have changed.
			</property>
			<property name="defaultMaxIterations" type="integer" required="true">
				Default value for the <code>Max Iterations</code> parameter of grouping methods.
				<br/>Default value: 1.
			</property>
			<property name="defaultLocale" type="string" required="false">
				Default locale definition for the compared string values.
			</property>
			<property name="defaultMergeSurvivorSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Default <code>Merge Survivor Selection Rule</code> criterion for all grouping methods.
			</property>
			<property name="groups" type="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod[]" required="false">
				List of grouping method definitions. Each unified record belongs to the first method
				where the <code>When</code> condition evaluates to true.
			</property>
			<property name="matchingMeasures" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingMeasure[]" required="false">
				List of Matching Measures.
			</property>
			<property name="defaultMatchingRules" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Default <code>Matching Rules</code> criterion for all grouping methods.
				<br/>Note: two records named &quot;pivot&quot; and &quot;candidate&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
			<property name="usePivotAsSurvivor" type="boolean" required="true">
				Specifies if pivot records (with roles <code>M</code> and <code>I</code>)
				are used as &quot;Merge survivors&quot; of candidate or matching groups, respectively.
				<br/>Default value: false. (Special MSR records and a msr-role is used).
				See <strong>ID Stability</strong>.
			</property>
			<property name="groupIdStrategy" type="com.ataccama.dqc.tasks.identify.GroupIdStrategy" required="false">
				Defines how merge survivors will be used in some special cases. 
			</property>
			<property name="defaultPivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Default <code>Pivot Selection Rule</code> criterion for all grouping methods.
			</property>
			<property name="outputDiscardedIds" type="com.ataccama.dqc.unify.config.UnifyOperation$DiscardedIdsSpecification" required="true">
				Some previously assigned group IDs may be discarded during incremental unification process
				(e.g. when two matching groups have been joined into one). This switch specifies, that
				and which IDs have to be sent to special output. The extended unification step has another
				additional output endpoint (named &lt;is&gt;_discardedIds) when other than NONE is selected. 
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.flow.Union">
    <introduction>Merges two input data flows into a single data flow (horizontal merge).</introduction>
    <description>
			This step merges input formats of two defined inputs into a single output format. 
			This merge is based on defined <code>Column Mappings</code>. Data are read from their 
			individual inputs (<code>in_a</code> or <code>in_b</code>) and written to the output. Therefore, 
			in the output there are merged-format data records, where each row contains data read from 
			either <code>in_a</code> or <code>in_b</code> input. 			
		<br/>

		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="columnMappings" type="com.ataccama.dqc.tasks.flow.ColumnMapping[]" required="false">
			Contains &quot;columnMapping&quot; elements with column mapping definitions.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.identify.grouping.IGroupingMethod" name="com.ataccama.dqc.tasks.identify.grouping.Union">
    <introduction>
        	Unification method where candidate groups are based on more than one key.
        </introduction>
    <properties>
	        <property name="keys" type="com.ataccama.dqc.tasks.common.components.UnionKey[]" required="true">
	        	Set of union keys. Records which have at least one those keys in common that is non-null will
	        	belong to one group.
	        </property>
        <property name="when" type="string" required="false">
				Boolean condition for using the current grouping method.<br/>
				Default value: true.
			</property>
      <property name="pivotSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting the &quot;Pivot record&quot; from a set of candidates.
				A matching group is constituted of one pivot record and candidates which
				are near to the pivot record, i.e. which satisfy one of the matching rules.
			</property>
      <property name="maxIterations" type="integer" required="false">
				Maximum number of iterations of the matching group assigning process. Consequently,
				it is maximum number of matching groups in one candidate group.
			</property>
      <property name="mergeSurvivorSelectionRule" type="com.ataccama.dqc.tasks.common.components.OrderBy[]" required="false">
				Defines the criterion for selecting one &quot;Merge survivor record&quot;, which must be
				assigned for each newly created group (candidate or matching). This
				criterion is used when more than one prior MSR records occurs in group.
				<br/>Ignored when <code>Use Pivot As Survivor</code> is specified.
			</property>
      <property name="matchingRules" type="com.ataccama.dqc.tasks.identify.matcher.config.MatchingRule[]" required="false">
				Set of rules used for determining when a candidate record is near the pivot record
				and belongs to its matching group.
				<br/>Note: two records named &quot;pivot&quot; and &quot;candidate&quot; are used in <code>Expression</code> property of each matching rule.
			</property>
      <property name="matchNearest" type="boolean" required="true">
				If specified, candidate will be assigned to matched group with minimal value of <code>Match Quality Expression</code>.
				If not specified, candidate will be assigned to matched group with the best pivot (default behavior). 
			</property>
      <property name="matchQualityExpression" type="string" required="false">
				Numeric (integer, long or float) expression that can be used to evaluate match quality of candidate record with it&#39;s pivot record.
				<br/>Similarly as in <code>Expression</code>
				compared records are referred by two dot-sources <code>pivot</code> and <code>candidate</code>.
				Results of <strong>Matching Measure</strong>
				referred via dot-source <code>measures</code> are accessible, too.
			</property>
    </properties>
  </class>
  <class super="com.ataccama.dqc.tasks.io.gdr.reader.member.StructuredMemberBase" name="com.ataccama.dqc.tasks.io.gdr.reader.member.Union">
    <properties>
			<property name="name" type="string" required="true">
				The name of this structured member. Also the name of its endpoint if it is drawn out.
			</property>
			<property name="endpoint" type="boolean" required="true">
				Controls if the endpoint of this structured member is available or not.
			</property>
			<property name="members" type="com.ataccama.dqc.tasks.io.gdr.reader.member.IMember[]" required="true">
				The sub-members of this structured member - both fields and child structured members.
			</property>
			<property name="shadowColumns" type="com.ataccama.dqc.tasks.common.column.ShadowColumnDef[]" required="true">
				Shadow columns of this structured member. If defined, they are available even when the endpoint is not drawn out.
			</property>
		 	<property name="parentIdColumn" type="string" required="false">
		 	Expression evaluating unique id of superior record. The id is used as part of <strong>recordDescriptor</strong>
		 	assigned to group of records generated by this output and belonging to that parent record. Name of parent output
		 	is used as dot-source name referring to parent record columns.
		 	Inapplicable at top level output.
		 	</property>
		 	<property name="recordDescriptor" type="string" required="false">
		 	Name of (usually shadow) string column defined in this output where the record descriptor will be stored. Applicable
		 	at non-top level only and when <strong>parentIdColum</strong> is defined. 
		 	</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.addresses.commons.model.components.EntityComponent" name="com.ataccama.dqc.addresses.commons.model.components.UnionEntityComponent">
    <introduction>
    		Definition of the entity component that is defined as a union of several 
    		subcomponents of the same kind (e.g., street number and land registry number).
    	</introduction>
    <properties>
    		<property name="components" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference[]" required="true">
    			Set of subcomponents as references to components. 
    		</property>
	        <property name="matchingValue" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="false">
	        	Definition of matching value for this component&#39;s dictionary.
	        	If the definition is missing, then definition from parent reference data
	        	is used. <br/>
	        	Default value: undefined (i.e. use definition from 
	        	<strong>reference data definition</strong> configuration element).
	        </property>
	    <property name="id" type="string" required="true">
	        	Identifier of the component.
	        </property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.components.UnionKey">
    <properties>
	        <property name="components" type="com.ataccama.dqc.tasks.common.components.UnionKeyComponent[]" required="true">
	        	Set of components of the key.
	        </property>
	        <property name="noKeyCond" type="string" required="false">
	        	Condition specifying when this key is assumed to be unusable and is therefore not used as a matching key in candidate group collection.
	        </property>
	        <property name="noEmptyComponent" type="boolean" required="true">
				Specifies that all components have to be valid (non-null) to conform valid key.
				If false (default) and at least one component is non-null, the key is valid and used.
	        </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.components.UnionKeyComponent">
    <properties>
	        <property name="behaveAsSet" type="boolean" required="true">
	        	Specify that the component value has to be assumed as a list of string values separated by spaces.
	        	Each of these values is used as one matching value in candidate group collection.
	        	The expression must be of string data type when the parameter is set to <code>true</code>.
	        	<br/>
	        	E.g., a record with the component value &quot;JOHN FITZGERALD&quot; then matches another one having the component value &quot;FITZGERALD&quot;.
	        	<br/>Default value: false.
	        </property>
	        <property name="separator" type="string" required="false">
	        	Characters used as word separator when <code>behaveAsSet</code> is true.
	        	<br/>
	        	Default: (one) space.
	        </property>
	        <property name="expression" type="string" required="true">
				Expression calculating one key component value. Non-string values are converted into string.
	        </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.conditions.UnionSame">
    <introduction>Merges multiple data flows with the same format into a single data flow.</introduction>
    <description>
		This step combines multiple separate data flows into single data flow.
		<br/>
      <br/>
		The input data flows must have the same column definitions (meaning the same names and types of columns).
		The columns must also be in the same order. The column definition of the output data flow corresponds
		to the column definition of the input flows.

		</description>
    <bindings>
		</bindings>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.UpdateGenderAlgorithm">
    <introduction>Determines gender based on first and last name.</introduction>
    <description>
			Based on a specified first name and last name, this step determines gender value and verifies it against
			any provided input value. The final result can be one of the following:
			<ul>
				<li>Gender value is confirmed - value determined by the step corresponds to the original (input) value
				and in the output the original value is stored (CONFIRMED).
				</li>
				<li>A problem - mismatch found during evaluation: the value determined from the first name doesn&#39;t match
				the value determined from the last name. The original value is stored in the output (MISMATCH).
				</li>
				<li>A problem - mismatch between the determined and original value was found, but the determined
				gender was not verified definitely/sufficiently (with percentage above the required threshold - see below)
				using both first and last name.
				The original value is stored in the output and the value that is, according to the step, probable is stored in the property <code>Estimated Gender</code> (CHANGE_SUGGESTION).
				</li>
				<li>Gender value is changed - the step result unambiguously (using both first and last name) confirms
				one definite value. In this case the original gender value is changed (CHANGED).
				</li>
				<li>Value cannot be determined because the step is not capable of determining the gender value using the 
				given first name and last name (UNDECIDABLE).
				</li>
			</ul>
			<br/>
			Determination of the gender value is dictionary based. Dictionaries contain known first and last names
			together with information about a ratio in which the name is represented within men and women.
			The final decision about the gender value is then based on the threshold, which is 51 percent by default (i.e.,
			only first names and last names with a minimum of 51 percent ratio each are considered to confirm the gender value
			unambiguously). The default value can be changed using the properties <code>Name Sureness Level</code> and
			<code>Surname Sureness Level</code> (a percentage; the step accepts values between 51 and 100).
			NOTE: statistical data with first names and last names for
			Czech Republic were used as a resource for the dictionaries.
			<br/>
      <br/>
			The original gender value is replaced <strong>only if the derived gender value is determined identically
			by both	first and last name</strong> (both satisfy the defined threshold).
			In other cases <strong>the original (input) value is stored in the output</strong>. If the input value
			is incorrect (and/or not found in the dictionary), it is considered to be empty and the step sets
			the scoring flag <code>GNDR_GENDER_MISMATCH</code>.
			<br/>
      <br/>
			This step supports also single-based verification - using the last name only, but in this case it only confirms the 
			gender value according to the last name or it sets a scoring flag <code>Estimated Gender</code> - a string indicating
			the estimated result. However, the original value is retained and stored in the output <code>In Gender</code>
			(but a replacement in this	situation can be forced using the the property <code>Overwrite If Guess</code>).<br/>
			The same situation occurs (with the same result) when determination of the gender value is not definite, however
			one of the components suggests what the probable gender value is  (i.e., only one of the components satisfies
			the threshold in the appropriate dictionary).
			<br/>
      <br/>
			Because the step uses dictionaries with exact forms of first names and last names, input first name and
			last name need to be cleansed and identified beforehand (e.g. using the Guess Name Surname step).<br/>
			Comparision of the determined and input gender value is case-insensitive.
			
			<p align="justify">The following table shows scoring flags set by the step for combinations of different input values.
	           <ul>
	               <li>
					If no input gender value is specified, the step has no data to compare the result against, instead the values
	                   from &quot;F&quot; and &quot;M&quot; rows and columns (blue) are used.
	               </li>
	               <li>
			           If an input gender value is provided, the columns <code>input gender value differs</code> 
			           and <code>input gender value equals</code> (green) are used.
			       </li>
			       <li>
			           The rest of table values (black on gray) are not dependent on the input gender value, i.e. they are the same for both cases.
                   </li>
                   <li>
					Scoring flags conform to the <code>overwriteIfGuess=false</code> status. If this property is set to
					<code>true</code>, the scoring flag <code>CHANGED</code> applies (instead of <code>CHANGE_SUGGESTION</code>).
	               </li>
                </ul>
				<br/>
        <br/>
					<table border="1">
						<th>
							<th rowspan="2">Last name</th>
							<th colspan="7">First name</th>
						</th>
						<th>
							<th>Not provided</th>
						   <th>Not found</th>
						   <th>Not conclusive</th>
						   <th>F (female)</th>
						   <th>M (male)</th>
						   <th>Input gender value differs</th>
						   <th>Input gender value equals</th>
						</th>
						<tr>
							<th>Not provided</th>
							<td>UNDECIDABLE</td>
							<td>UNDECIDABLE<br/>NAME_UNKNOWN</td>
							<td>UNDECIDABLE</td>
							<td>CHANGE_SUGGESTION</td>
							<td>CHANGE_SUGGESTION</td>
							<td>CHANGE_SUGGESTION</td>
							<td>CONFIRMED</td>
						</tr>
						<tr>
							<th>Not found</th>
							<td>UNDECIDABLE<br/>SURNAME_UNKNOWN</td>
							<td>UNDECIDABLE<br/>NAME_UNKNOWN<br/>SURNAME_UNKNOWN</td>
							<td>UNDECIDABLE<br/>SURNAME_UNKNOWN</td>
							<td>CHANGE_SUGGESTION<br/>SURNAME_UNKNOWN</td>
							<td>CHANGE_SUGGESTION<br/>SURNAME_UNKNOWN</td>
							<td>CHANGE_SUGGESTION<br/>SURNAME_UNKNOWN</td>
							<td>CONFIRMED<br/>SURNAME_UNKNOWN</td>
						</tr>
						<tr>
							<th>Not conclusive</th>
							<td>UNDECIDABLE</td>
							<td>UNDECIDABLE<br/>NAME_UNKNOWN</td>
							<td>UNDECIDABLE</td>
							<td>CHANGE_SUGGESTION</td>
							<td>CHANGE_SUGGESTION</td>
							<td>CHANGE_SUGGESTION</td>
							<td>CONFIRMED</td>
						</tr>
						<tr>
							<th>F(female)</th>
							<td>CHANGE_SUGGESTION</td>
							<td>CHANGE_SUGGESTION<br/>NAME_UNKNOWN</td>
							<td>CHANGE_SUGGESTION</td>
							<td>CHANGED</td>
							<td>MISMATCH</td>
							<td/>
							<td/>
						</tr>
						<tr>
							<th>M(male)</th>
							<td>CHANGE_SUGGESTION</td>
							<td>CHANGE_SUGGESTION<br/>NAME_UNKNOWN</td>
							<td>CHANGE_SUGGESTION</td>
							<td>MISMATCH</td>
							<td>CHANGED</td>
							<td/>
							<td/>
						</tr>
						<tr>
							<th>Input gender value opposite</th>
							<td>CHANGE_SUGGESTION</td>
							<td>CHANGE_SUGGESTION<br/>NAME_UNKNOWN</td>
							<td>CHANGE_SUGGESTION</td>
							<td/>
							<td/>
							<td>CHANGED</td>
							<td>MISMATCH</td>
						</tr>
						<tr>
							<th>Input gender value equals</th>
							<td>CONFIRMED</td>
							<td>CONFIRMED<br/>NAME_UNKNOWN</td>
							<td>CONFIRMED</td>
							<td/>
							<td/>
							<td>MISMATCH</td>
							<td>CONFIRMED</td>
						</tr>
					</table>
				</p>
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="changeGenderCase" type="boolean" required="true">
				If set to <code>true</code> and if the scoring flag &quot;CONFIRMED&quot; occurs, the output gender value
				is transformed to upper case. In other cases it is stored in lower case form. If this property
				is set to <code>false</code>, the format is copied from <code>Male Definition</code>,
				<code>Female Definition</code> or input. The setting of this property has no influence on the
				comparision process of the input gender value with <code>Male Definition</code> and
				<code>Female Definition</code> - this comparision is always case insensitive.<br/>
				Default value: <code>False</code>.
			</property>
			<property name="estimatedGender" type="string" required="true">
				Column that stores assumed (estimated) gender value if applicable (e.g., in case of a single component
				(last name) based determination or in the case that determination of the gender value is not definite). At the
				same time, the scoring flag <code>CHANGE_SUGGESTION</code> is set. The value in <code>In Gender</code>
				is retained. This functionality can be suppressed using the <code>Overwrite If Guess</code> property.
			</property>
			<property name="femaleDefinition" type="string" required="true">
				A string value defining identification of the female gender. This value is expected in the input
				and also stored in the output.
				<br/>
				Default value: <code>F</code>.
			</property>
			<property name="firstNameRatioLookupFileName" type="string" required="false">
				Dictionary file that contains first names and their
				representative ratio within men and women. The definition of this dictionary is mandatory
				when the property <code>In Name</code> is defined.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="inGender" type="string" required="true">
				Column that contains the input gender value and stores the final output gender value.
			</property>
			<property name="inName" type="string" required="false">
				Column that contains the input first name.
			</property>
			<property name="inSurname" type="string" required="true">
				Column that contains the input last name.
			</property>
			<property name="maleDefinition" type="string" required="true">
				A string value defining identification of the male gender. This value is expected in the input
				and also stored in the output.
				<br/>
				Default value: <code>M</code>.
			</property>
			<property name="minSurnameLength" type="integer" required="true">
				Minimum allowed length of the last name. If the input last name does not meet this criteria, it is
				considered to be empty.
				<br/>
				Default value: <code>3</code>.
			</property>
			<property name="nameSurenessLevel" type="integer" required="true">
				Integral value (threshold) in which the first name must be represented within men or women, respectively,
				to be considered as conclusive. The value range 51-100 is accepted.
				<br/>
				Default value: <code>51</code>.
			</property>
			<property name="overwriteIfGuess" type="boolean" required="true">
				If set to <code>true</code> this property, instead of setting scoring flag &quot;CHANGE_SUGGESTION&quot;, stores
				the value directly in the output <code>In Gender</code> and changes the scoring flag to &quot;CHANGED&quot;.<br/>
				Default value: <code>False</code>.
			</property>
			<property name="surnameRatioLookupFileName" type="string" required="true">
				Dictionary file that contains last names and their
				representative ratio within men and women.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="surnameSurenessLevel" type="integer" required="true">
				Integral value (threshold) in which the last name must be represented within men or women, respectively,
				to be considered as conclusive. The value range 51-100 is accepted.
				<br/>
				Default value: <code>51</code>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="UG_CONFIRMED">
				A scoring flag indicating that the step verified and assessed the input gender value as correct, the
				value determined from first name and/or last name equals to the input value.
				The input value is stored in the output.
			</scoringKey>
			<scoringKey name="UG_CHANGED">
				A scoring flag indicating that the gender value was changed. The determination process based on
				both first and last name returns the value opposite of what is in the input, and the determined value
				is stored in the output.
			</scoringKey>
			<scoringKey name="UG_MISMATCH">
				A scoring flag indicating that the value determined from the first name does not equal the one determined
				from the last name. The input value is stored in the output.
			</scoringKey>
			<scoringKey name="UG_UNDECIDABLE">
				A scoring flag indicating that it is not possible to determine what the gender value is using the given
				first and last name.
				The input value is stored in the output.
			</scoringKey>
			<scoringKey name="UG_CHANGE_SUGGESTION">
				A scoring flag indicating that the step assessed the input gender value as incorrect, but does not have enough
				information to determine the final value based on both first and last name (i.e. only one of the components
				satisfies the threshold in the appropriate dictionary). At the same time, the estimated (probable) value
				is stored in the <code>Estimated Gender</code> property and the input value is stored in the output.
			</scoringKey>
			<scoringKey name="UG_GENDER_MISMATCH">
				A scoring flag indicating that the gender data contains an unknown value.
			</scoringKey>
			<scoringKey name="UG_NAME_UNKNOWN">
				A scoring flag indicating that the input first name is provided but not found in
				the dictionary or the ratio found in the dictionary is invalid.
			</scoringKey>
			<scoringKey name="UG_SURNAME_UNKNOWN">
				A scoring flag indicating that the input last name is provided but not found in
				the dictionary or the ratio found in the dictionary is invalid.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.web.UrlMapping">
    <introduction>Maps filter to a specific path within the context.</introduction>
    <description>Maps filter to a specific path within the context.</description>
    <properties>
			<property name="listeners" type="string" required="false">Maps filters to the specified listeners.</property>
			<property name="tests" type="com.ataccama.dqc.web.IMappingTest[]" required="false">Filter is applied only if specofic test is passed.</property> 
			<property name="urlPattern" type="string" required="false">Maps filters to the specified URLs. <strong>Url Pattern</strong> must be prefix of the URL request.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.base.IUrlResourceConfig">
    <properties/>
  </class>
  <class name="com.ataccama.dqc.tasks.common.config.UserMetadata">
    <description>
			User defined metadata definition.
		</description>
    <properties>
			<property name="classification" type="string" required="false">
				Data classification.
			</property>
			<property name="dataOrigin" type="string" required="false">
				Origin of data.
			</property>
			<property name="description" type="string" required="false">
				Data description.
			</property>
			<property name="items" type="com.ataccama.dqc.tasks.common.config.UserMetadata$Item[]" required="false">
				Element aggregating the individual meta data item definitions.
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.bank.account.ValidateBankAccountNumberCZ">
    <introduction>Validates Czech bank account number.</introduction>
    <description>
	          This step validates input column data as a bank account number used in the Czech republic (and Slovakia).
	          Numbers in this format consist of three parts: prefix, base and bank ID. 
	          The step first trashes characters in the input that cannot occur in the bank number and saves them
	          to the <code>trashed</code> output. Then, it tries to determine the <code>bankId</code>, 
	          <code>base</code> and <code>prefix</code> parts of the account
	          number. According to the bank account format specification, the <code>prefix</code> and 
	          <code>base</code> must pass the mod11 test to be considered as valid. The step also 
	          supports output data formatting as specified by the property <code>Output Format</code> 
	          and configurable invalid data handling as defined in the invalid data handling configuration 
	          properties. See the description of each property for more details.
	          If the output is not processed by invalid data handling routines, the output format
	          determines what will be written out: 
	          <ul>
	               <li>
	                    If there is an <code>Output Format</code> defined, it is used to format the parsed data 
	                    and the formatted data are written out. If the corresponding part of the <code>Output Format</code> 
	                    could not be determined, the empty string value is used instead. 
	               </li>
	               <li>
	                    If no <code>Output Format</code> is defined, the original value is written to the 
	                    output. 
	               </li>
	          </ul>
	          If the <code>bankIdOut</code> output that has no relevant input:
	          <ul>
	          	<li>the empty value is written out if <code>bank id</code> was not recognized</li>
	          	<li>the standardized <code>bank id</code> is written out if it was recognized</li>
	          </ul>
	     </description>
    <properties>
     		 <property name="id" type="string" required="false">
			Step identification string.
			</property>
	     	<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
	        <property name="inBankAccount" type="string" required="true">
	          The input column with account number data.
	        </property>
	        
	        <property name="outBankAccount" type="string" required="true">
	          Where the result should be stored.
	        </property>
	        
	        <property name="trash" type="string" required="false">
	          The output contains characters (letters) removed from the account number before the start 
	          of processing.
	        </property>	        

	        <property name="outBankId" type="string" required="false">
	          If recognized, this output will contain the bank ID number in standardized form, which is
	          a 4-digit bank ID number filled with zeroes from the left if needed. This output value
	          does not depend on the validation of the found <code>bank id</code> in the lookup file.
	        </property>
	        	        
	        <property name="bankIdLookupFileName" type="string" required="false">
	          Lookup to use for validation of the determined <code>bank id</code>. 
	          It is a simple string lookup containing single values representing the <code>bank id</code>.
	          For more information see the <strong>detailed description</strong>.
	        </property>

	        <property name="outputFormat" type="string" required="false">
	          The format to be used for formatting the output. There are 3 predefined constants 
	          representing the parts of the account number: <code>{PREFIX}</code>, <code>{BASE}</code> 
	          and <code>{BANKID}</code>. If filling with zeroes to the maximum length of the component 
	          is required, it is possible to use the constants <code>{0PREFIX}</code> and <code>{0BASE}</code>. 
	          <code>{BANKID}</code> always means the <code>bank id</code> standardized to the 
	          4-digit length, so a related &#39;zeroed&#39; constant is not defined.<br/>
	          Examples for the input <code>00123-000456-234</code>:
	          <ul>
	               <li>
            <code>{PREFIX}-{BASE}/{BANKID}</code> - outputs <code>123-456/0234</code>
          </li>
	               <li>
            <code>{0PREFIX}-{0BASE}/{BANKID}</code> - outputs 
	               <code>000123-0000000456/0234</code>
          </li>
	          </ul>
	          Note that using special characters inside the component name will make it a &#39;static text&#39; 
	          component: for example <code>{:PREFIX}</code> will be represented as string &quot;{:PREFIX}&quot; 
	          instead of identifying the <code>prefix</code> part of the number. 
	        </property>
	        	                	     
	        <property name="invalidDataDefinitions" type="com.ataccama.dqc.tasks.clean.bank.account.ValidateBankAccountNumberCZ$InvalidDataDefinitions" required="true">
	        	A collecting tag for invalid data definitions processed by this step.
	        </property>
	        	                	     
	     <property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
	        <scoringKey name="BAN_BASE_FORMAT_INVALID">
	          Invalid size of the base component.
	        </scoringKey>
	        <scoringKey name="BAN_PREFIX_FORMAT_INVALID">
	          Invalid size of the prefix component.
	        </scoringKey>
	        <scoringKey name="BAN_BASE_MOD_FAILED">
	          The base part does not meet the mod11 constraint.
	        </scoringKey>
	        <scoringKey name="BAN_NULL">
	          There are no data in the input.
	        </scoringKey>
	        <scoringKey name="BAN_FORMAT_INVALID">
	          Too many components recognized or an incompatible number of digits.
	        </scoringKey>
	        <scoringKey name="BAN_BANKID_FORMAT_INVALID">
	          Invalid size of the bank ID component.
	        </scoringKey>
	        <scoringKey name="BAN_PREFIX_MOD_FAILED">
	          Prefix does not meet mod11 constraint.
	        </scoringKey>
	        <scoringKey name="BAN_BANKID_FIXED">
	          The bank ID was padded with zeroes to the 4-digit length.
	        </scoringKey>
	        <scoringKey name="BAN_BANKID_UNKNOWN">
	          The bank ID was not found in the bank ID lookup file.
	        </scoringKey>
	        <scoringKey name="BAN_PREFIXBASE_FORMAT_GUESSED">
	          The prefix and base were merged in the input but it was possible to guess
	          them.
	        </scoringKey>
	        <scoringKey name="BAN_AMBIGUOUS">
	          The prefix and base were merged in the input (relevant component size is larger than 10 digits).
	        </scoringKey>                                                                        
	     </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ua.ValidateBirthNumberUA">
    <introduction>Validates Ukrainian birth number (tax code).</introduction>
    <description>
            This step validates birth numbers used in Ukraine. For now, the number is tested to comply
            with the following constraints:
            <ul>
                <li>The number&#39;s date part must comply with the given date hint (only when the hint is 
                      present)</li>
                <li>The number&#39;s gender identification must comply with the gender hint (only when 
                      the hint is present)</li>
                <li>The number format must comply with the following rules:
                    <ul>
                        <li>The date part must contain at least one non-zero digit</li>
                        <li>The number after normalization must be at maximum 10 digits long.
                              Normalization means that the number is converted to the 10-digit form by
                              filling missing zeroes from the left or stripping redundant zeroes 
                              from the left</li>
                    </ul>
                </li>
            </ul>
            <p align="justify">
            This step also generates a fake birth number when the output fake binding property is set and 
            sufficient info to generate the number is present (the gender hint and date hint 
            are both connected and filled with valid values). The generated fake number consists of the date 
            part relevant to the given date hint, the gender part relevant to the given gender and the 
            &#39;filling&#39; character defined by the property <code>Fake Substitute Character</code>.
            </p>
            <p align="justify">
            The format of the generated fake number is the following:<br/> 
                <code>00000XXXGX</code>
        <br/>
            where <br/>
            <ul>
                <li>
            <code>0</code> - the date part related to the given date hint (the number of days since 1.1.1900)</li>
                <li>
            <code>X</code> - the value defined by the <code>Fake Substitute Character</code> property</li>
                <li>
            <code>G</code> - the gender value: 1 for male, 2 for female - related to the given gender hint</li>
            </ul>
            </p>
            <p align="justify">
                Note that generated fake numbers are not valid, since it is not possible to 
                calculate the valid control digit at present and therefore make the generated number valid 
                (fulfilling the Ukrainian rule for the control digit). Also the &#39;filling&#39; character
                may have a non-numerical value and therefore break the &#39;numerical-digits-only&#39; constraint.
            </p>
         </description>
    <properties>
            <property name="birthDate" type="string" required="false">
                Expression defining the <code>DAY</code> value to be taken as the date hint.
            </property>
            <property name="birthDateOut" type="string" required="false">
                Name of the <code>DAY</code> type output where the birth date read from the birth 
                number should be written to.<br/>
            </property>
            <property name="birthNumber" type="string" required="true">
                Expression defining the <code>STRING</code> value to be taken as the birth number.
            </property>
            <property name="birthNumberOut" type="string" required="true">
                Name of the <code>STRING</code> type output where the number validation result 
                should be written to.<br/>
            </property>
            <property name="gender" type="string" required="false">
                Expression defining the <code>STRING</code> value to be taken as the gender hint.
            </property>
            <property name="genderOut" type="string" required="false">
                Name of the <code>STRING</code> output where the gender read from the birth number 
                should be written to.
            </property>
            <property name="trash" type="string" required="false">
                Name of the <code>STRING</code> type output where the characters from the birth 
                number trashed during validation should be written to.
            </property>
            <property name="fakeBirthNumberOut" type="string" required="false">
                <code>STRING</code> type output where the generated fake number should be written to. 
                A fake number is generated only when this property is set and there are valid 
                gender and date hints in the input.
            </property>
            <property name="fakeSubstituteCharacter" type="string" required="false">
                Defines the character that will be used as the substitution character in the generated 
                fake number. The default value is &#39;<code>0</code>&#39;. This value is required if the 
                fake number should be generated (i.e., when <code>Fake Birth Number Out</code> is 
                connected).
            </property>
            <property name="femaleDefinition" type="string" required="false">
                Defines how the female gender is encoded in the <code>Gender</code> / 
                <code>Gender Out</code> input/output
            </property>
            <property name="maleDefinition" type="string" required="false">
                Defines how the male gender definition is encoded in the <code>Gender</code> /
                <code>Gender Out</code> input/output
            </property>
            <property name="invalidDataDefinitions" type="com.ataccama.dqc.tasks.clean.ua.ValidateBirthNumberUA$InvalidDataDefinitions" required="true">
                Collector tag for invalid data definitions
            </property>
            <property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
         <property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
            <scoringKey name="BN_UA_BN_NULL">
                The input birth number is empty.
            </scoringKey>
            <scoringKey name="BN_UA_DATE_HINT_NULL">
                The input date hint is empty.
            </scoringKey>
            <scoringKey name="BN_UA_DATE_MISMATCH">
                The input date hint does not match with the value read from the number.
            </scoringKey>
            <scoringKey name="BN_UA_FAKE_GENERATED">
                Indicates that a fake number was generated in the <code>Fake Birth Number Out</code> output.
            </scoringKey>
            <scoringKey name="BN_UA_FAKE_NOT_GENERATED">
                Indicates that a fake number was not generated. This flag is set only when fake numbers
                are to be generated. This means that it is set only if 
                <code>Fake Birth Number Out</code> is set and it is unable to generate a fake number.
            </scoringKey>
            <scoringKey name="BN_UA_FORMAT_INVALID">
                Indicates an invalid format of the input birth number (invalid date part, invalid length).
            </scoringKey>
            <scoringKey name="BN_UA_GNDR_HINT_INVALID">
                Indicates that the gender hint is invalid (it does not match either the  
                <code>Female Definition</code> or the <code>Male Definition</code> value).
            </scoringKey>
            <scoringKey name="BN_UA_GNDR_HINT_NULL">
                Indicates that the gender hint is empty.
            </scoringKey>
            <scoringKey name="BN_UA_GNDR_MISMATCH">
                Indicates that the input gender hint and gender read from the birth number do not match.
            </scoringKey>
         </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidateVatIdAlgorithm">
    <introduction>Validates Czech VAT IDs (DIČ).</introduction>
    <description>
			This step recognizes new and old VAT ID (DIČ) values. The step also cleans incorrect characters within the VAT ID,
			 verifies checksum (if possible) and VAT ID against a dictionary file containing registered tax offices.
			Using the <code>preserveInputValue</code> property, the final output value can be selected (original or
			cleansed). NOTE: VAT ID = DIČ.
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="cnLookupFileName" type="string" required="true">
				Dictionary file with list of companies.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="convertOldVid" type="boolean" required="true">
				Specifies whether VAT ID number with the format valid before 2004/05/01 should be converted to
				the format valid after 2004/05/01.<br/>
				Default value: <code>False</code>
			</property>
			<property name="foLookupFileName" type="string" required="true">
				Dictionary file with a list of tax offices.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="in" type="string" required="true">
				Column that contains the input VAT ID value.
			</property>
			<property name="outCode" type="string" required="false">
				Column that stores company (Register of Economic Subjects) code if successfully verified.
				Acceptable codes are IC (company identification number), RC (birth number) or any other
				number which can play role of code within a VAT ID (e.g. the number of the company&#39;s cash register).
				Applies to old VAT ID values only.
			</property>
			<property name="outFinOff" type="string" required="false">
				Column that stores the tax office code for possible VAT ID verification.
				Applies to old VAT ID values only.
			</property>
			<property name="outVid" type="string" required="false">
				Column that stores the output VAT ID value.
			</property>
			<property name="preserveInputValue" type="boolean" required="true">
				Specifies whether the original(<code>true</code>) or the cleansed(<code>false</code>) value is stored
				in the output (when cleansing is performed)<br/>
				Default value: <code>False</code>.<br/>
			</property>
			<property name="treatOldVidAsInvalid" type="boolean" required="true">
				Specifies whether a VAT ID number given the format valid before 2004/05/01 should be considered as invalid.<br/>
				Default value: <code>False</code>
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="VID_NULL">
				A scoring flag indicating that the input VAT ID is missing.
			</scoringKey>
			<scoringKey name="VID_FIN_OFFICE">
				A scoring flag indicating that the VAT ID contains an unknown tax office code.
			</scoringKey>
			<scoringKey name="VID_FORMAT">
				A scoring flag indicating that the provided VAT ID has a bad format.
			</scoringKey>
			<scoringKey name="VID_COMPANY">
				A scoring flag indicating that IC was recognized within the VAT ID
				but the IC is unknown.
			</scoringKey>
			<scoringKey name="VID_IC_CHECK">
				A scoring flag indicating that the IC number has a bad checksum. Applies if the company is a corporation.
			</scoringKey>
			<scoringKey name="VID_BN_CHECK">
				A scoring flag indicating that the RC number has a bad checksum. Applies if the company is an individual.
			</scoringKey>
			<scoringKey name="VID_BN_DATE">
				A scoring flag indicating that birth date is incorrect in relation to the length of the RC.
				Applies if the company is an individual
			</scoringKey>
			<scoringKey name="VID_OLD">
				A scoring flag indicating that the VAT ID has a format valid until 2004/05/01.
			</scoringKey>
			<scoringKey name="VID_FO_DIFF">
				A scoring flag indicating that the code of tax office contained in the VAT ID does not
				conform to the local authority code at the beginning of the VAT ID.
				Applies only to old VAT IDs (before 2004/05/01) and particular company codes.
			</scoringKey>
			<scoringKey name="VID_CLEANED">
				A scoring flag indicating that the VAT ID was transformed/cleansed within the verification process.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidateEmailAlgorithm">
    <introduction>Validates e-mail addresses.</introduction>
    <description>
			This step checks the validity of an e-mail address according to a valid e-mail address format.
			The step supports verification of the top level domain (TLD). The TLD can contain characters
			and numbers and must start with a character. Lower level domains respect letter digit hyphen (LDH) syntax 
			and can start with a number. A hyphen is allowed within the domain portion only.
			If an error is detected (<code>EML_ADDRESS</code>, <code>EML_TLD</code> or <code>EML_NULL</code>),
			an empty value is stored in both outputs <code>Out Name</code> and <code>Out Email</code>.
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="in" type="string" required="true">
				Column that contains the input e-mail.
			</property>
			<property name="outName" type="string" required="false">
				Column that stores the output owner of the e-mail. Note: This value is NOT equal to
				the name of the mailbox on front of the at (@) mark. E.g. Support [customer_support@ataccama.com], Out Name is Support.
			</property>
			<property name="outEmail" type="string" required="false">
				Column that stores the output e-mail address (username@domain).
			</property>
			<property name="tldLookupFileName" type="string" required="true">
				Dictionary file that contains valid top level domains (TLD).
				For more information about the dictionary see <strong>the detailed description here</strong>.  
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="EML_NULL">
				A scoring flag indicating that no e-mail data in the input is provided.
			</scoringKey>
			<scoringKey name="EML_ADDRESS">
				A scoring flag indicating that the input e-mail address has an invalid format.
			</scoringKey>
			<scoringKey name="EML_TLD">
				A scoring flag indicating that the top level domain name is incorrect - unknown in consideration of the dictionary, but valid regarding
				its syntax (otherwise &quot;EML_ADDRESS&quot; is set).
			</scoringKey>
			<scoringKey name="EML_AMBIGUOUS_DOMAIN">
				A scoring flag indicating that the input e-mail contains one TLD only (corresponding with the RFC 2822 standard),
				however the domain is considered suspicious.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidateICAlgorithm">
    <introduction>Validates Czech identification number for legal persons.</introduction>
    <description>
				Tests the input string as an ICO (Czech identification number for legal persons) and verifies its validity.
				Only valid ICO values are stored in the output column &quot;out&quot;. If the ICO value
				is invalid then a scoring flag indicating an error in the ICO value is set and an empty
				value is written to the output. The property <code>Allow Cleaning</code> allows execution
				of ICO cleansing before the validation. The property <code>Preserve Input Value</code> determines
				whether the original or cleansed ICO value is written to the output (after successful validation).
		</description>
    <properties>
			<property name="allowCleaning" type="boolean" required="true">
			Flag which specifies whether special characters (other than letters and digits)
			can be removed in verificiation. <br/>
			Default value: <code>True</code>.
			</property>
			<property name="in" type="string" required="true">
			Column that contains ICO values.
			</property>
			<property name="omitInvalidIC" type="boolean" required="true">
			Flag which specifies whether a null value (flag set to <code>true</code>) is written to the output column &quot;out&quot; in case
			any of the scoring flags IC_NULL, IC_BAD_FORMAT or IC_BAD_CHECKSUM is set.
			If flag is set to <code>false</code> then the property <code>preserveInputValue</code>
			influences the output.
			<!--<link id="ValidationOutputSettings">výstupy validačních algoritmů</link>. -->
			I.e. if the input value is valid then either the original (not cleansed value)
			or the cleansed and corrected (appended by 0) value is written to the output.
			</property>
			<property name="out" type="string" required="true">
			Column that stores valid output ICO values.
			</property>
			<property name="preserveInputValue" type="boolean" required="true">
			Flag which determines whether the original input value (flag set to <code>true</code>)
			or the cleansed value (flag set to <code>false</code>) should be written to the the output column &quot;out&quot;.
			The flag is ignored if <code>allowCleaning = false</code>.<br/>
			Default value: <code>False</code>
            <!--<link id="ValidationOutputSettings">výstupy validačních algoritmů</link>. -->
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="IC_NULL">
				A scoring flag indicating that the input ICO value is null.
			</scoringKey>
			<scoringKey name="IC_BAD_FORMAT">
				A scoring flag indicating that the format of the input ICO value is invalid (e.g. incorrect length or invalid characters).
			</scoringKey>
			<scoringKey name="IC_BAD_CHECKSUM">
				A scoring flag indicating that the the check sum is incorrect.
			</scoringKey>
			<scoringKey name="IC_CLEANED">
				A scoring flag indicating that a special character was removed.
				(Removal is possible only if the property <code>Allow Cleaning</code> is set to <code>true</code>.)
			</scoringKey>
			<scoringKey name="IC_NORMALIZED">
				A scoring flag indicating that one or more &#39;0&#39; characters are appended at the beginning of the ICO value to correct the format.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidateIdCardAlgorithm">
    <introduction>Validates the format of a card number.</introduction>
    <description>
		This step checks validity of a card number specified in the <code>Cn</code> data input. In case the card
		number satisfies the conditions of validity, the input card number will be copied
		to the data output <code>Cn Out</code>. If the card number fails to satisfy some of the conditions,
		the corresponding error flags will be set (see description of the flags) and the output will contain an 
		empty value. Recording of an invalid number to the output can be enforced by
		the parameter <code>Omit Invalid ID Card</code> and setting its value to <code>false</code>.<br/>
		Validation procedure: first, the characters &#39;0&#39; are removed from the beginning
		of card number (from the left).  The remaining number has to satisfy the following conditions
		of validity (to be recognized as valid):
		<ul>
					<li>number length has to be 8 – 19 characters (inclusive)</li>
					<li>number does not contain non-digit characters</li>
					<li>check digit in the last position is valid</li>
					<li>contains at least one nonzero digit in the positions 2-6 
					(this position identifies card issuers)</li>
		</ul>
		<br/>
		The last digit of the card number is a check digit. The algorithm used to validate the 
		check digit is called the Luhn algorithm. When validated, the number
		may be padded with zeroes from the left without affecting the check digit value.
		<br/>
		This step outputs standardized number formats, i. e. without added initial zeros.
		</description>
    <properties>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="cn" type="string" required="true">
			Column that contains the input card number.
			</property>
			<property name="cnOut" type="string" required="true">
			Column that contains the output card number.
			</property>
			<property name="omitInvalidIC" type="boolean" required="true">Property that
			specifies whether the output value of the card number is shown in case of an error
			(for further details see the detailed description and appropriate scoring keys):
			<code>true</code> - NULL value is written; <code>false</code> - the input (original) value is written.<br/>
			Default value: <code>True</code>.
		</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="VIC_NULL">A scoring flag indicating that the input is empty.
			</scoringKey>
			<scoringKey name="VIC_BAD_FORMAT">A scoring flag indicating that the card
			number has incorrect length after removing zeroes from input values (step accepts
			length from 8 to 19 characters).
			</scoringKey>
			<scoringKey name="VIC_INVALID">A scoring flag indicating that the card number
			contains incorrect characters (non-digit characters).
			</scoringKey>
			<scoringKey name="VIC_INVALID_CHECK">A scoring flag indicating that the card
			number does not correspond to the check digit on the last position.
			</scoringKey>
			<scoringKey name="VIC_EMPTY_ISSUER">A scoring flag indicating that there are zeroes in the 
			issuer identifier positions (positions 2-6).
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidateInResAlgorithm">
    <introduction>Validates legal persons ID and name against reference data.</introduction>
    <description>
			Tests the existence of the the input IČO (property <code>ico</code>) in the Czech Register of Economic Subjects (RES) by obtaining
			the business name. The obtained business name is compared with the input business name (property <code>businessName</code>).
			The obtained name is stored in the property <code>realNameOut</code> if this property is defined. A dictionary file
			which contains all economic subjects is defined by the property <code>databaseFile</code>(for a detailed
			description of the dictionary file see the section <strong>Files - Register of Economic Subjects</strong>.<br/>
			If the input IČO is not filled in, then [branding:product.name.abbreviation] reports an error and the step ends. If the input IČO is filled in, then the step reads the input
			business name and compares it to the business name found in the dictionary file by the IČO value. Matching values of 
			both the input and dictionary file names are compared. Rules for creating matching bussines name
			are defined by the <code>matchingValueGeneratorConfig</code> property.
			If the values differ, then the scoring flag <code>IC_EXT_NOT_FOUND</code> is set. If there is no record matching the input IČO
			value in the dictionary file, then the scoring flag <code>IC_EXT_NOT_FOUND</code> is set.
			<br/>
			For best matching of company names, the step <strong>Transform Legal Forms</strong> should be applied
			to this name (stored into file in first column) and the same transformation must be applied before this step. 
		</description>
    <properties>
	      	<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="businessName" type="string" required="false">
				Column that contains the input business name.
			</property>
			<property name="databaseFile" type="string" required="true">
				String that contains the name of the file keeping the lookup table of the records IČO - business name - other info (RES).
			</property>
			<property name="ico" type="string" required="true">
				Column that contains the input IČO.
			</property>
			<property name="matchingNameGeneratorConfig" type="com.ataccama.dqc.tasks.common.util.matching.MatchingValueGeneratorConfig" required="true">
				Configuration of the matching generator which creates values from input values and the dictionary that can
				match each other.
			</property>
			<property name="realNameOut" type="string" required="false">
				Column that stores the output business name.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="IC_EXT_NULL">
				A scoring key indicating that the input IČO value is <code>null</code>.
			</scoringKey>
			<scoringKey name="IC_EXT_NOT_FOUND">
				A scoring key indicating that corresponding IČO value was not found in the dictionary file.
			</scoringKey>
			<scoringKey name="IC_EXT_NAME_MISMATCH">
				A scoring key indicating that input business name does not correspond to the business name found in the dictionary file.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidatePhoneNumberAlgorithm">
    <introduction>Parses and validates phone numbers.</introduction>
    <description>
			This step verifies the validity of a phone number. The phone number format is specified using parsing rules.
			For more accurate verification, a dictionary of international area codes is used.
			(IDC - International Destination Code -	the dictionary specified in <code>Idc Lookup File Name</code>)
			Also, a dictionary of local providers (e.g., Czech Republic) can be used when specified using <code>Prov Lookup File Name</code>).
			<br/>
			This step uses a parser to examine the input string. For more details about
			it please see the description of <strong>Pattern Parser</strong>.
			<br/>
			This step is capable of processing more phone extension numbers
			so that these are grouped together and separated by the given character
			(the <code>Ext Separator</code> parameter).
			<br/>
			Besides standard components there are the following predefined ones available.
			These components are verified against corresponding dictionaries.<br/>
			<ul>
				<li>
          <code>PHONE</code> - phone number: 9 digit number with a space as possible separator, i.e. <code>{NUMBER:acceptSeparators=true,separatorChar=&#39; &#39;,minLength=9,maxLength=9}</code>.</li>
				<li>
          <code>EXT</code> - phone extension: at most 3 digit number, i.e. <code>{NUMBER:minLength=1,maxLength=3}</code>.</li>
				<li>
          <code>PROV</code> - number present in the dictionary of providers given by <code>Prov Lookup File Name</code>.</li>
				<li>
          <code>IDC</code> - international destination code,
					a number starting with &#39;+&#39; or &#39;00&#39; and present in the dictionary of the codes given by <code>Idc Lookup File Name</code>.</li>
			</ul>
			In order to recognize components correctly, the number parts must be divided by a 
			separator. For example to recognize a number 
			with the pattern <code>{AREACODE}{PHONE8}</code> (where <code>{AREACODE}</code> is a  
			component consisting of 1 or 2 digits and <code>{PHONE8}</code>  is a component 
			consisting of 8 digits) the two parts of the number must be divided by separator, 
			for example, in the telephone number <code>&#39;12 12345678&#39;</code> where space is the 
			separator.
		</description>
    <properties>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="components" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.Component[]" required="false">
				Definition of user components.
			</property>
			<property name="fullTrashScope" type="boolean" required="true">
				Specifies whether text parsed by components which don&#39;t the define <code>Store Parsed Into</code> parameter is
				stored into the column defined by the binding <code>Trash</code>. Text not parsed by any component is stored in any case.
				This parameter has effect only if the binding <code>Trash</code> is defined.
				<br/>
				Default value: <code>False</code>.
			</property>
			<property name="extSeparator" type="string" required="false">
				A single character (only) used as a delimiter between
				two extension numbers in the <code>Out Ext</code> output binding.
				Default value: <code>,</code> (comma).
			</property>
			<property name="idcLookupFileName" type="string" required="true">
				Dictionary file with known IDCs.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="idcPrefix" type="string" required="false">
				A string used for conversion of an international area code into a uniform output format.
				Allowed values are &quot;+&quot; or &quot;00&quot;.<br/>
				Default value is an empty string.
			</property>
			<property name="in" type="string" required="true">
				Column that contains the input phone number.
			</property>
	     	<property name="invalidDataDefinitions" type="com.ataccama.dqc.tasks.clean.AbstractValidatePhoneNumberAlgorithm$InvalidDataDefinitions" required="true">
	     		Collector tag for invalid data definitions
	     	</property>	     				
			<property name="numberPartLength" type="integer" required="true">
				Length of a part of the phone number into which the number is split in the output format.<br/>
				Default value: 3.
			</property>
			<property name="numberSeparator" type="string" required="false">
				Separator used for phone number parsing in the output format.
			</property>
			<property name="outExt" type="string" required="false">
				Column that stores is identified extension-line.
			</property>
			<property name="outExtOrig" type="string" required="false">
				Column that stores is original extension-line.
			</property>
			<property name="outIdc" type="string" required="false">
				Column that stores is identified international area code.
			</property>
			<property name="outIdcOrig" type="string" required="false">
				Column that stores is original international area code.
			</property>
			<property name="outPhoneNumber" type="string" required="false">
				Column that stores is final standardized (output) phone number.
			</property>
			<property name="outPhoneNumberOrig" type="string" required="false">
				Column that stores is original phone number.
			</property>
			<property name="outProv" type="string" required="false">
				Column that stores is identified phone provider number.
			</property>
			<property name="outProvOrig" type="string" required="false">
				Column that stores is original phone provider number.
			</property>
			<property name="outRuleName" type="string" required="false">
				Column that stores is used parsing rule that best describes the input structure.
			</property>
			<property name="tokenizerConfig" type="com.ataccama.dqc.tasks.common.parse.ConfigurableTokenizerConfig" required="true">
				Definition of the tokenizer.
			</property>
			<property name="patternGroups" type="com.ataccama.dqc.tasks.common.abp.parser.configuration.PatternGroup[]" required="true">
				This section associates individual <code>PatternGroup</code> tags representing one specified group of patterns.
			</property>
			<property name="prefix" type="string" required="false">
				String attached to the beginning of the phone number in the output.<br/>
				Default value is an empty string.
			</property>
			<property name="provLookupFileName" type="string" required="true">
				Dictionary file with known phone providers.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="trash" type="string" required="false">
				Column that stores trash information. Trash information is the part
				of the input text which was not recognized
				as a known component or, when the <code>Full Trash Scope</code> flag is true,
				text parsed by the component not having its own output column <code>Store Parsed Into</code>.
				The binding is not required, thus the property <code>Full Trash Scope</code>
				is effective only when this binding is set.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
            <scoringKey name="PN_NO_PATTERN">
                A scoring flag indicating that no parsing pattern (parsing rule) conforming to the input value was found.
            </scoringKey>
            <scoringKey name="PN_PART_PATTERN">
                A scoring flag indicating that only part of a parsing pattern matched the input phone number.
                The flag is being set in situations when IDC or PROV are parsed
                but not verified against their dictionaries.
            </scoringKey>
            <scoringKey name="PN_MORE_PATTERNS">
                A scoring flag indicating that more than one parsing pattern matched the input phone number.
            </scoringKey>
            <scoringKey name="PN_IDC">
                A scoring flag indicating that part of the input number considered to be an IDC number does not correspond
                to any of known IDCs in the used dictionary.
            </scoringKey>
            <scoringKey name="PN_PROV">
                A scoring flag indicating that part of the input number considered to be an provider number does not correspond
                to any of known providers in the used dictionary.
            </scoringKey>
            <scoringKey name="PN_NULL">
                A scoring flag indicating that no phone number in the input is provided.
            </scoringKey>
            <scoringKey name="PN_TRASH">
                A scoring flag indicating that some text wasn&#39;t parsed or was parsed by a component having no
                special output in the case that <code>Full Trash Scope</code> is specified. This flag is set even if the binding <code>Trash</code>
                is not defined.
            </scoringKey>
        </scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidateRZAlgorithm">
    <introduction>Validates Czech vehicle registration number.</introduction>
    <description>
		Validates RZ (czech car registration number) and performs checks against:
		<ul>
			<li>car type (only for RZs where it is possible to determine the vehicle type from the RZ format)</li>
			<li>registration date (whether the form of the RZ complies with the era: since 2001 the new form 
				  of registration number is used)</li>
		</ul>
		This algorithm does not contain any internal cleaning mechanism  (removing invalid characters) - and expects 
		cleansed data on input. In this case, cleaning means removing special characters (pause, spaces, etc.). The only
		action performed by the algorithm is conversion of the input to the uppercase.
		<br/>
      <br/>
		This algorithm implements validation of the RZ forms as defined by the following czech laws:
		<ul>
			<li>vyhl. č. 243/2001 Sb.</li>
			<li>vyhl. č. 291/2004 Sb.</li>
		</ul>

		<strong>Recognized RZ types:</strong>
		<ul>
			<li>Standard RZ numbers<br/>
				  For standard RZ values, the following rules are applied:<br/>
				  <ul>
				  		<li>input&#39;s length must be from 5 to 7 characters</li>
				  		<li>characters are formed by Latin alphabets (<code>L</code>) capitals and Arabic digits (<code>D</code>)</li>
				  		<li>the first character must be a letter of the region (<code>R</code>)</li>
				  		<li>the next characters can be alphanumeric characters (<code>X</code>)</li>
				  		<li>the input must contain at least one letter (<code>L</code>) and one digit (<code>D</code>)</li>
				  </ul>
				  where:
				  <ul>
				  	  <li>
              <code>L</code> = {<code>ABCDEFHIJKLMNPRSTUVXYZ</code>}</li>
				      <li>
              <code>R</code> = {<code>ABCEHJKLMPSTUZ</code>}</li>
				      <li>
              <code>D</code> = {<code>0123456789</code>}</li>
				      <li>
              <code>X</code> = <code>L+D</code>
            </li>	
				  </ul>
				  <br/>	
			</li>
			
			<li>Exceptions to the standard format (special RZ types)<br/>
				The step recognizes vehicle registration numbers of the following types<br/>
				(Note: the quoted characters define specific letters in particular positions):
				<ul>
					<li>historical: <code>&#39;V&#39;DDDD</code> (old form), <code>DD&#39;V&#39;DDDD</code>, <code>DD&#39;V&#39;DDD</code>, <code>DD&#39;V&#39;DD</code> (new form)</li>
					<li>racing: <code>&#39;R&#39;DDDD</code> (old form), <code>DD&#39;R&#39;DDDD</code>, <code>DD&#39;R&#39;DDD</code> (new form)</li>
					<li>trial: <code>&#39;F&#39;DDDD</code>
            </li>
					<li>handling/operating: min 5 characters, max 6 characters: <code>RXXXX</code>, <code>RXXXXX</code>
            </li>
					<li>diplomatic 2001: <code>&#39;DD&#39;DDDDD</code>,<code>&#39;DD&#39;DDDD</code>,<code>&#39;DD&#39;DDD</code>, <code>&#39;XX&#39;DDDDD</code>, 
						  <code>&#39;XX&#39;DDDD</code>, <code>&#39;XX&#39;DDD</code>
            </li>
					<li>diplomatic 2004: <code>XXX*XX</code>, <code>XX*XX</code> - where <code>* = &#39;CD&#39;, &#39;XX&#39;, &#39;XS&#39;, &#39;HC&#39;</code>
            </li>
					<li>time limited: 7 characters, it begins with a region code + digits (<code>RDDDDDD</code>)</li>
				</ul>
				<br/>
			</li>
			
			<li>Old RZ formats (SPZ)<br/>
			  with the start of the new numbering system in 2001, the old SPZs were not discarded but are still valid (though no longer 
			  assigned). Therefore the algorithm also supports and recognizes the following formats of the old SPZs:
			  <ul>
			  	<li>
              <code>OODDDD</code>
            </li>
			  	<li>
              <code>OOLDDDD</code>
            </li>
			  	<li>
              <code>DDOODD</code>
            </li>
			  	<li>
              <code>DDOOLDD</code>
            </li>
			  </ul>
			  where:
			  <ul>
			  	<li>
              <code>O</code> = two letter code of the former czech districts:<br/>
      					{<code>BE,BI,BO,BK,BM,BS,BZ,BN,BV,CB,CE,CH,CK,CL,CR,CV,DC,DO,FI,FM,HB,HK,HR,HO,JE,JH,JI,JN,KA,KI,KD,KL,KH,KM,KO,KR,KV,KT,LB,LI,LN,LT,
      					MB,ME,MO,NA,NB,NJ,OC,OL,OM,OP,OS,OT,OV,PA,PU,PB,PC,PZ,PE,PH,PY,PI,PJ,PM,PN,PR,PS,PT,PV,RA,RK,RO,SM,SO,ST,SU,SY,TA,TC,TP,TR,TU,
      					UH,UL,US,UO,VS,VY,ZL,GT,ZN,ZR</code>}
			  	</li>
			  	<li>
			  		<code>L</code> = {<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>}
			  	</li>
			  	<li>
			  		<code>D</code> = {<code>0123456789</code>}
			  	</li>
			  </ul>
			  Algorithm accepts also combinations which probably were never assigned due to the vulgar or politically incorrect meaning 
			  (e.g. <code>PRC</code>, <code>PRD</code> or <code>STB</code> - see. <a href="http://www.feudal.cz/spz/html/1960-2002.htm" target="_blank">SPZ 1960-2001 info</a>).			
			</li>
		</ul>

		<p align="justify">
			<strong>RZ patterns</strong>
        <br/>
			As the extension to the formats desribed above, the algorithm allows to define custom RZ patterns : a set of patterns
			to be used first when validating the input. If the input value matches any of these patterns, it is considered valid
			and no further checks are performed. The output <code>Out Rz Type</code> is then set to the <code>CUSTOM_PATTERN</code>
			value. Custom patterns are processed as the first ones, so they override any other patterns used by the algorithm (e.g. 
			internal patterns used to determine special RZ forms as defined by law etc.).
			<br/>
			The primary reason of the rzPatterns is to provide a way how to accept inputs which wouldn&#39;t be normally accepted
			because they do not meet the other rules (e.g. some new exception to RZ in the future etc.).
			<br/>
        <br/>
			<strong>RZ patterns syntax</strong>
			<ul>		
			    <li>
            <code>N</code> - positive integral number {<code>123456789</code>}</li>
			    <li>
            <code>D</code> - integral number {<code>0123456789</code>}</li>
			    <li>
            <code>R</code> - letter of the region (see law from 2004): {<code>ABCEHJKLMPSTUZ</code>}</li>
			    <li>
            <code>A</code> - alphabet - the pack of allowed characters that can be used in RZ: {<code>ABCDEFHIJKLMNPRSTVXYZ</code>}</li>
			    <li>
            <code>L</code> - letter - {<code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code>}</li>
			    <li>
            <code>X</code> - alphanumeric value - any value <code>A</code> or <code>D</code>
          </li>
			</ul>
			The user&#39;s pattern can also contain the exact-character-rule enclosed in apostrophes such as <code>&#39;X&#39;</code>, 
			where <code>X</code> is any character.
		</p>
		
		<p align="justify">
			<strong>Description of the input processing</strong>
			<br/>
        <br/>
			<strong>First phase - validation against the new RZ forms:</strong>
        <br/>
			This phase consists of the following checks (in this order):
			<ul>
				<li>check user patterns</li>
			  	<li>check special forms of RZ as defined by law</li>
			  	<li>check common form of the RZ as defined by law</li>
			</ul> 
			No character fixing is performed in this phase, since the new RZ format is too generic. It is not possible to reliably recognize
			possible typos from the correctly spelled characters.
			<br/>
        <br/> 
			<strong>Second phase - validation against the old SPZ forms:</strong>
        <br/>
			This phase is run when:
			<ul>
			  	<li>input string does not pass any of the checks in the first phase</li>
			  	<li>xthe input string only complies to the too generic checks of the first phase so there&#39;s possible ambiguity
			     (e.g. new RZ &quot;manipulative&quot; vs. old SPZ form).</li>
			</ul>
			The part of the checks in this phase is also an attempt to fix incorrectly spelled characters. The fixing operation can be performed
			here since the old SPZ had fixed format so it is possible to reliably determine what character (letter vs. digit) should be at
			which position (in order to comply with the SPZ rules).
			Fixing consists of transforming letters to the digits and vice versa using these transformation pairs:
			<ul>
			  	<li>
            <code>B</code> &lt;-&gt; <code>8</code>
          </li>
			  	<li>
            <code>I</code> &lt;-&gt; <code>1</code>
          </li>
			  	<li>
            <code>O</code> &lt;-&gt; <code>0</code>
          </li>
			  	<li>
            <code>S</code> &lt;-&gt; <code>5</code>
          </li>
			  	<li>
            <code>Z</code> &lt;-&gt; <code>2</code>
          </li>
			</ul>  
			 <br/>
			If the input passes just one of the phases, then it is assigned to the phase&#39;s era (new format vs. old format).  
			 <br/>
        <br/>
			If there&#39;s ambiguity when deciding whether given input represents old or new format, the input year hint is used. 
			If no input hint is	available then the old SPZs are preferred (since the number of old SPZ &quot;in the wild&quot; is probably 
			much higher then the amount of special RZs they can be confused with).
		</p>
	</description>
    <properties>
			<property name="alphabet" type="string" required="false">Defines the character set
				considered to be an alphabet for RZ. The character set defined
				in the law from 2004 is used as the default value set: {<code>ABCDEFHIJKLMNPRSTVXYZ</code>}.
			</property>
			<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="omitInvalidRZ" type="boolean" required="true">
				When set to <code>false</code> and	the verification of RZ value has failed, the input
				RZ will be copied to the data output property. If the flags <code>RZ_UNKNOWN</code>,
				<code>RZ_BAD_FORMAT</code>, <code>RZ_YEAR_MISMATCH</code>, <code>RZ_TYPE_MISMATCH</code> 
				are set during the verification process, the input value is incorrect.
				If the flag <code>RZ_NULL</code> is set, the output value is incorrect and empty.
				<br/>
				Default value: <code>True</code>.
			</property>
			<property name="outRz" type="string" required="false">
				Where the verified RZ should be saved to.
			</property>
			<property name="outRzType" type="string" required="false">
				Sets out the type of the RZ as determined by the algorithm. The output value is just one of the following:
				<ul>
					<li>
            <code>GENERIC</code> - the input corresponds to the common (standard) RZ format</li>
					<li>
            <code>HISTORICAL</code> - the input corresponds to the historical RZ format</li>
					<li>
            <code>RACING</code> - the input correspondes to the racing RZ format</li>
					<li>
            <code>TESTING</code> - the input corresponds to the testing RZ format </li>
					<li>
            <code>DIPLOMATIC</code> - the input corresponds to the diplomatic RZ format</li>
					<li>
            <code>MANIPULATIVE</code> - the input curresponds to the permanantly manipulative RZ format</li>
					<li>
            <code>TIME_LIMITED</code> - the input corresponds to the time limited RZ format</li>
					<li>
            <code>USER_PATTERN</code> - the input corresponds to the some user pattern</li>
					<li>
            <code>OLD_FORMAT</code> - the input corresponds to the old SPZ format</li>					
				</ul>
			</property>
			<property name="registrationYear" type="string" required="false">
				This determines the year of the vehicle registration. If the year of the registration is after 2001,
				the set vehicle registration number must comply to the new RZ form. Checks only if the mentioned RZ is verified as valid.
			</property>
			<property name="rz" type="string" required="true">
				Specifies the vehicle registration number data source.
			</property>
			<property name="rzPatterns" type="string[]" required="false">A <strong>
				List of properties</strong> which associates a set of <code>rzPattern</code> tags.
			</property>
			<property name="vehicleType" type="string" required="false">
				Vehicle type for more
				accurate verification of RZ. Meanings of single values are as follows:
				<ul>
					<li>
            <code>0</code> - Type is not defined</li>
					<li>
            <code>1</code> - Moped</li>
					<li>
            <code>2</code> - Motorcycle</li>
					<li>
            <code>3</code> - Other types of vehicles</li>
				</ul>
				Checks only if the mentioned RZ is verified as valid and the set vehicle type is different from 0.
				If the set vehicle type is different than above, the RZ is assigned <code>RZ_BAD_TYPE</code>.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="RZ_NULL">A scoring flag indicating that the input RZ is null.
			</scoringKey>
			<scoringKey name="RZ_UNKNOWN">A scoring flag indicating that the input RZ is invalid,
				includes invalid characters or has not been found as a known form.
			</scoringKey>
			<scoringKey name="RZ_BAD_FORMAT">A scoring flag indicating that the input RZ
				has bad format (incorrect length).
			</scoringKey>
			<scoringKey name="RZ_FIXED">A scoring flag indicating that the output RZ was repaired.
			</scoringKey>
			<scoringKey name="RZ_TYPE_MISSING">A scoring flag indicating that the input type is missing even though
				a property for this information is defined.
			</scoringKey>
			<scoringKey name="RZ_TYPE_INVALID">
				A scoring flag indicating that given input type is invalid - it means that passed value does not match any
				of predefined values (see <code>Vehicle Type</code>)
			</scoringKey>
			<scoringKey name="RZ_TYPE_MISMATCH">A scoring flag indicating that the input RZ does not correspond to the vehicle
				type set as <code>Vehicle Type</code> (or <code>Vehicle Type</code> is invalid - contains an incorrect value).
			</scoringKey>			
			<scoringKey name="RZ_YEAR_MISSING">A scoring flag indicating that the input year is missing even though
			a property for this information is defined.
			</scoringKey>			
			<scoringKey name="RZ_YEAR_INVALID">
				A scoring flag indicating that given input year is invalid. To be valid, the year must be in range from 1960 
				(starting year of the former SPZ format) to this year.
			</scoringKey>			
			<scoringKey name="RZ_YEAR_MISMATCH">A scoring flag indicating that the input RZ does not correspond to the year
				(it is given if <code>Registration Year</code> is defined and the input value does not correspond to the RZ vehicle
				registration number).
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidateSKRZAlgorithm">
    <introduction>Validates Slovak vehicle registration number.</introduction>
    <description>This step checks the validity of a vehicle registration number
		(formerly known as SPZ in Czech Republic). If the registration number
		is determined to be invalid, the step attempts to identify possible typing
		errors and, if successful, returns the corrected number. While correcting, the
		step attempts to switch the following pairs of characters:
		&#39;O&#39; &lt;-&gt; &#39;0&#39;, &#39;S&#39; &lt;-&gt; &#39;5&#39;, &#39;Z&#39; &lt;-&gt; &#39;2&#39; and &#39;I&#39; &lt;-&gt; &#39;1&#39;.
		<br/>
		The step does not contain any internal cleaning mechanism (removing invalid
		characters), and expects cleansed data on input. In this case, cleaning
		means removing special characters (pause, spaces, etc.) and character conversion
		to uppercase form.
		<br/>
		First, the step tries to verify uncorrected (not repaired) data as a new RZ and then
		as an old SPZ.  If no match is found, first step tries to find any corrections
		for the format of new RZ and then for the format of an old SPZ. Any RZ which is corrected is given the flag 
		<code>FLAG_FIXED</code>.
		<br/>
		The following rules are checked in the RZ:
		<ul>
				<li>1. a minimum of 6, and a maxium of 7, characters</li>
				<li>2. characters are formed by Latin alphabet capitals and Arabic digits</li>
				<li>3. a matching with some of the possible forms of Slovak RZ or SPZ</li>
		</ul>
		If a match is found with some of the RZ or SPZ forms, then the step validates the production year
		acquired from the <code>Prod Year</code> property with the specified format. If the number is in old format of vehicle number
		and the production year is after 1997, the step will set the <code>BAD_DATE</code> flag.
		This comparison does not have an influence on the
		validity of RZ, it only serves as supplemental information. If no production year information exists,
		the step will set the <code>DATE_MISSING</code> flag. If the property of production year is not used
		(not connected), the &#39;missing&#39; flag will not be set and validation of the production year will not be performed.
		<br/>
		If the vehicle registration number is recognized as valid, the original form (eventually the corrected form)
		is recorded to the output <code>rzOut</code>. For recording an invalid RZ to the output, it is necessary to specify
		the <code>Omit Invalid RZ</code> parameter and set its value to <code>false</code>.
		</description>
    <properties>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="districtLookupFileName" type="string" required="true">Dictionary file that contains
			codes of Slovak regions for RZ. Defined index value is a region code. For more information see the <strong>Dictionary files</strong>.
			</property>
			<property name="omitInvalidRZ" type="boolean" required="true"> Property that influences the output
			value of RZ if the RZ number is invalid. &#39;True&#39; means that the invalid RZ is not written, &#39;False&#39; means that the input (original)
			value is written. <br/>
			Default value: True.
			</property>
			<property name="outRz" type="string" required="false">
				Column that stores the RZ output value.
			</property>
			<property name="prodYear" type="string" required="false">
				Determines the production year of the vehicle. If the production year is after 1997, 
				the set vehicle registration number must be valid. Checks only if the mentioned RZ is verified as valid.
			</property>
			<property name="rz" type="string" required="true">
				Column that contains the RZ input value.
			</property>
      		<property name="vehicleType" type="string" required="false">
      			Not used. Defined for backward compatibility with the 
      			<strong>Validate RZ</strong> step. 
      		</property>					
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="RZ_NULL">A scoring flag indicating that the input RZ is null.
			</scoringKey>
			<scoringKey name="RZ_UNKNOWN">A scoring flag indicating that input RZ is invalid,
			includes invalid characters or has not been found as a known form.
			</scoringKey>
			<scoringKey name="RZ_BAD_FORMAT">A scoring flag indicating that the input RZ has bad
			format (incorrect length).
			</scoringKey>
			<scoringKey name="RZ_FIXED">A scoring flag indicating that the output RZ was repaired.
			</scoringKey>
			<scoringKey name="RZ_SUSP">A scoring flag indicating that the input RZ does not correspond to the
			<code>rzPatterns</code>.
			</scoringKey>
			<scoringKey name="RZ_BAD_YEAR">A scoring flag indicating that the input RZ does not correspond to the vehicle
			type set as <code>Vehicle Type</code> (or <code>Vehicle Type</code> is invalid - contains an incorrect value).
			</scoringKey>
			<scoringKey name="RZ_YEAR_MISSING">A scoring flag indicating that the input value of the production year is
			empty although the property is defined.
			</scoringKey>
			<scoringKey name="RZ_BAD_TYPE">Not used. It is defined only for scoring compatibility with the step Validate RZ.
			</scoringKey>
			<scoringKey name="RZ_TYPE_MISSING">Not used. It is defined only for scoring compatibility with the step Validate RZ.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.clean.ValidateVinAlgorithm">
    <introduction>Validates Vehicle Identification Number.</introduction>
    <description>
			This step validates a VIN (Vehicle Identification Number) and returns its verified value.<br/>
			<strong>NOTE:</strong>
			Using VIN as a resource for vehicle identification/validation can be misleading when additional
			information is missing. Currently, VIN is used by different manufacturers with more or less strict rules.

			The functional capabilities of this step are strongly dependent on the information of manufacturer codes, which are
			supplied using World Manufacturer Identifier (WMI) dictionaries.
			<br/>
      <br/>
			Furthermore, the same manufacturer may use different VIN formats when developing different model series&#39;.
			For example, The Czech company Skoda uses a check-sum number for its Octavia model series,
			however no check-sum is used for the Felicia model series.

			<br/>
      <br/>
			The step considers a VIN as valid only if it satisfies the following conditions/properties:

			<ul>
				<li>The VIN has the correct length and contains only allowed characters.</li>
				<li>The VIN check-sum number (CRC) is correct (only if the VIN contains a CRC).</li>
				<li>The manufacturer&#39;s name (if available in the input data) conforms to the one recognized by WMI.</li>
				<li>Whether the VIN type was successfully and unambiguously identified using:
					  <ul>
					  	<li>unique WMI</li>
					  	<li>unique combination of WMI and input manufacturer&#39;s name</li>
					  </ul>
				</li>
				<li>
				If the manufacturing year derived from the VIN agrees with the input year value hint.
				(Applies only if the position of the year digit within the VIN is known and the input year hint value is available)
				</li>
			</ul>
			<br/>

			This step checks the characters within the input VIN and, if the invalid characters <code>I</code>,<code>O</code> and
			<code>Q</code> are found, they are replaced with the numbers 1, 0 and 0 respectively. 
			<br/>
      <br/>
			<strong>NOTE:</strong>
      <br/>
			The input value must be preprocessed to the appropriate format (i.e., transformed to uppercase and with no diacritics
			(accents) - a sample of the configuration needed for cleansing the data before using this step is in the example).<br/>

			<br/>
			The step checks the validity of the CRC number, but only if VIN type format is successfully identified.
			Recognition of the manufacturer is possible according to the manufacturer&#39;s name and model series. In addition, the CRC check-sum information
			can be derived. If such information is not discernible (the VIN has CRC marked as unknown in the dictionary <code>Vin Info File Name</code>), 
			the VIN is checked to see if:
			<ul>
				<li>it conforms to the US form of VIN, which must contain a CRC in the 9th position (US VINs starts with a digit from range 1-4)</li>
				<li>there&#39;s CRC at the default position (9th position) which agrees with the potential CRC VIN calculation</li>
			</ul>
			Based on the value of the <code>Do Repair</code> parameter, the step can repair an incorrect CRC (when used with setting of 
			the <code>VIN_CRC_FIXED</code> flag). The repair is allowed only if the algorithm is sure that such VIN contains CRC digit (the value of the 
			<code>Out Has Check Digit</code>=<code>TRUE</code>).
			<br/>

			If the manufacturer&#39;s name hint is available on input, it is compared with the name(s) derived from the WMI code of the given VIN -
			this comparison is diacritics (accents) insensitive and case insensitive.
			If the output <code>manuOut</code> is defined, the value of the ascertained/verified manufacturer&#39;s name is stored here - if
			it is unique for a given WMI. If it is not unique for a given WMI (more manufacturers exists for a given WMI), an empty value
			is stored, meaning that it was not possible to choose the proper manufacturer. If validation is not successful, the appropriate flags are set/scored (see 
			flags descriptions).
			<br/>

			The step checks also the production year. The production year processing depends on the production-year-code-position defined in the VIN lookup:
			<ul>
				<li>If the VIN type is known to have production year in the VIN, the production year is decoded from the position defined by the VIN lookup,
					  the <code>TRUE</code> value is written to the output <code>Out Has Prod Year</code> and decoded production year value is
					  written to the <code>Out Year</code>.
					  Then the year-value decoded from the VIN is compared to the <code>Year</code> input hint. If the hint is not empty and
					  the hint value does not match the value decoded from the VIN, the <code>VIN_PY_MISMATCH</code> flag is set and VIN is considered invalid.<br/>
				</li>
				<li>If the VIN type is known to not have production year - then all production year checking mechanism is skipped since there&#39;s no value in
					  the VIN which can be validated. This situation is not marked by any flag.
					  In this case the <code>FALSE</code> value is written to the output <code>Out Has Prod Year</code> and <code>null</code> value
					  is written to the <code>Out Year</code> property.
				</li>
				<li>If it is not known whether the VIN contains the production year or not, the <code>null</code> value is written to the output <code>Out Has Prod Year</code>.
					  Then the algorithm checks if there&#39;s CRC defined in the VIN. If there&#39;s no CRC in the VIN, it is invalid or the guessed CRC is invalid, 
					  the algorithm skips further production-year checks and writes <code>null</code> to the <code>Out Year</code> property.<br/>

					  If the CRC validation was successful - then the algorithm tries to read the production year code from the
				      default (10th) position in the VIN (it assumes that if the VIN supports the CRC digit, there&#39;s a good chance that it supports production
					  year either). If the value in that position is a valid production year code, it is decoded, flag
				      <code>VIN_PY_GUESS</code> is set and the value is written to the <code>Out Year</code>.<br/>
				      
				      Then the decoded year value is compared to the input year hint (if defined) and in case of the mismatch the <code>VIN_PY_MISMATCH</code> flag is set. 
				      But in this case the flag does not invalidate whole VIN since we are not absolutely sure that the code at 10th position is really represents the 
				      production year code.<br/>
          <br/>
				      
				      If the value at 10th position does not represent valid production year value, the further production year checking is skipped.
				</li>
			</ul>
			
			<br/>
			Since the production year is encoded in the VIN using just single position (which may have 30 different values), each 30 years a new 
			cycle starts. Therefore the same value in the VIN may be interpreted as multiple production years. E.g. value <code>&#39;A&#39;</code> stands either for 
			the year 1980 or 2010, 2040 etc. When algorithm detects this ambiguity, the input production year is considered and the closes matching production 
			year is selected. If there&#39;s no input hint specified, the newest possible value is chosen. Due to the production year vs. real year difference, 
			even <code>currentYear</code>+1 value is returned as valid.<br/>
			
			<br/>
			Manufacturers often use their own &quot;model year&quot; when marking the year within the VIN, which does not
			conform to the calendar year: it begins on the first of September in the previous year and ends on the 31st of August
			in a year that is nominally the same as model year. At the same time, it may occur that the value of year included in VIN is less
			than the input year. To eliminate such differences the step can, when validating the VIN, accept a year range
			plus or minus one year. This is considered as valid, and the flag <code>VIN_YEAR_AROUND</code>
			is set (if the attribute <code>Allow Year Around</code> is set to true (which is the default value)).<br/>
			Based on the verifications listed above, the VIN is written to the output in accordance with the setting of the 
			<code>Omit Invalid VIN</code> parameter. This parameter determines whether only VINs which have satisfied all tests
			(true) or VINs which did not satisfy all tests, are written to the output.
		</description>
    <properties>
      		<property name="id" type="string" required="false">
			Step identification string.
			</property>
		 	<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
			<property name="vin" type="string" required="true">
				Column that contains the input VIN.
			</property>
			<property name="year" type="string" required="false">
				Column that contains the input production year hint.
			</property>
			<property name="manu" type="string" required="false">
				Column that contains the manufacturer&#39;s name hint (the value compared with the value determined from the VIN).
			</property>
			<property name="outVin" type="string" required="false">
				Column that stores the final output VIN.
			</property>
			<property name="outYear" type="string" required="false">
				Contains year production information determined from the input VIN.<br/>
              	Since this information is more manufacturer-specific, the determined value is reliable only if there&#39;s no <code>VIN_PY_GUESS</code> flag set. 
              	Otherwise it is a best-guess based on the state of the VIN (see more detailed description below).<br/>
				<ul>
					<li>if this binding is non empty then
						<ul>
							<li>
                <code>VIN_PY_GUESS</code> is not set: algorithm has successfully detected the production year information in the VIN</li>
							<li>
                <code>VIN_PY_GUESS</code> is set: the algorithm does not reliably detected the production year value, so the value written
								  to the output is just a guess</li>
						</ul>
					</li>
					<li>if this binding is empty then
							<ul>
								<li>VIN is known not to have production year information</li>
								<li>or the algorithm does not have any information about the production year presence in the VIN (typically when manufacturer 
									  does not provide any information about its VIN structures)</li>
							</ul>
					</li>	
				</ul>
			</property>
			<property name="outManu" type="string" required="false">
              	Since the manufacturer information is encoded directly in the WMI part of the VIN, this information (when present) is pretty reliable.
				<ul>
					<li>if this binding is non empty then algorithm successfully detected the manufacturer of the vehicle (manufacturer is 
						  defined in the WMI/VIN lookup)</li>
					<li>if this binding is empty then
						<ul>
							<li>manufacturer is unknown</li>
							<li>or there are multiple manufacturers using this type of VIN and the algorithm cannot choose the correct one. 
								  In such case <code>VIN_MANU_MULTIPLE</code> flag is set</li>
						</ul>
					</li>
				</ul>              
			</property>			
			<property name="outHasCheckDigit" type="string" required="false">
				Reliably determines whether given type of VIN contains CRC information or not.
              	This value reliably says whether given VIN type contains CRC or not. It works as a three-state boolean
              	where individual values represents the following states:
              	<ul>
              		<li>
            <code>TRUE</code> - we know that this type of VIN contains CRC information</li>
              		<li>
            <code>FALSE</code> - we know that this type of VIN does not contain CRC information</li>
              		<li>
            <code>null</code> (empty) - we don&#39;t know anything about CRC information in this type of VIN</li>
              	</ul>
				<br/>
              	<strong>Notes:</strong>
              	<ul>
              		<li> this output value is not related to the overall validity of the VIN. In other words: this output binding remains same 
              			   for all VINs of given type regardless on the result of the particular VIN validation (e.g. CRC check result).</li>
              		<li> even if we do not know anything about the CRC in the VIN we try to check it. In such case this output binding contains 
              			   <code>null</code> (as explained above), but flags may report some more information:
              			   <ul>
              			   		<li>
                <code>NO_CRC</code> = CRC check was not successful, but since we are not sure whether there&#39;s CRC in the VIN,
                    					this is not considered an error</li> 
                 				<li>missing <code>NO_CRC</code> - we tried to check the CRC and the check passed. So there&#39;s probably CRC in
                 					  default CRC position but since we can&#39;t be sure about it, the hasCrc binding remains empty.</li> 
                 			</ul>
                 	</li>
                 </ul>   			
			</property>
			<property name="outHasProdYear" type="string" required="false">
              	This property reliably says whether given VIN type contains production year or not. It works as three-state boolean where individual values represents 
              	the following states:
              	<ul>
              	      <li>
            <code>TRUE</code> - we know that this type of VIN contains product year information . If this is the case then mismatch with the 
              	      					  potential input product year hint is considered an error.</li>
              	      <li>
            <code>FALSE</code> - we know that this type of the VIN does not have product year information. If this is the case then input product 
              	      					  year hint is silently ignored (since we have no information from the VIN to compare it with).</li>
              	      <li>
            <code>null</code> - we have no reliable information about this VIN, so we cannot decide whether this VIN contains product year or not. 
              	      					  If this is the case then algorithm tries to perform the production year guess - possible detected year mismatch is then
              	      					  flagged as <code>VIN_PY_MISMATCH</code> but it does not affect VIN validity (since we are not completely sure about the guess). 
              	      </li>
              	</ul>			
			</property>
			<property name="outModel" type="string" required="false">
				Column that stores the ascertained vehicle model, if it is present in the dictionary.
			</property>		
			<property name="allowYearAround" type="boolean" required="true">
				When this parameter is set to &quot;true&quot;, years with a difference of (maximum) 1 are considered as the same
				(disagreement between the vehicle&#39;s &quot;model year&quot; and production year, the calendar year and the car company&#39;s production year).
				If this parameter is set to &quot;false&quot;, only years with no difference will be considered as the same (if
				<code>VIN_YEAR_AROUND</code> is not set).<br/>
				Default value: <code>True</code>.
			</property>
			<property name="doRepair" type="boolean" required="true">
				Repairs incorrect value of checksum number (CRC). This correction is performed only if the error is detected
				(i.e., the step does not correct the CRC when it has been determined that no CRC is present within the VIN).
				This repair is allowed only if the algorithm is sure that there&#39;s CRC in the VIN.
			</property>
			<property name="omitInvalidVIN" type="boolean" required="true">
				Property that influences the output value of the VIN if there is an error
				(a VIN with some of the errors described above). 
				<code>True</code> means that a NULL value is written, <code>False</code> means that the input (original) value is written.
				<br/>
				Default value: <code>True</code>.
			</property>
			<property name="vinInfoFileName" type="string" required="true">
				Dictionary file that contains information about known VIN formats.
				The dictionary contains records with individual VIN types.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
			<property name="wmiFileName" type="string" required="true">
				Dictionary file that will be used for manufacturer&#39;s name
				verification.
				For more information about the dictionary see <strong>the detailed description here</strong>.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
    </properties>
    <scoring>
			<scoringKey name="VIN_NULL">
				A scoring flag indicating that the input VIN is missing.
			</scoringKey>
			<scoringKey name="VIN_BAD_CRC">
				A scoring flag indicating that the input VIN contains incorrect checksum number (CRC).
				This flag is only set when CRC of the VIN is not valid and: 
				<ul>
					<li>the value of the <code>Do Repair</code> is false</li>
					<li>or the value of the <code>Do Repair</code> is true (and therefore the CRC was fixed)
					      but the VIN was not set to the output (out-vin) because of some other error (e.g. product year mismatch etc.).
					</li>
				</ul>
			</scoringKey>
			<scoringKey name="VIN_FIXED">
				A scoring flag indicating that the VIN was cleansed (unsupported characters deleted), incorrect characters (O,I,Q)
				replaced with correct ones (1,0).
			</scoringKey>
			<scoringKey name="VIN_BAD_FORMAT">
				A scoring flag indicating that the input VIN has a bad format (invalid length).
			</scoringKey>
			<scoringKey name="VIN_CRC_FIXED">
				A scoring flag indicating that the checksum number was not correct but it was corrected and the VIN with correct checksum number was
				written to the vin-out output. The repair is allowed only if the algorithm is sure that VIN type contains VIN 
				(<code>Out Has Check Digit</code>=<code>TRUE</code>). This flag is set only if there&#39;s something
				in the out-vin output - if the CRC was fixed but the vin-out is empty due to some other error (e.g. product year mismatch) then 
				<code>VIN_BAD_CRC</code> flag is used instead to prevent the situation when flags says that CRC was fixed but the output VIN is empty.
			</scoringKey>
			<scoringKey name="VIN_CRC_GUESS_FAIL">
				 A scoring flag indicating that the VIN probably does not contain a checksum number or it is not possible to
				 decide in which position it is located.<br/>
				 This flag is set only if <code>Out Has Check Digit</code>=<code>null</code> and the CRC check at the default position has failed.
			</scoringKey>
			
			<scoringKey name="VIN_WMI_NOT_FOUND">
				A scoring flag indicating that the WMI ascertained from the VIN was not found in the WMI dictionary.
			</scoringKey>
			
			<scoringKey name="VIN_PY_HINT_MISSING">
				A scoring flag indicating that the input <code>Year</code> contains empty value.
			</scoringKey>
			<scoringKey name="VIN_PY_HINT_INVALID">
				A scoring flag indicating that the <code>Year</code> value is incorrect (date is far in the past, in the future, etc.).
			</scoringKey>
			<scoringKey name="VIN_PY_INVALID">
				A scoring flag indicating that the year-code in the VIN has an incorrect value (&#39;I&#39;, &#39;O&#39;, &#39;Q&#39;, &#39;U&#39;, &#39;Z&#39; or &#39;0&#39;).
				This error flag is set only if we are sure there&#39;s PY in the VIN ((<code>Out Has Prod Year</code>=<code>TRUE</code>)).
			</scoringKey>
			<scoringKey name="VIN_PY_MISMATCH">
				A scoring flag indicating that the input <code>Year</code> value differs from the value ascertained from the VIN by more than 1 year.
				If the <code>Out Has Prod Year</code>=<code>TRUE</code> then this is an error flag. Otherwise it is just an
				informational flag (since the algorithm is not sure whether there&#39;s production year encoded in the VIN). 
			</scoringKey>
			
			<scoringKey name="VIN_MANU_MISSING">
				A scoring flag indicating that the input producer&#39;s name is missing even though a binding for this information is defined.
			</scoringKey>
			<scoringKey name="VIN_MANU_MULTIPLE">
				A scoring flag indicating that according to the dictionary, VIN format corresponds to more than one producer
				(input vin is considered as invalid when this flag is set together with <code>VIN_MANU_MISSING</code>. The reason is that it is not possible to 
				decide what the right producer is).
			</scoringKey>
			<scoringKey name="VIN_MANU_MISMATCH">
				A scoring flag indicating that the producer&#39;s name ascertained from the VIN (WMI code and some other identifiers) does not correspond to
				the name given in the <code>Manu</code> input.
			</scoringKey>
			<scoringKey name="VIN_PY_GUESS">
				A scoring flag indicating that there is no reliable information about the VIN available and therefore the year was
				estimated (from the number at 10th position of the VIN).<br/>
				This flag is set only if <code>Out Has Prod Year</code>=<code>null</code> and algorithm has successfully detected 
				the PY from the VIN (e.g. valid value is present at the default PY position and the VIN has CRC so we can assume that the value we 
				read for PY really identifies PY).				
			</scoringKey>
			<scoringKey name="VIN_YEAR_AROUND">
				A scoring flag indicating that the input year is not equal to the one ascertained from the VIN, but it differs
				by only 1 year.
			</scoringKey>
		</scoring>
  </class>
  <class super="com.ataccama.one.profiling.linear.simple.params.feature.ColumnStatistic" name="com.ataccama.one.profiling.linear.simple.params.feature.ValueCount">
    <introduction>Statistic that provides total count and null counts.</introduction>
    <properties/>
    <scoring/>
  </class>
  <class super="com.ataccama.dqc.tasks.ai.transformation.imputing.definition.ImputingFeatureTransformation" name="com.ataccama.dqc.tasks.ai.transformation.imputing.definition.ValueImputingTransformation">
    <introduction>Replaces null values with specified value.</introduction>
    <properties>
            <property name="value" type="string" required="true">
                Value, that is used to replace null values. Data type must correspond to the input type of this transformation.
            </property>
        </properties>
  </class>
  <class name="com.ataccama.ai.algorithms.commons.Metrics$Values"/>
  <class name="com.ataccama.adt.variables.read.ReadLinesFile$VariableMapping">
    <introduction>Variables read from file</introduction>
    <description/>
    <properties>
			<property name="line" type="integer" required="true">Line number from which value should be read</property>
			<property name="name" type="string" required="true">Variable name</property>
			<property name="type" type="com.ataccama.dqc.expressions.model.data.DataType" required="true">Value type</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">Value data format</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.variables.read.ReadPropertyFile$VariableMapping">
    <introduction>Variables read from property file</introduction>
    <description/>
    <properties>
			<property name="name" type="string" required="true">Variable name and also key in property file</property>
			<property name="type" type="com.ataccama.dqc.expressions.model.data.DataType" required="true">Value type</property>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">Value data format</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.common.abp.parser.configuration.Verifier">
    <description>
			Defines the word lookup engine. Specifies the method with which the lookup is processed, the 
			dictionary(ies) of acceptable words and the word normalization method.
		</description>
    <properties>
			<property name="fileName" type="string" required="false">
				Dictionary file with single word strings (values against which a single word component is verified).
			</property>
			<property name="multiFileName" type="string" required="false">
				Dictionary file with multiple word strings (values against which a multiple word component is verified).<br/>
			</property>
			<property name="maxErrors" type="integer" required="true">
				Maximum edit distance between parsed and 
				dictionary values.<br/>
				Default value: 0.
			</property>
			<property name="maxErrorRatio" type="float" required="true">
				Maximum relative distance (edit distance to dictionary value length ratio).<br/>
				Default value: 1.0.			
			</property>
            <property name="wordSeparators" type="string" required="false">
                Definition of possible word separators to be used when searching in the lookup defined
				by <code>File Name</code>. Empty value causes the text be split into separate characters.
                Default value: space.
            </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.server.services.VersionedFileSystemComponent">
    <introduction>Defines a set of versioned filesystem folders.</introduction>
    <description>
			Defines a set of versioned filesystem folders. The component is used to monitor configuration file changes in order to enable reloading new configuration without a server restart. Modified files are detected on the refresh command execution and are replaced to the currently running configurations.
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="requiredRole" type="string" required="false">User role required to execute the refresh command.</property>
			<property name="versionedFolders" type="string[]" required="false">Paths (absolute or relative to the location of server configuration file) to filesystem folders that should be versioned.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfWaitForFileTask">
    <introduction>Waits for a file to appear (or disappear) with a defined timeout.</introduction>
    <description>Waits for a file to appear (or disappear) with a defined timeout. If the file does not appear (disappear) in a given period of time, the task fails. Otherwise it succeeds and returns FINISHED_OK state.
			<p align="justify">The task can use remote resources (accessible with <code>resource://&lt;resourceName&gt;/&lt;path&gt;/&lt;inputFile&gt;</code> syntax):</p>
				<ul>
					<li>Amazon S3 server</li>
					<li>HDFS (if your product package contains Big Data Engine)</li>
				</ul>
    </description>
    <properties>
			<property name="fileName" type="string" required="true">Path to the file(s) to appear (disappear).
			<p align="justify">Supports wildcards.</p>
			</property>
			<property name="pollingInterval" type="string" required="true">The interval to wait between two checks of the condition (ms). Value &gt;0 required.</property>
			<property name="timeout" type="string" required="true">The maximum amount of time the task waits for the condition to be true (ms). After this time, the task fails (it does not wait anymore even if the condition is just being checked). Value &gt;0 required.</property>
			<property name="waitFor" type="com.ataccama.adt.task.exec.EwfWaitForFileTask$FileApperMode" required="true">If the value is set to &quot;appear&quot;, the task waits for a file appearance. If the value is &quot;disappear&quot;, the task waits for the file removal (i.e. some lock file).</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfWaitForSqlRowTask">
    <introduction>Waits (at maximum given amount of time) until specified query returns result containing at least one row.</introduction>
    <description>Task waits (at maximum given amount of time) until specified query returns result containing at least one row. If the query returns no result set, the task fails immediately. If the result set contains no row, the task keeps waiting.</description>
    <properties>
			<property name="connectionName" type="string" required="true">Name of the database connection.</property>
			<property name="pollingInterval" type="string" required="true">The interval to wait between two checks of the condition (ms). Value &gt;0 required.</property>
			<property name="query" type="string" required="true">Query to execute over the database; supports variable mappings.</property>
			<property name="timeout" type="string" required="true">The maximum amount of time the task waits for the condition to be true (ms). After this time, the task fails (it does not wait anymore even if the condition is just being checked). Value &gt;0 required.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfWaitForSqlValueTask">
    <introduction>Waits (at maximum given amount of time) until the condition is evaluated to true.</introduction>
    <description>Waits (at maximum given amount of time) until the specified condition is evaluated to true. If the query passed to the task does not return any result (i.e. it does not return any result set containing rows and it does not contain any output parameters), the task fails immediately.
			<br/> If the query returns a result set, only the first row is taken into account: therefore it is recommended to specify the query the way it returns only one specific row or use &quot;order by&quot; clause in order to retrieve rows in an intended order.
				<ul>
					<li>Values read from the query are not stored to the task&#39;s variables until the condition is evaluated as true (but still are available in the condition).</li>
					<li>All objects read from mappings are converted to strings before storing on context (evaluation in conditions, storing to task variables) because workflow does not support data types. When using mapped values in condition, re-typing to the desired type is required (eg. toInteger). When deserializing Date values, use default US Date format &quot;yyyy-MM-dd HH:mm:ss.&quot;</li>
					<li>Since values from the mappings are mapped as global variables in the <strong>Condition</strong> property, the mapping with the same name as a global variable overrides this global variable&#39;s value in the Condition evaluation.</li>
				</ul>
			</description>
    <properties>
			<property name="condition" type="string" required="true">Condition determining whether the task can quit. It must evaluate to boolean: if the result is TRUE, the task quits and mapped output values are stored to the task&#39;s variables. If the condition&#39;s result is FALSE, the task continues to wait/check.</property>
			<property name="connectionName" type="string" required="true">Name of the database connection.</property>
			<property name="mapping" type="com.ataccama.adt.task.base.Mapping" required="false">Defines how to map the output parameters and values read from the result set to the variables. Each mapping must have name which is used either in the condition or later for setting up the value to the task variable.</property>
			<property name="pollingInterval" type="string" required="true">The interval to wait between two checks of the condition (ms). Value &gt;0 required.</property>
			<property name="query" type="string" required="true">Defines SQL query to execute. The query uses the following syntax for passing parameters:
				<ul>
					<li>${name} – variable mapping, value of the variable name will be passed to the query</li>
					<li>$+{name} – output parameter mapping, output variable name will be registered to the SQL statement at this place. Mapping property must contain <strong>Output Parameter</strong> element with this name (it specifies data type of the output parameter)</li>
					<li>$#{name} – string replace, value of the variable name will be placed to the SQL query at given position</li>
				</ul>
			</property>
			<property name="timeout" type="string" required="true">The maximum amount of time the task waits for the condition to be true (ms). After this time, the task fails (it does not wait anymore even if the condition is just being checked). Value &gt;0 required.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.web.console.WebConsoleComponent">
    <introduction>Enables Admin Center.</introduction>
    <description>
			Enables Admin Center.
		</description>
    <properties>
			<property name="cacheTemplate" type="boolean" required="true">Enables caching of Admin Center page templates.</property>
			<property name="customMenuCategories" type="com.ataccama.dqc.web.console.MenuCategory[]" required="false">Specifies custom menu categories. Each custom category corresponds to a section in the Admin Center navigation panel.</property>
			<property name="customMenuItems" type="com.ataccama.dqc.web.console.MenuItem[]" required="false">Specifies custom menu items (pointing to external servers and/or document folders) in the Admin Center.</property>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="listeners" type="string" required="false">Comma-separated list of names of HTTP listeners where the console should be accessible. If the attribute is missing, the console will be deployed on all listeners.</property>
			<property name="requiredRole" type="string" required="false">User role required to access the Admin Center.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.html.WebLookupAlgorithm">
    <introduction>Reads values from a web page defined by the input value.</introduction>
    <description>
			This step downloads a web page for each input row. Optionally, it can
			transform the page
			using an XSLT transformation and extract
			information which can be stored
			in
			columns. The address of the
			downloaded web page is constructed using data in
			the input
			row. Various
			problems can be scored, e.g. timeout, no response, wrong
			transformation, etc.
			<br/>
			<br/>
			Parameters to be sent to the server are stored in
			<code>Post Parameters</code>
			(when using the POST
			method) and depend on the technology used. Some
			common ones are:
			<br/>
			<br/>
			<strong>ASPX</strong>
			<br/>
			Requires posting of the attributes that are involved in the creation
			of the
			<code>VIEWSTATE</code>
			value, the
			<code>VIEWSTATE</code>
			value itself and the form element being clicked.
			The
			<code>VIEWSTATE</code>
			value is used by ASPX to keep the
			state and values of the ASP form.
			Values that are involved in the
			VIEWSTATE value are controls
			having
			some value (text fields, combo boxes, etc.). To inform the server
			about the clicked button it
			also needs to send the respective button
			ID. Values that need to be sent
			can be determined by
			analyzing HTTP
			data communication between the server and client. This can be
			done
			using a specialized tool, such as:
			<ul>
				<li>Firefox page info (tab Form) - for version 3 this can be done
					using, for example,
					the Page Info Forms and Links plugin
					(https://addons.mozilla.org/cs/firefox/addon/7978)</li>
				<li>Ethereal network analyzer</li>
				<li>and others</li>
			</ul>
			A simple example: a form has one entry text field,
			<code>idValue</code>
			, a button,
			<code>cmdSend</code>
			,
			which performs the form&#39;s
			<code>submit</code>
			action, a button,
			<code>cmdReset</code>
			, which performs the form&#39;s
			reset action and labels,
			<code>label1</code>
			and
			<code>label2</code>
			. So, the values that
			indicate that the form was filled in and sent
			for processing are:
			<ul>
				<li>
					<code>__VIEWSTATE</code>
					(can be read from the HTML page containing the form)
				</li>
				<li>
					<code>label1, label2</code>
				</li>
				<li>
					<code>idValue</code>
				</li>
				<li>
					<code>cmdSend</code>
					(may have any value, since the server only needs to know that
					<code>cmdSend</code>
					was clicked)
				</li>
			</ul>
			<br/>
			<strong>JSP</strong>
			<br/>
			Requires sending attributes that determine the result plus the
			control that was selected (clicked). So, using
			the same example as for
			ASP, the values that need to be sent are:
			<ul>
				<li>
					<code>idValue</code>
				</li>
				<li>
					<code>cmdSend</code>
					(again with any value - the server only needs to know about this
					control)
				</li>
			</ul>
			<br/>

		</description>
    <properties>
			<property name="beforeTransformationDebugFile" type="string" required="false">
				The downloaded page transformed into XML can be stored in a
				file for
				debugging purposes. Only the page for the last row is
				stored.
			</property>
			<property name="afterTransformationDebugFile" type="string" required="false">
				The same as
				<code>Before Transformation Debug File</code>
				, except that the transformed page is stored.
			</property>
			<property name="transformationFile" type="string" required="false">
				The XSLT
				transformation file.
			</property>
			<property name="cookies" type="string" required="false">
				Name of the column where to load/store cookies from/to. If this
				binding is defined together with
				the
				<code>Init Url Pattern</code>
				attribute, then
				<code>Init Url Pattern</code>
				is used to retrieve cookies
				and these cookies are stored to this
				column for later usage (in subsequent steps that needs to
				use same
				cookies for example). When
				<code>Cookies</code>
				attribute is set and
				<code>Init Url Pattern</code>
				is empty, then cookies are read from this column and send to the
				remote server.
			</property>
			<property name="initUrlPattern" type="string" required="false">
				Address that
				determines which URL to use to read cookie-related data. It needs to
				be filled in if the server requires, for example, the session ID to
				be sent with the HTTP request. This
				is the case for ASPX, JSP and
				other page types. Before processing individual rows, the
				step
				connects to this address using the GET method and retrieves all
				cookie-related
				data. These data are then sent to the server with each
				HTTP request.
			</property>
			<property name="postParameters" type="com.ataccama.dqc.tasks.io.html.ParameterDefinition[]" required="false">
				Defines parameters to be sent to the website as POST parameters.
			</property>
			<property name="usePostMethod" type="boolean" required="true">
				Determines
				whether to use the POST method. It is set to false by default, which
				represents the GET method.
			</property>
			<property name="urlPattern" type="string" required="true">
				The URL where
				web pages are downloaded from. The URL is constructed
				dynamically.
				The column values can be substituted into the pattern as
				&quot;{column_name}&quot;. Example:
				&quot;http://www.web.com/?id={column_name}&quot;.

				Values inserted to &quot;{column_name}&quot; are automatically URL encoded
				(percent-encoding). Use
				option &quot;{column_name|noEscape}&quot; to disable
				translation of special
				characters.
			</property>
			<property name="timeout" type="double" required="true">
				The time in
				seconds in which the page must be downloaded for each row.
				If the
				downloading time is longer than this, nothing is stored in the
				output columns,
				the row
				is scored and processing continues to the next
				row.
			</property>
			<property name="responseDebugFile" type="string" required="false">
				The responses can be written into the file. If the file name contains a percent character
				then it is replaced by the number of the record for which the response was generated.
				If a file with the same name exists then it is rewritten.
			</property>
			<property name="requestDebugFile" type="string" required="false">
				The same as <code>Response Debug File</code> but for the request.
			</property>
			<property name="columns" type="com.ataccama.dqc.tasks.io.html.Column[]" required="true">
				Each column maps a text extracted from downloaded and
				optionally
				transformed page to
				a column in the input row.
			</property>
		<property name="scorer" type="com.ataccama.dqc.tasks.common.scoring.Scorer" required="true">
			Element which stores basic scoring settings.
			</property>
      <property name="id" type="string" required="false">
			Step identification string.
			</property>
    </properties>
    <scoring>
			<scoringKey name="WLA_RESPONSE_TIMEOUT">
				The downloading time was longer then the
				value in the &quot;timeout&quot;
				property.
			</scoringKey>
			<scoringKey name="WLA_UNKNOWN_RESPONSE">
				The response code from the server was not
				between 200 and 299.
			</scoringKey>
			<scoringKey name="WLA_TRANSFORMATION_ERROR">
				Some error happened when transforming the
				downloaded page using the XSLT
				file.
			</scoringKey>
			<scoringKey name="WLA_MALFORMED_URL">
				The dynamically constructed url was
				malformed.
			</scoringKey>
		</scoring>
  </class>
  <class name="com.ataccama.dqc.tasks.text.WordAnalyzer">
    <introduction>Classifies words in string according to dictionaries.</introduction>
    <description>
			This step identifies words by parsing input column values
			using a specified separator and replaces them with symbols -
			names of dictionaries specified by step properties. Furthermore these
			created strings can be matched against patterns. If some pattern is
			matched then this pattern goes to the output instead of the created
			string. If the string is not found, there are three possible actions and
			three corresponding output columns (plus a trash column):
			<ul>
			<li>output column <code>dest</code> - not found strings are removed</li>
			<li>output column <code>maskWithUnknownLeft</code> - not found strings
			are left as they were in the input if no pattern is found</li>
			<li>output column <code>maskWithUnknownReplaced</code> - not found strings
			are replaced by the string defined in the <code>symbolForUnidentifiedWords
			</code>
			property</li>
			</ul>
			Unknown strings can be copied into the <code>trash</code> column.
			The step is repeated for each pair of source and destination columns.
		</description>
    <properties>
			<property name="analyzedColumns" type="com.ataccama.dqc.tasks.text.AnalyzedColumn[]" required="true">
			List of analyzed columns <code>&lt;analyzedColumn&gt;</code>
			containing source and destination column pairs.
			</property>
			<property name="trashSeparator" type="string" required="false">
			If unidentified words are found then these words are stored in a column optionally defined on each analyzed
			column and these words are separated by this property value.
			</property>
			<property name="copySeparators" type="boolean" required="true">
			Specifies whether the data input separator characters should be copied into the
			data output. Default behavior is &#39;true&#39;.
			</property>
			<property name="separator" type="string" required="true">
				Definition of characters used to divide/parse the input data into
				tokens (words).
				See <strong>character set definition syntax</strong>.
			</property>
			<property name="listOfValues" type="com.ataccama.dqc.tasks.text.ListOfValue[]" required="false">
				List of <code>&lt;slListOfValue&gt;</code> elements containing filenames
				with String Lookup dictionaries and their symbols (names).
				Note: At least one dictionary must be specified within this step - at least
				one of either <code>&lt;slListOfValue&gt;</code> or <code>&lt;mlListOfValue&gt;</code>
				must be supplied (and be nonempty).
			</property>
			<property name="symbolForUnidentifiedWords" type="string" required="false">
			Specifies a character or character sequence that should be used to
			replace words not present in the specified dictionaries.
			</property>
			<property name="whenCondition" type="string" required="false">
			Expression that must be satisfied for this step to be executed.
			</property>
  			<property name="id" type="string" required="false">
			Step identification string.
			</property>
		</properties>
  </class>
  <class super="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.ISearchMethodDefinition" name="com.ataccama.dqc.tasks.addresses.dictionary.model.searching.WordAwareMethod">
    <introduction>
    		Search method that uses single words from the input text to find known values.
    	</introduction>
    <description>
    		The methods tokenize input text into words and these words are used
    		as keys to find known values for each component that has its
    		property <code>input</code> set to true. The dictionaries 
    		are specified by the components themselves and are not specified here.
    		The found values are then compared
    		to the input text to verify positive matches up to a maximum error.
    		The word is used as a key to the dictionaries only when its
    		length is at least the value specified (property <code>Min Word Length</code>)
    		and is not found in an optional excluded words dictionary.
    	</description>
    <properties>
			<property name="searchSingleWords" type="boolean" required="true">
				Specifies searching for single words directly in the dictionaries
				Default value: False.
			</property>
			<property name="minWordLength" type="integer" required="true">
				Minimum length of the word to be searched in the dictionaries.
				This prevents searching words that are abbreviations such as: 
				rd (road) or ul (ulice).
				Default value: 2.
			</property>
			<property name="excludedWordsFileName" type="string" required="false">
				Name of the dictionary containing values that are not searched in
				the dictionaries. This lookup is optional and, 
				if not specified, all &quot;searchable&quot; words are searched.
			</property>
    	<property name="inputComponents" type="com.ataccama.dqc.addresses.commons.model.components.EntityComponentReference[]" required="true">
		      List of input components to be searched for.
		  </property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.nlp.WordTokenizer">
    <introduction>Splits input to words.</introduction>
    <description>
            <p align="justify">Step creates a new record for each word token (word, punctuation mark, abbreviation etc.)
                in the input string.
            </p>
            <p align="justify">For optimal performance, one input record should be one sentence. Prepare large documents
                with
                <strong>SentenceTokenizer</strong>
                .</p>
            <p align="justify">OpenNLP model files are necessary for this step. Model files can be trained with the
                <strong>WordTokenizerTrainer</strong>
                step.</p>
        </description>
    <properties>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="inputColumn" type="string" required="true">Column containing input sentences.</property>
            <property name="modelFile" type="string" required="true">OpenNLP TokenizerModel file.</property>
            <property name="outputColumn" type="string" required="true">Column for output tokens.</property>
            <property name="recordDescriptorColumn" type="string" required="false">Record descriptor column.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.tasks.nlp.WordTokenizerTrainer">
    <introduction>Trains the model for
            <strong>WordTokenizer</strong>
            .</introduction>
    <description>
            <p align="justify">Step creates the model for
                <strong>WordTokenizer</strong>
                .</p>
            <p align="justify">Tokens are either separated by a whitespace or by a special &lt;SPLIT&gt; tag. At least one &lt;SPLIT&gt; tag is necessary in the input stream, otherwise the model training will fail.</p>
            <p align="justify">The following sample shows the correct input format:</p>
            <example>
                <pre>Pierre Vinken&lt;SPLIT&gt;, 61 years old&lt;SPLIT&gt;, will join the board as a nonexecutive
director Nov. 29&lt;SPLIT&gt;. Mr. Vinken is chairman of Elsevier N.V.&lt;SPLIT&gt;, the Dutch
publishing group&lt;SPLIT&gt;. Rudolph Agnew&lt;SPLIT&gt;, 55 years old and former chairman of
Consolidated Gold Fields PLC&lt;SPLIT&gt;, was named a nonexecutive director of this British
industrial conglomerate&lt;SPLIT&gt;.</pre>
            </example>
            <p align="justify">More information about training can be found at OpenNLP website (
                <code>http://opennlp.apache.org</code>
                ).</p>
        </description>
    <properties>
            <property name="abbreviations" type="string" required="false">Known abbreviations column.</property>
            <property name="cutoff" type="integer" required="true">The minimal number of times a feature must be seen, otherwise it is ignored.</property>
            <property name="id" type="string" required="false">
			Step identification string.
			</property>
            <property name="inputValues" type="string" required="true">Training input column.</property>
            <property name="iterations" type="integer" required="true">Number of training iterations.</property>
            <property name="modelFile" type="string" required="true">Output model file.</property>
        </properties>
    <scoring/>
  </class>
  <class name="com.ataccama.dqc.web.config.WorkerQueueBean">
    <description>Defines dedicated thread pools to some services or requests. The <strong>Worker Queues</strong> has <strong>Mappings</strong> subsection with subelements that define conditions when the worker queue is activated. All requests that meet the URL pattern and listener defined in the <strong>Mappings</strong> section are handled by the queue defined. If the <strong>Mappings</strong> are not specified, the Worker Queue will be mapped to all listeners and all requests.
		</description>
    <properties>
			<property name="healthStateRecoveryTimeout" type="long" required="true">Amount of time (ms) for which the imperfect health state is visible after the last incident.</property>
			<property name="healthStateRefreshRate" type="long" required="true">Frequency (ms) of the <strong>Worker Queue</strong> health state refresh.</property>
			<property name="mappings" type="com.ataccama.dqc.web.config.MappingBean[]" required="false">Worker queue mappings.</property>
			<property name="maxQueueSize" type="integer" required="true">Maximum number of waiting requests in the queue.</property>
			<property name="name" type="string" required="false">Worker queue name.</property>
			<property name="shutdownTimeout" type="long" required="true">Maximum amount of time (ms) the server waits to finish already started requests in case the server is being stopped.</property>
			<property name="threadNumber" type="integer" required="true">Number of threads dedicated to handle requests from the queue.</property>
			<property name="timeout" type="long" required="true">Maximum amount of time (ms) each request waits for the execution thread.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.web.WorkflowServerComponent">
    <introduction>
			Adds Workflows section to Admin Center and enables running workflows on the server via the Admin Center, HTTP Request and OnlineCtl.
		</introduction>
    <description>
			Adds Workflows section to Admin Center and enables running workflows on the server via the Admin Center, HTTP Request and OnlineCtl.
		</description>
    <properties>
			<property name="disabled" type="boolean" required="true">Specifies whether component should be disabled.</property>
			<property name="httpListener" type="string" required="false">The <strong>HTTP Dispatcher</strong> listener on which workflows can be executed via HTTP requests.</property>
			<property name="logLevel" type="integer" required="true">Maximum level of events that will be logged into server console. The levels are:
				<ul>
					<li>-1: Log everything.</li>
					<li>0: Log nothing.</li>
					<li>1: Log everything related to Workflow Server Component.</li>
					<li>2: Log starts and ends of workflows, state changes of workflow tasks.</li>
					<li>3: Log activities of workflow tasks.</li>
					<li>4 and higher: Log activities of other subloggers (e.g., DQC plans started by workflows). Workflows that log on the level 4 or higher are rare.</li>
				</ul>
      </property>
			<property name="resourcesFolder" type="string" required="false">
			<p align="justify">
				Relative (to the server configuration file) or absolute location where to store supporting and resource files. Currently, there are stored:
				<ul>
					<li>File containing ID generation state for running task instances.</li>
    				<li>Log files created by the workflow for individual workflow instances.</li>
    			</ul>
    		</p>
    			</property>
			<property name="showRuntimeConfiguration" type="boolean" required="true">Specifies whether the runtime configuration is displayed in the ONE Runtime Server Admin when using the Run DQC Process task.</property>	
          	<property name="sources" type="com.ataccama.adt.web.SourceConfigBean[]" required="false">Defines named sources of the workflow configurations.</property>
			<property name="stateStorageProvider" type="com.ataccama.adt.runtime.state.storage.IStateStorageProvider" required="true">Defines which backend should be used for storing the workflow execution states. Currently, there are two storage provider implementations: DB State Storage Provider and File State Storage Provider.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.task.exec.EwfWriteFileVariablesTask">
    <introduction>Writes workflow variables to a target file</introduction>
    <description>Mapping of variables to target file depends on selected strategy (see File Variable Strategy).</description>
    <properties>
			<property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="false">Specifies how values of different types should be formatted.</property>
			<property name="encoding" type="string" required="true">The encoding used in the target file.</property>
			<property name="fileVariableStrategy" type="com.ataccama.adt.variables.write.IWriteFileVariables" required="true">Defines how the values should be written to the target file.</property>
			<property name="targetFile" type="string" required="true">The file to write to.</property>
		</properties>
  </class>
  <class name="com.ataccama.adt.variables.write.IWriteFileVariables">
    <properties/>
  </class>
  <class super="com.ataccama.adt.variables.write.IWriteFileVariables" name="com.ataccama.adt.variables.write.WritePropertyFile">
    <introduction>Write values to the target file as key-value pairs</introduction>
    <description>Writes values to the target file in property file format, i.e. as <code>key=value</code>.</description>
    <properties>
			<property name="properties" type="com.ataccama.adt.variables.write.WritePropertyFile$PropertyMapping[]" required="false">Properties</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.variables.write.IWriteFileVariables" name="com.ataccama.adt.variables.write.WriteWholeFile">
    <introduction>Write single value to the target file</introduction>
    <description/>
    <properties>
			<property name="expression" type="string" required="true">
				Expression to evaluate and write its result to property file. To write multiple lines, concatenate lines with line-ending characters,
				for example <code>ewfGetTaskVariable(&#39;task-1&#39;, &#39;a&#39;) + &#39;\r\n&#39; + ewfGetTaskVariable(&#39;task-2&#39;, &#39;b&#39;)</code>
			</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.reader.XmlParser">
    <introduction>Parses xml strings from input stream and puts them into one or more output end points.</introduction>
    <description>
		This step is similar to the <strong>Xml Reader step</strong>.
		It can create several output streams from input stream containing xml strings. Rows of one output stream can be
		logically children to rows from another stream of rows. For example let&#39;s assume input xml contains set
		of clients and each client has several addresses. Such record can be read as a stream of clients
		and another stream of addresses, where each address can have an id taken from the client stream (for
		further identification of the corresponding client). Each stream can also use shadow columns and referencing
		values from other columns of the input stream for further identification of particular records.

		The input stream passes through to the default output &quot;out&quot;, with the possibility to specify a column that will
		be filled with explanation in case of an error parsing the associated xml.

		The namespaces official specification can be a little tricky and therefore if they are used it is good to read
		<a href="http://www.w3.org/TR/2009/REC-xml-names-20091208/" target="_blank">namespace specification</a>.
		</description>
    <properties>
		 	<property name="inputColumn" type="string" required="true">The input column containing xml strings to be parsed.</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="namespaces" type="com.ataccama.dqc.tasks.io.xml.reader.PrefixNamespacePair[]" required="false">
				When the xpaths contain namespaces then the namespaces must be used by prefixes
				which are defined here. Eg. for xpath expression &quot;pr:el&quot; the prefix &quot;pr&quot; with its
				namespace must be defined here.
			</property>
      <property name="recordsOutputs" type="com.ataccama.dqc.tasks.io.xml.reader.RecordsOutput[]" required="true">
				Output end points defined on the root level.
		 	</property>
      <property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
			General parameters for data formatting. This configuration is applied to
			all specified columns unless the column defines its own
			<code>dataFormaParameters</code> section.
			For more information, see <strong>
					  DataFormatParameters</strong>
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.reader.XmlReader">
    <introduction>Reads data from a xml file and puts them into one or more output end points.</introduction>
    <description>
		It can create several output streams from one xml file where rows of one stream can be
		logically children to rows from another stream of rows. Eg. file can contain records
		of clients and each client have several addresses and then the xml file can be read
		as a stream of clients and for each client there can be read addresses where addresses
		are put to another stream. The streams can also be independent. The namespaces official
		specification can be a little tricky and therefore if they are used it is good to read
		<a href="http://www.w3.org/TR/2009/REC-xml-names-20091208/" target="_blank">namespace specification</a>.
		</description>
    <properties>
		 	<property name="fileName" type="string" required="true">The source xml file.</property>
		<property name="id" type="string" required="false">
			Step identification string.
			</property>
      <property name="namespaces" type="com.ataccama.dqc.tasks.io.xml.reader.PrefixNamespacePair[]" required="false">
				When the xpaths contain namespaces then the namespaces must be used by prefixes
				which are defined here. Eg. for xpath expression &quot;pr:el&quot; the prefix &quot;pr&quot; with its
				namespace must be defined here.
			</property>
      <property name="recordsOutputs" type="com.ataccama.dqc.tasks.io.xml.reader.RecordsOutput[]" required="true">
				Output end points defined on the root level.
		 	</property>
      <property name="dataFormatParameters" type="com.ataccama.dqc.tasks.common.parse.DataFormatParameters" required="true">
			General parameters for data formatting. This configuration is applied to
			all specified columns unless the column defines its own
			<code>dataFormaParameters</code> section.
			For more information, see <strong>
					  DataFormatParameters</strong>
			</property>
    </properties>
  </class>
  <class name="com.ataccama.dqc.web.security.XmlSecurity">
    <introduction>Authentication is configured in an external XML file using the Spring framework.</introduction>
    <description>Authentication is configured in an external XML file using the Spring framework.</description>
    <properties>
			<property name="securityConfig" type="string" required="false">Specify path to configuration file <strong>spring-security.xml</strong>.</property>
		</properties>
  </class>
  <class name="com.ataccama.server.http.security.custom.XmlSpringSecurity">
    <introduction>Authentication is configured in an external XML file using the Spring framework.</introduction>
    <description>Authentication is configured in an external XML file using the Spring framework.</description>
    <properties>
			<property name="configFile" type="string" required="false">Specify path to configuration file <strong>spring-security.xml</strong>.</property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.write.XmlWriter">
    <introduction>Writes data to a file in XML format.</introduction>
    <description>
			The data output is a standard XML file containing records stored as XML nodes.
			Multiple data flows (called data streams in the step configuration) can be stored
			to a single file, each in different format. The individual records are stored as
			a single element with arbitrarily complex inner structure (attributes and subelements)
			with the column values stored either as text nodes or attribute values.
			<strong>Note:</strong> endpoints this step exposes depend on data streams defined in the step
			configuration.
		</description>
    <properties>
		 	<property name="id" type="string" required="false">
			Step identification string.
			</property>
			<property name="encoding" type="string" required="true">
				Encoding of the output file.
			</property>
			<property name="fileName" type="string" required="true">
				Name of the output file.
			</property>
			<property name="fileTemplate" type="string" required="true">
				The overall structure of the resulting XML file, the fragment must be
				a valid XML file. The individual data streams are referenced by
				<code>&lt;dataStream name=&quot;data stream name&quot; /&gt;</code> elements. These
				special elements will be replaced by the actual data when the step is run.

				Every whitespace character (space, tab, new line break, etc.) defined in the template will be
				written to the output XML in the same way unless <code>indent</code> property is set.
			</property>
			<property name="dataStreams" type="com.ataccama.dqc.tasks.io.xml.write.XmlWriterDataStream[]" required="true">
				Definition of data streams. Each stream adds a new input endpoint and must have its
				counterpart in <code>fileTemplate</code>. Data read from the input are written
				at the place where the stream is referenced in <code>fileTemplate</code>
			</property>
            <property name="indent" type="boolean" required="true">
                Indicates to generate indented XML. In that case content of textual nodes is trimmed
                (i.e. whitespace characters removed from both sides).
                Indenting character is a tab character.
                <br/>
                Default value: <code>true</code>.
            </property>
		</properties>
  </class>
  <class name="com.ataccama.dqc.tasks.io.xml.write.XmlWriterDataStream">
    <introduction>Defines data stream to be written by XmlWriter step</introduction>
    <description>
			Records are stored into the resulting XML file by means of
			data streams. Each stream defines an input endpoint and format of an XML fragment
			that each record is serialized into. Thus for each record a new fragment is written into the file.
		</description>
    <properties>
			<property name="name" type="string" required="true">
				Name of the data stream.
			</property>
			<property name="xmlFragment" type="string" required="true">
				Defines XML fragment for each record to be written by this data stream.
				Use {<code>column_name</code>} notation to define where to place value of that column.
				It can be used in attributes as well as in textual content.
			</property>

		</properties>
  </class>
  <class super="com.ataccama.server.http.ServletFilter" name="com.ataccama.dqc.web.filters.XsltTransformFilter">
    <introduction>Filter used to apply XSL transformations to server requests and responses commonly needed for 3rd party SOAP integration.</introduction>
    <description>Filter used to apply XSL transformations to server requests and responses commonly needed for 3rd party SOAP integration.</description>
    <properties>
			<property name="requestTransformation" type="string" required="false">Request XSL transformation filename.</property> 
			<property name="responseTransformation" type="string" required="false">Response XSL transformation filename.</property>
		</properties>
  </class>
  <class super="com.ataccama.adt.file.operations.IEwfFileOperationTask" name="com.ataccama.adt.file.operations.EwfZipFileOperation">
    <introduction>Source files/folders are zipped to a zip file.</introduction>
    <description>Source files/folders are zipped to a zip file.</description>
    <properties>
			<property name="excludeParameters" type="string[]" required="false">Set of mask parameters, which are excluded from zipping.</property>
			<property name="overwriteFlag" type="boolean" required="true">Permission to overwrite the output zip file. The task fails when <strong>Overwrite Flag</strong> is false and <strong>Target File</strong> already exists.</property>
			<property name="recursiveFlag" type="boolean" required="true">Permission to zip sub-directories.</property>
			<property name="sourceFile" type="string" required="true">Path to the source mask on files/folders. The task fails when no file/directory is found to mask.</property>
			<property name="targetFile" type="string" required="true">Path to the target zip file. The task fails when <strong>Target File</strong> is an existing directory (i.e., target zip file name cannot be the same as an existing directory name).</property>
		</properties>
    <scoring/>
  </class>
</elements>