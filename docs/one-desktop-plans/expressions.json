{
  "title": "Expressions",
  "headers": [
    "Expressions",
    "Contents:",
    "Introduction",
    "Operands",
    "Handling null values",
    "Variables",
    "Operations and functions",
    "Arithmetic operations",
    "Logical operations",
    "Comparison operators",
    "Set operations",
    "Other operations",
    "Date functions",
    "String functions",
    "Coding functions",
    "Math functions",
    "Bitwise functions",
    "MinMax functions",
    "Aggregating functions",
    "Conditional expressions",
    "Conversion and formatting functions",
    "XML functions",
    "Array and structured data functions",
    "Word set operation functions",
    "Unclassified functions",
    "Regular expressions",
    "' @\" ' - syntax (single escaping)",
    "Capturing groups"
  ],
  "content": "This section describes expressions used within [branding:product.name.abbreviation] steps.\n\t\t\tPlaces where the expressions may be used are described in the description sections of the appropriate steps.\n\nExpression operands may be of a defined column type, such as INTEGER, FLOAT, LONG, STRING, DATETIME, DATE and BOOLEAN.\n\t\t\tIf a number assigned to either an INTEGER or LONG variable overflows or underflows the interval of permitted values for that type\n\t\t\t(i.e. -2147483648;+2147483647 for INTEGER and -9223372036854775808;+9223372036854775807 for LONG) then the number wraps around\n\t\t\tthe interval. E.g., the value 2147483649 assigned to an INTEGER variable is interpreted as -2147483647.\n\nOperands are automatically converted to wider type if needed. This is relevant for numeric data types\n\t\t\tINTEGER, LONG and FLOAT (widening INTEGER -> LONG -> FLOAT) and datetime types DATE and DATETIME (DATE -> DATETIME).\n\t\t\tIn case of comparisons, set and conditional operations, all operands are first converted to the most general type and then\n\t\t\tthe operation is performed.\n\nAn operand is any expression with a type corresponding to a valid type of a given operation.\n\t\t\tOperands can be divided into four categories:\n\nOperations and functions handles arguments withNULLvalue\n\t\t\tconformingSQL rules.\n\t\t\tBut there is one important exception for STRING data type.NULL stringandempty stringare consideredequal,\n\t\t\tso null string arguments are handled as empty (zero length) strings.\n\nExample:\n\nThe expression can be formed as a sequence of assignment expressions followed by one resulting expression. Multiple expressions\n\t \tare delimited by;(semicolon). Assignment expression has the following syntax:variable := expression\n\nFirst occurrence of a variable on the left hand side defines this variable and its type. Reference to variable in expression is valid\n\t \tonly after its definition. Each following occurrence of variable, including on the left hand side of assignment expression, must conform\n\t \tto variable's type.\n\nExample:\n\n[branding:product.name.abbreviation] provides the following function and operation categories:\n\nCaution:All functions and operations which do not have the \"locale\" parameter set or defined will be set to\n\t\t\tuse the default [branding:product.name.abbreviation] locale. The step locale setting does not influence this behavior.\n\nThis category includes common arithmetic operations - addition, subtraction, multiplication and division.\n\t\t\tThe result of an arithmetic operation applied to the types INTEGER and/or LONG is always INTEGER\n\t\t\tor LONG. The result is of type LONG if at least one operand was of type LONG.\n\nNote: Type NUMBER stands for date types\tINTEGER, LONG or FLOAT in the description of input and output types.\n\nCommon logical operationsAND,OR,XORandNOT(all keywords are case insensitive).\n\nRelational operators.\n\nFor sets, a few basic operations -IN,IS IN,NOT IN,IS NOT IN- are implemented.\n\t\t\tSet members are literals of types defined for columns or column names themselves.\n\nNote:env.properties are by default inaccessible from security reasons.\n\t\t\t\t\tTo retrieve the value of an environment variable (withenv.prefix), this option must now be explicitly configured for that variable.\n\t\t\t\t\tIn other words, you need to set propertyata.function.getParameterValue.allowedto a regular expression matching the enabled properties\n\t\t\t\t\t(for example,ata.function.getParameterValue.allowed=env.OS|env.TEMP).\n\t\t\t\t\tPropertiesJAVA_HOME,JRE_HOME,HOSTNAME,HOME,USER, andLANGUAGEare by default allowed.\n\t\t\t\t\tTo enable this option, proceed with the following steps, depending on your use case.\n\nRun a planIn ONE Desktop, open the plan that you want to run.In the toolbar, next to theRunoption, open the dropdown menu and selectRun Configuration.In the dialog that opens, switch to theRuntimestab.InVM arguments, add the following line:-Data.function.getParameterValue.allowed=<environment_variable>Replace the placeholder with the name of the environment variable that you want to use. To provide several variables, separate them using a vertical bar (|), for example:-Data.function.getParameterValue.allowed=env.HOMEDRIVE|env.ProgramW6432|env.DriverDataSelectApplyto save your changes. You can now selectRunto immediately execute your plan or selectCloseto continue editing it.\n\nDebug a stepMake sure ONE Desktop is not running while you are making these changes.Navigate to your ONE Desktop installation folder.Open theone-desktop.inifile in a text editor.Add the following line to the last line in the file:-Data.function.getParameterValue.allowed=<environment_variable>Replace the placeholder with the name of the environment variable that you want to use. To provide several variables, separate them using a vertical bar (|), for example:-Data.function.getParameterValue.allowed=env.HOMEDRIVE|env.ProgramW6432|env.DriverDataSave your changes and close the file.Start ONE Desktop. You can now use the specified environment variable when debugging steps.\n\nIn [branding:product.name.abbreviation], a date is represented by DATE and DATETIME types. The DATE type represents a date to the detail level of days,\n\t\t\tDATETIME to the detail level of milliseconds. The time values that are compatible with each format are named and described below.\n\nAll the listed date parts are represented by positive integers. Milliseconds is not\n\t\t\tsupported by the date functions.\n\nNote: Date type DATE-TYPE stands for date types\tDATE or DATETIME in the description of input and output types.\n\nCommon functions used for string processing.\n\nFunctions for hashing, encoding or decoding strings.\n\nTraditional mathematical functions. Return float value and usually have one float argument.\n\nBitwise functions are logical operations applied on separate bits of the operands.\n\nFunctions used for computation of minimum or maximum values.\n\nAggregating functions are special functions which can be used only in context of steps\n\t\t\tthat supports grouping of records.\n\t\t\tFor now there are two such steps -Representative CreatorandGroup Aggregator.Depending on the context, expressions containing aggregate functions distinguish between two types of sources -\n\t\t\tinner (used in arguments of any aggregated function) and outer (used outside of functions). These\n\t\t\tmay be generally different, for example when the sum of a certain attribute of all records in a group is added to another attribute of a record\n\t\t\tthat has an entirely different format and usage.\n\nEvery aggregating function has a variant for conditional evaluating. The name of the variant\n\t\t\tis derived from the original name with the appended suffixif. The conditional variant has\n\t\t\tone extra argument that is inserted before the original arguments and contains a boolean expression.\n\t\t\tThe expression specifies when the appropriate record will be included into aggregation.E.g. the expressionavg(salary)can have the conditional variantavgif(score < 100, salary).\n\nNesting of aggregate functions is not allowed. For example, the expressioncountif(salary < avg(salary))is invalid.\n\nConditional expressions are a special type of expressions where the resulting value\n\t\t\tdepends on the evaluation of certain conditions. These functions do not have strictly\n\t\t\tdefined argument types, instead they are flexible and their arguments are defined\n\t\t\tby the specific functionality of each expression.\n\nConversion functions are used for conversions and formatting the input expression.\n\nFunctions for working with XML formatted data.\n\nFunctions for arrays or structured type.\n\nWord set operation functions operate on two strings, interpreting them as sets of words\n\t\t\tseparated by the givenseparator(or space, by default) and returns the integer cardinality\n\t\t\tof the resulting set or, in some cases, the resulting set itself.\n\nIf the parametermultisetis set toTRUE, the sets are treated as \"multisets\",\n\t\t\te.g. two identical words in one set form two members of the set rather than one. When multiset\n\t\t\tisFALSE(default), identical words are first deduplicated.\n\nThree of function (intersection, difference, symmetricDifference) have variants named\n\t\t\twith prefixlcs(i.e.lcsIntersection). These variants are based\n\t\t\ton concept that intersection of two (word) lists is defined\n\t\t\tasLongest Common Subsequention.\n\t\t\tIn this case, the order/duplicity of elements in lists is significant.For example, two lists a = 'C A D B A' and b = 'A E B C D', whose \"normal\" intersection is set 'A B C D',\n\t\t\thave \"lcs\" intersection 'A B' (or 'C D', 'A D'), and so lcsIntersection(a, b) = 2,\n\t\t\tlcsDifference(a, b) = 2 (or 3 in multiset case), lcsSymmetricDifference(a, b) = 5 (or 6).\n\nThe two types of difference functions can be executed with an optional integer parameter,singularity, which distinguishes\n\t\t\tsets that have common members from sets without common members.\n\t\t\tWhen this parameter is used, the function returns a value (typically a very large number) when the sets have an empty intersection.For example:difference('A B', 'C D') = 2. The typical result.\n\t\t\tThe difference between completely different sets may have the same value\n\t\t\tas the difference between, for example, very similar sets 'A B C D E' and 'A B C F G'.difference('A B', 'C D', 1000) = 1000. Using thesingularityparameter yields a different result,\n\t\t\twhich shows that the difference between completely different sets is high.\n\nMost of the functions have variant with name extended by suffix \"Exp\" (e.g. intersectionExp).\n\t\t\tThese variants have one appended optional argumentcomparator. This argument is\n\t\t\t\"functional parameter\" and defines how the elements in sets will be compared to determine if they are the same.\n\t\t\tThe functional parameter must take two string value and return boolean result and, of course, the result must not depend on\n\t\t\targument order.\n\nThe functional argument in general is similar to function definition and has following syntax:\n\nThe columns an variables are accessible inside the function body.\n\nWhen using functional comparator, the calculation of intersection of two sets\n\t\t\tis quite different from \"normal\" set operation, because we cannot assume\n\t\t\tthe comparator conforms equality relation. In both set operands A resp. B we determine\n\t\t\tsubsets A' resp. B' of members that have at least one matching member in opposite set.\n\t\t\tSince these subsets may have different sizes, the size of intersection is defined as the first one.\n\nExamples of using last functional parameters:\n\nWhen std_name = \"AAA BBB AAA ABC\" and std_hh_names = \"AAB AAA CCC BBC\" and multi = TRUE, then\n\t\t\tthe first case gives 6 (one pair of AAA), second is 6 (all three AAA paired)\n\t\t\tand third is 1 (only CCC remains unpaired).\n\nOther [branding:product.name.abbreviation] operations.\n\nThe syntax for regular expressions in [branding:product.name.abbreviation] follows the rules for regular expressions\n\t\tused in Java described inClass Pattern documentation.\n\nThe following sections contain the information about regular expression usage extensions\n\t\tin [branding:product.name.abbreviation].\n\nWhen writing regular expressions, one must take into consideration\n\t\tthat the regular expression is manipulated as a Java string. In literal Java strings the backslash\n\t\tis an escape character. The literal string '\\\\' is a single backslash.\n\t\tIn regular expressions, the backslash is also an escape character.\n\t\tThe regular expression '\\\\' matches a single backslash. This regular expression\n\t\tas a Java string, becomes '\\\\\\\\'. To avoid the use of the double escaping,\n\t\tprefix the string in quotes with '@'. In that case the string inside the '@\"' and\n\t\t'\"' will be taken as literals, and no characters will be considered escape characters\n\t\tin the context of Java string.\n\nMatching of regular expressions in the input is done by analyzing the input\n\t\texpression string (the string resulting from applying the expression to the input). Sections of\n\t\tthe\tinput string (called \"capturing groups\", enclosed in parenthesis) are identified and\n\t\tmarked for further use in creating the output. These capturing groups can be referenced\n\t\tby using back-reference (see below for syntax).\n\nIn the case of a match, the \"matched\" data from the input are sent to predefined output\n\t\tcolumns. Each output column has asubstitutionproperty which is the value\n\t\tthat will be sent to the output. It can contain the above mentioned back-references with\n\t\tthe following syntax:\n\nThe capturing groups might be used in expressionssubstituteAll, substitutaManyand in the stepRegex Matching.\n\nFor example, to substitute all pairs of letter-digit couples with just the digit from the couple (i.e. the\n\t\t\t\tinput string \"a1b2c3d4e5\" leads to the output \"12345\") one might write"
}