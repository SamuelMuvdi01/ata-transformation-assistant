{
  "title": "Unification",
  "headers": [
    "Unification",
    "Contents:",
    "Unification",
    "Candidate groups",
    "Basic method: SimpleKey",
    "Symmetric merging method: Union",
    "Hierarchical merging method: Hierarchical / ClassicHierarchical",
    "Hierarchical with union merging method: HierarchicalUnion",
    "Matching groups",
    "Unification roles",
    "Manual override",
    "Stability of assigned group IDs"
  ],
  "content": "Unification is based on finding groups of records which belong to one logical entity\n\t\t(usually calledclient) by a certain set of criteria.\n\t\tThe grouping process consists of two stages – dividing records into widercandidate groupsand then narrowing them intomatching subgroups.\n\t\tIn addition, some rules, calledManual overrides, can be applied for exceptions to assigning \n\t\tparticular records into matching groups.\n\nThere are four methods of establishing candidate groups.\n\t\tEach of them defines one or morekeysfor each record.\n\t\tThe key can be composed of one or morecomponentsas results of expressions\n\t\tevaluated on the record. The keys can be assumedemptyif all\n\t\tits components are null and/or according to some specialno-keycondition.\n\nEach candidate group is identified by its number, calledCandidate ID.\n\nThe candidate group consists of records with the sameonekey.\n\nDefinition:Records Z and Y belongs to one candidate group,\n\t\t\twhen key(Z) = key(Y) and this key is not empty.\n\nThere areseveralkeys defined and each of them have the no-key condition.\n\t\t\tThe candidate groups consist of records which have at least one key equal and nonempty.\n\nDefinition:Assume keyn(Z) is nth key of record Z,then records Z and Y belong to one candidate group\n\t\t\twhen keyi(Z) = keyi(Y) and this key is nonempty for some i.\n\nThe previous SimpleKey method can be considered as a special case of Union with just one key.\n\nThere are two keys defined –primary keyandsecondary keyand there are no-key conditions both of for them. This method is intended for widening primary groups\n\t\t\t(based on the primary key) by additional records having and empty primary key,\n\t\t\tbut belonging to the same secondary group (based on the secondary key)\n\t\t\tas some record from primary group.\n\nNote: in this context, the term \"primary key\" means \"key determining\n\t\t\tprimary grouping\", not the usual database meaning as the unique key of a particular record.\n\nDefinition:Assume P(Z) and S(Z) are terms for primary and secondary, respectively, keys of record Z\n\t\t\tand G(prim=p) is a candidate group for the nonempty primary key p, then:All records Z with P(Z) = p belongs to G(prim=p)Record Z having empty P(Z) belongs to G(prim=p) if S(Z) is nonempty\n\t\t\t\t\tand there is at least one record Y having P(Y) = p and S(Y) = S(Z)\n\t\t\t\t\tand there is no other record X having S(X) = S(Z) but P(X) <> p.\n\t\t\t\t\t(i.e., the secondary key unambiguously \"connects\" records to only one primary group)Records Z with empty P(Z) and nonempty S(Z) = s but not satisfying the \n\t\t\t\t\trest of rule b) are collected to candidate group G(sec=s)\n\nThe method has two variants which differ in way the primary and secondary keys\n\t\t\tand no-key conditions are defined. The Hierarchical variant defines general\n\t\t\tkeys, which can be assembled from any components and general no-key conditions.\n\t\t\tThe ClassicHierarchical variant is based on common usage of a hierarchical method,\n\t\t\twhen the primary and secondary groups are candidate or matching groups of preceding\n\t\t\ttwo unifications and no-key conditions are firmly derived from related unification roles.\n\nThe method is a modification of the previous Hierarchical method.\n\t\t\tIt defines one primary key butmoresecondary keys,\n\t\t\twhich are used likewise in the Union method to assembly the secondary group.\n\t\t\tAccording to the second condition of the previous Hierarchical method,\n\t\t\tthe record with the empty primary key can be appended to some primary group\n\t\t\tif there is some \"chain\" of such records each having some other secondary\n\t\t\tkey equal and the chain leads unambiguously to the primary group.\n\nIn the second stage of unification, the candidate groups are divided into matching groups.The matching groups are created by repetitive selection of the best record (pivot)\n\t\tfrom remaining records of the candidate group and then adding all records (candidate)\n\t\twhich aresimilarto this pivot.\n\t\tThe rating of quality is defined by thepivot selection ruleand similarity by thematching rule.\n\t\tThe number of such pivot selections, and thus the number of matching groups in one candidate group, are limited.\n\t\tPotential records from a candidate group which haven't been assigned to any pivot\n\t\tare calledrenegades.\n\nEach matching group is identified by its number, calledMatching ID.\n\nAll records passed through the unification process obtain two integer IDs of\n\t\tcandidate and matching group.\n\t\tIn addition, the record is marked withUnification role, which\n\t\tcan take the following values:NRecord have no regular key for candidate groupingMThe best record of one candidate group, pivot of initially established\n\t\t\t\tmatching group in candidate groupINext selected pivots of other matching groups in candidate groupSOther records similar to some pivot and attached to its matching groupRRenegades, records not similar to any pivot in candidate groupOSpecial pivot role obtained in manual override processing (see the following description)\n\nRegular rules for creating matching groups can be modified by a list of special explicitly\n\t\tset rules. A manual override rule is always related to a concrete record identified\n\t\tby its unique primary key. So each rule has a primary key of record and eventually\n\t\tanother primary key of aparentrecord.Types of manual override rules:R -> CRecord has to be in its own group.The record is not assigned to any group, it forms a new one-member group\n\t\t\t\tand its unification role will be \"O\" (overridden pivot).C + RRecord has to be assigned to another group.The record is assigned to the group in which its parent belongs.C + CGroup has to be appended to another group.The whole group into which the record has been assigned is appended to the group in which its parent belongs.For example, the rule {C+R,1234,4321} (rule of type C+R for record with primary key 1234\n\t\tand parent record with primary key 4321) says that record 1234 always belongs to the same matching group\n\t\tas record 4321, even if they are not in a common candidate group.\n\nThe manual override rules are contained in theRepositoryand can be edited\n\t\tviaManual Override BuilderorIncremental Manual Override Builder.\n\nThere can be one exception during processing of the rules C+R or C+C (which are related to some\n\t\tparent record) - when the parent record is not found. Then there is no way to assign the record\n\t\tto any matching group and the record is marked as anorphan. The orphans make a stand-alone\n\t\tmatching group (one-member in the case of C+R, multi-member for C+C) and its pivot record takes the unification\n\t\trole \"O\" (overridden pivot). The same case happens if manual override rules cause a cycle in dependency\n\t\ton parents.\n\nMoreover, for rules of type C+C, it can happen that the parent record of the rule belongs\n\t\tto the same group as the record whose group has to be appended (in other words, the rule says that\n\t\tthe group should be appended to itself and so it is needless). In this \"self parent\" case\n\t\tthis group remains unchanged but its pivot record take the unification role \"O\" (overridden pivot).\n\nThe records obtain the special markManual Override Rolespecifying if and how\n\t\tthey were affected by some manual override rules.Manual override roles:NNormal, unaffected by any ruleOAffected by some rulePParent of some rule and is not assigned to other parentSOrphan\n\nCandidate and matching groups are identified by their numeric IDs, which are assigned in \n\t\tincreasing sequence when the new group is established. During incremental updating of the \n\t\trecord set and rearranging groups caused by adding or deleting records or changes of\n\t\trecord keys or other attributes, there is an effort to keep already used group IDs as much\n\t\tas possible. From this reason, only one record of each group is called theMerge survivoror, in other words, the \"carrier\" of group ID.\n\nWhen the new group (candidate or matching) is formed, the following cases can occur:The group doesn't contain any carrierThen the group obtains a new ID from the sequence and the a carrier is determined.The group contains just one carrier (inherited from some previous group)Then the group obtains the ID of this carrier.The group contains two or more carriers (coming from some previous groups)Then the \"best\" carrier, depending on some selection rule, is chosen and the group\n\t\t\tobtains its ID. Other carriers lose their IDs and from now on are not carriers.\n\nThere are two strategies for determining which record is assumed as the Merge survivor (carrier of the ID):When a new ID is assigned to a group, one record is selected depending on certainMerge survivor selection rulesand this record is marked as the Merge survivor.\n\t\t\t\tThis mark is stored intoMerge Survivor Rolewhich contains combination of two letters\n\t\t\t\tdescribed below.The record marked as the pivot of group is assumed to be the ID carrier. So, when the pivot of\n\t\t\tsome previous group has moved to a newly formed group, it can carry the previous group ID even if \n\t\t\tit is not selected as the pivot of the new group. Simultaneously, the previous group loses its ID.The switchusePivotAsSurvivorof unification defines which strategy should be used.\n\nMerge survivor roles and their unify role analogySTMerge survivor for both candidate and matching IDs (unification roles M, N)NTMerge survivor for matching ID only (unification roles I, R)SNMerge survivor for candidate ID onlyNNRecord is not merge survivor (unification role S)\n\nEven if the record carrying the group ID is currently deleted from repository, it can still give its ID\n\t\tto the group to which it could have belonged if not deleted."
}